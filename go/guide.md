<!--* toc_depth: 3 *-->

# Go 风格指南

https://google.github.io/styleguide/go/guide

[概述](index) | [指南](guide) | [决策](decisions) |
[最佳实践](best-practices)

<!--

-->

{% raw %}

**注意：** 这是概述 Google [Go 风格](index) 的一系列文档的一部分。本文档是**[规范性](index#normative)和[权威性](index#canonical)**的。有关更多信息，请参见[概述](index#about)。

<a id="principles"></a>

## 风格原则

有一些总体的原则可以概括如何编写可读的 Go 代码。以下是可读代码的属性，按重要性排序：

1.  **[清晰性]**：代码的目的和原理对读者来说是清楚的。
2.  **[简洁性]**：代码以最简单的方式实现其目标。
3.  **[精炼性]**：代码具有很高的信噪比。
4.  **[可维护性]**：代码的编写方式使其易于维护。
5.  **[一致性]**：代码与更广泛的 Google 代码库保持一致。

[清晰性]: #clarity
[简洁性]: #simplicity
[精炼性]: #concision
[可维护性]: #maintainability
[一致性]: #consistency

<a id="clarity"></a>

### 清晰性

可读性的核心目标是生成对读者来说清晰的代码。

清晰性主要通过有效的命名、有用的注释和高效的代码组织来实现。

清晰性应从读者的角度来看，而不是代码作者的角度。代码易于阅读比易于编写更重要。代码的清晰性有两个不同的方面：

*   [代码实际上在做什么？](#clarity-purpose)
*   [代码为什么要这样做？](#clarity-rationale)

<a id="clarity-purpose"></a>

#### 代码实际上在做什么？

Go 的设计使得相对容易看出代码在做什么。在不确定或读者可能需要先验知识才能理解代码的情况下，值得投入时间，以便使代码的目的对未来的读者更清楚。例如，它可能有助于：

*   使用更具描述性的变量名
*   添加额外的注释
*   用空格和注释分隔代码
*   将代码重构为单独的函数/方法，使其更模块化

这里没有一刀切的方法，但在开发 Go 代码时，优先考虑清晰性非常重要。

<a id="clarity-rationale"></a>

#### 代码为什么要这样做？

代码的原理通常可以通过变量、函数、方法或包的名称充分传达。如果不是这样，添加注释非常重要。“为什么？”在代码包含读者可能不熟悉的细微差别时尤其重要，例如：

*   语言中的细微差别，例如，闭包将捕获循环变量，但闭包距离很远
*   业务逻辑的细微差别，例如，需要区分实际用户和冒充用户的访问控制检查

API 可能需要小心使用才能正确使用。例如，一段代码可能出于性能原因而复杂且难以理解，或者复杂的数学运算序列可能以意想不到的方式使用类型转换。在这些情况下以及更多情况下，重要的是随附的注释和文档解释这些方面，以便未来的维护人员不会犯错，并且读者可以理解代码而无需进行逆向工程。

同样重要的是要注意，一些提供清晰性的尝试（例如添加额外的注释）实际上可能会通过添加混乱、重述代码已经说明的内容、与代码相矛盾或增加维护负担以保持注释的最新状态来模糊代码的目的。让代码自己说话（例如，通过使符号名称本身具有自我描述性），而不是添加冗余注释。通常，注释最好解释为什么要做某事，而不是代码在做什么。

Google 代码库在很大程度上是统一和一致的。通常情况下，突出的代码（例如，通过使用不熟悉的模式）这样做是有充分理由的，通常是为了性能。保持此属性对于让读者清楚地知道在阅读新代码时应将注意力集中在哪里非常重要。

标准库包含许多此原则的实际示例。其中：

*   [`package sort`](https://cs.opensource.google/go/go/+/refs/tags/go1.19.2:src/sort/sort.go) 中的维护者注释。
*   良好的[同一包中的可运行示例](https://cs.opensource.google/go/go/+/refs/tags/go1.19.2:src/sort/example_search_test.go)，这使用户（它们[显示在 godoc 中](https://pkg.go.dev/sort#pkg-examples)）和维护者（它们[作为测试的一部分运行](decisions#examples)）都受益。
*   [`strings.Cut`](https://pkg.go.dev/strings#Cut) 只有四行代码，但它们提高了[调用点的清晰度和正确性](https://github.com/golang/go/issues/46336)。

<a id="simplicity"></a>

### 简洁性

您的 Go 代码对于使用、阅读和维护它的人来说应该是简单的。

Go 代码应该以最简单的方式编写，以实现其目标，无论是在行为还是性能方面。在 Google Go 代码库中，简单的代码：

*   易于从上到下阅读
*   不假设您已经知道它在做什么
*   不假设您可以记住所有前面的代码
*   没有不必要的抽象级别
*   没有使人注意平凡事物的名称
*   使值和决策的传播对读者来说是清楚的
*   有注释解释为什么，而不是代码在做什么，以避免未来的偏差
*   有独立的文档
*   有有用的错误和有用的测试失败
*   通常可能与“聪明”的代码互斥

代码简洁性和 API 使用简洁性之间可能会出现权衡。例如，可能值得使代码更复杂，以便 API 的最终用户可以更轻松地正确调用 API。相反，也可能值得将一些额外的工作留给 API 的最终用户，以便代码保持简单易懂。

当代码需要复杂性时，应有意识地添加复杂性。如果需要额外的性能，或者特定库或服务有多个不同的客户，通常需要这样做。复杂性可能是合理的，但应附带文档，以便客户端和未来的维护人员能够理解和驾驭复杂性。这应该辅以测试和示例，以演示其正确用法，尤其是在使用代码时既有“简单”方式又有“复杂”方式的情况下。

此原则并不意味着不能或不应在 Go 中编写复杂的代码，或者不允许 Go 代码复杂。我们努力创建一个避免不必要复杂性的代码库，以便当复杂性出现时，它表明所讨论的代码需要小心理解和维护。理想情况下，应该有随附的注释来解释原理并识别应采取的预防措施。这通常在优化代码以提高性能时出现；这样做通常需要更复杂的方法，例如预先分配缓冲区并在整个 goroutine 生命周期中重复使用它。当维护人员看到这一点时，应该是一个线索，表明所讨论的代码对性能至关重要，并且应该影响在进行未来更改时所采取的预防措施。另一方面，如果不必要地使用，这种复杂性会给那些需要阅读或更改代码的人带来负担。

如果代码的目的应该是简单的，但结果却非常复杂，这通常是一个信号，表明需要重新审视实现，看看是否有更简单的方法来实现相同的目标。

<a id="least-mechanism"></a>

#### 最小机制

如果有几种方法可以表达相同的想法，请选择使用最标准工具的一种。通常存在复杂的机制，但不应在没有理由的情况下使用。根据需要向代码添加复杂性很容易，而删除现有复杂性（在发现不必要之后）要困难得多。

1.  当核心语言构造（例如通道、切片、映射、循环或结构）足以满足您的用例时，请尝试使用它。
2.  如果没有，请在标准库中查找工具（例如 HTTP 客户端或模板引擎）。
3.  最后，在引入新依赖项或创建自己的依赖项之前，请考虑 Google 代码库中是否有足够的核心库。

例如，考虑包含绑定到变量的标志的生产代码，该变量具有必须在测试中覆盖的默认值。除非打算测试程序本身的命令行界面（例如，使用 `os/exec`），否则直接覆盖绑定值比使用 `flag.Set` 更简单，因此更可取。

同样，如果一段代码需要集合成员资格检查，则布尔值映射（例如，`map[string]bool`）通常就足够了。仅当需要更复杂的操作（使用映射无法实现或过于复杂）时，才应使用提供类似集合的类型和功能的库。

<a id="concision"></a>

### 精炼性

简洁的 Go 代码具有很高的信噪比。很容易辨别相关的细节，并且命名和结构引导读者了解这些细节。

有很多事情会妨碍在任何给定时间显示最显着的细节：

*   重复的代码
*   无关的语法
*   [不透明的名称](#naming)
*   不必要的抽象
*   空格

重复的代码尤其会模糊每个几乎相同的部分之间的差异，并且需要读者直观地比较相似的代码行以查找更改。[表驱动测试] 是一个很好的例子，说明了一种可以简洁地从每次重复的重要细节中分解出公共代码的机制，但是选择将哪些部分包含在表中将影响表的易于理解程度。

在考虑多种构建代码的方式时，值得考虑哪种方式使重要的细节最明显。

理解和使用常见的代码结构和习惯用法对于保持高信噪比也很重要。例如，以下代码块在 [错误处理 ]中非常常见，读者可以快速理解此块的目的。

```go
// 好：
if err := doSomething(); err != nil {
    // ...
}
```

如果代码看起来与此非常相似但略有不同，则读者可能不会注意到更改。在这种情况下，值得通过添加注释来引起注意，从而有意识地 ["增强"] 错误检查的信号。

```go
// 好：
if err := doSomething(); err == nil { // 如果没有错误
    // ...
}
```

[表驱动测试]: https://github.com/golang/go/wiki/TableDrivenTests
[错误处理]: https://go.dev/blog/errors-are-values
["增强"]: best-practices#signal-boost

<a id="maintainability"></a>

### 可维护性

代码被编辑的次数远多于编写的次数。可读的代码不仅对试图理解其工作原理的读者有意义，而且对需要更改它的程序员也有意义。清晰是关键。

可维护的代码：

*   易于未来的程序员正确修改
*   具有结构化的 API，以便它们可以优雅地增长
*   清楚地了解它所做的假设，并选择映射到问题结构的抽象，而不是代码的结构
*   避免不必要的耦合，并且不包含未使用的功能
*   具有全面的测试套件，以确保维护承诺的行为并且重要逻辑正确，并且测试在发生故障时提供清晰、可操作的诊断

当使用抽象（如接口和类型）时，这些抽象根据定义从它们使用的上下文中删除信息，因此务必确保它们提供足够的好处。编辑器和 IDE 可以直接连接到方法定义，并在使用具体类型时显示相应的文档，但只能引用接口定义。接口是一种强大的工具，但会带来成本，因为维护人员可能需要了解底层实现的细节才能正确使用接口，这必须在接口文档或调用站点中进行解释。

可维护的代码还可以避免将重要细节隐藏在容易被忽视的地方。例如，在以下每一行代码中，单个字符的存在或缺失对于理解该行至关重要：

```go
// 坏：
// 使用 = 而不是 := 可以完全改变这一行。
if user, err = db.UserByID(userID); err != nil {
    // ...
}
```

```go
// 坏：
// 这一行中间的 ! 很容易错过。
leap := (year%4 == 0) && (!(year%100 == 0) || (year%400 == 0))
```

这些都不是不正确的，但都可以以更明确的方式编写，或者可以附带注释来引起对重要行为的注意：

```go
// 好：
u, err := db.UserByID(userID)
if err != nil {
    return fmt.Errorf("无效的来源用户：%s", err)
}
user = u
```

```go
// 好：
// 格里高利闰年不仅仅是 year%4 == 0。
// 请参阅 https://en.wikipedia.org/wiki/Leap_year#Algorithm。
var (
    leap4   = year%4 == 0
    leap100 = year%100 == 0
    leap400 = year%400 == 0
)
leap := leap4 && (!leap100 || leap400)
```

以同样的方式，隐藏关键逻辑或重要边缘情况的辅助函数可能会使未来的更改很容易无法正确考虑它。

可预测的名称是可维护代码的另一个特征。包的用户或一段代码的维护者应该能够在给定上下文中预测变量、方法或函数的名称。相同概念的函数参数和接收器名称通常应共享相同的名称，既要保持文档的可理解性，又要方便以最小的开销重构代码。

可维护的代码最大限度地减少其依赖项（包括隐式和显式）。依赖于较少的包意味着可以影响行为的代码行数更少。避免依赖于内部或未记录的行为使得代码在这些行为在未来发生变化时不太可能带来维护负担。

在考虑如何构建或编写代码时，值得花时间思考代码可能随时间演变的方式。如果给定的方法更有利于更容易和更安全的未来更改，那么这通常是一个很好的权衡，即使这意味着稍微复杂的设计。

<a id="consistency"></a>

### 一致性

一致的代码是指看起来、感觉和行为都类似于整个代码库中、团队或包的上下文中，甚至在单个文件中类似的代码。

一致性问题不会覆盖上述任何原则，但如果必须打破平局，则通常有利于打破它以支持一致性。

包内的一致性通常是最重要的即时一致性级别。如果在整个包中以多种方式处理相同的问题，或者如果相同概念在文件中具有多个名称，则可能会非常不协调。但是，即使这样也不应覆盖已记录的样式原则或全局一致性。

<a id="core"></a>

## 核心指南

这些指南收集了所有 Go 代码都应遵循的 Go 风格的最重要方面。我们希望在授予可读性时学习并遵循这些原则。预计这些原则不会经常更改，并且新添加的内容必须清除高标准。

以下指南扩展了 [Effective Go] 中的建议，该建议为整个社区的 Go 代码提供了共同的基线。

[Effective Go]: https://go.dev/doc/effective_go

<a id="formatting"></a>

### 格式化

所有 Go 源文件都必须符合 `gofmt` 工具输出的格式。此格式由 Google 代码库中的预提交检查强制执行。[生成的代码] 通常也应该格式化（例如，通过使用 [`format.Source`]），因为它也可以在代码搜索中浏览。

[生成的代码]: https://docs.bazel.build/versions/main/be/general.html#genrule
[`format.Source`]: https://pkg.go.dev/go/format#Source

<a id="mixed-caps"></a>

### MixedCaps

Go 源代码在编写多字名称时使用 `MixedCaps` 或 `mixedCaps`（驼峰式），而不是下划线（蛇形式）。

即使它违反了其他语言的约定，也适用。例如，如果导出常量，则常量为 `MaxLength`（而不是 `MAX_LENGTH`），如果未导出，则常量为 `maxLength`（而不是 `max_length`）。

为了选择初始大小写的目的，局部变量被认为是 [未导出的]。

<!--#include file="/go/g3doc/style/includes/special-name-exception.md"-->

[未导出的]: https://go.dev/ref/spec#Exported_identifiers

<a id="line-length"></a>

### 行长度

Go 源代码没有固定的行长度。如果一行感觉太长，请优先考虑重构而不是拆分它。如果它已经尽可能短，则应允许该行保持较长。

不要拆分行：

*   在 [缩进更改](decisions#indentation-confusion) 之前（例如，函数声明、条件）
*   为了使长字符串（例如，URL）适合多个较短的行

<a id="naming"></a>

### 命名

命名与其说是科学，不如说是艺术。在 Go 中，名称往往比许多其他语言中的名称短一些，但相同的 [一般准则] 适用。名称应：

*   在使用时不要感到 [重复](decisions#repetition)
*   考虑上下文
*   不要重复已经清楚的概念

您可以在 [决策](decisions#naming) 中找到有关命名的更具体指导。

[一般准则]: https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html

<a id="local-consistency"></a>

### 局部一致性

如果样式指南对特定的样式点没有任何说明，则作者可以自由选择他们喜欢的样式，除非附近的（通常在同一文件或包中，但有时在团队或项目目录中）代码对该问题采取了一致的立场。

**有效** 的局部样式考虑因素示例：

*   使用 `%s` 或 `%v` 格式化打印错误
*   使用缓冲通道代替互斥锁

**无效** 的局部样式考虑因素示例：

*   代码的行长度限制
*   使用基于断言的测试库

如果局部样式与样式指南不一致，但可读性影响仅限于一个文件，则通常会在代码审查中显示，其中一致的修复将超出所讨论的 CL 的范围。此时，可以提交一个错误来跟踪修复。

如果更改会使现有的样式偏差恶化，将其暴露在更多的 API 表面上，扩大偏差存在的文件数量，或者引入实际的错误，那么局部一致性不再是违反新代码样式指南的有效理由。在这些情况下，作者应该在同一个 CL 中清理现有的代码库，在当前 CL 之前执行重构，或者找到至少不会使局部问题恶化的替代方案。

<!--

-->

{% endraw %}
