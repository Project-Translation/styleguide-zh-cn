<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="styleguide.xsl"?>
<GUIDE title="Google Common Lisp Style Guide">


<p align="right">

Revision 1.28
</p>


<address>
Robert Brown
</address>
<address>
  <a HREF="mailto:tunes@google.com">François-René Rideau</a>
</address>

<address>
   In memoriam Dan Weinreb
</address>

<p align="center">
<cite>Patterns mean "I have run out of language."</cite> — Rich Hickey
</p>


<OVERVIEW>
<CATEGORY title="Important Note">
  <STYLEPOINT title="Note: Displaying Hidden Details in this Guide">
     <SUMMARY>
       This style guide contains many details
       that are initially hidden from view.
       They are marked by the triangle icon, which you see here on your left.
       Click it now. You should see "Hooray" appear below.
     </SUMMARY>
     <BODY>
       <p>
        Hooray!  Now you know you can expand points to get more details.
        Alternatively, there's an "expand all" at the top of this document.
       </p>
     </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="Background">
  <p>
    Common Lisp 是一种强大的多范式编程语言。
    能力越大，责任越大。
  </p>
  <p>
    本指南推荐格式和风格选择，
    旨在使您的代码更容易被其他人理解。
    对于我们在 Google 开发的那些内部应用程序和自由软件库，
    您在进行更改时应遵守这些准则。
    但请注意，每个项目都有其自身的规则和习惯，
    这些规则和习惯补充或覆盖了这些通用准则；
    例如，以速度为导向的 QPX 低价搜索引擎
    与 QRes 预订系统具有非常不同的风格和感觉。
  </p>
  <p>
    如果您在 Google 之外编写 Common Lisp 代码，
    我们邀请您考虑这些准则。
    您可能会发现其中一些在不与您拥有的其他优先级冲突的情况下很有用。
    我们欢迎您提出关于如何改进我们的指南的意见和建设性反馈，以及
    关于哪些替代风格适合您以及原因。
  </p>
  
  <p>
    本指南不是 Common Lisp 教程。
    有关该语言的基本信息，请查阅
    <a HREF="http://www.gigamonkeys.com/book/">Practical Common Lisp</a>。
    有关语言参考，请查阅
    <a HREF="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">Common Lisp HyperSpec</a>。
    有关更详细的风格指导，请（略带保留地）查看 Peter Norvig 和 Kent Pitman 的
    <a HREF="http://norvig.com/luv-slides.ps">style guide</a>。
  </p>
</CATEGORY>
</OVERVIEW>
<CATEGORY title="Meta-Guide">
  <STYLEPOINT title="Must, Should, May, or Not">
    <SUMMARY>
      Each guideline's level of importance is indicated
      by use of the following keywords and phrases, adapted from
      <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
    </SUMMARY>
    <BODY>
      <table>
        <tr>
          <th valign="top">MUST</th>
          <td>
            <p>
              This word, or the terms "REQUIRED" or "SHALL",
              means that the guideline is an absolute requirement.
              You must ask permission to violate a MUST.
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">MUST NOT</th>
          <td>
            <p>
              This phrase, or the phrase "SHALL NOT",
              means that the guideline is an absolute prohibition.
              You must ask permission to violate a MUST NOT.
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">SHOULD</th>
          <td>
            <p>
              This word, or the adjective "RECOMMENDED", means that
              there may exist valid reasons in particular circumstances
              to ignore the demands of the guideline, but
              the full implications must be understood and carefully weighed
              before choosing a different course.
              You must ask forgiveness for violating a SHOULD.
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">SHOULD NOT</th>
          <td>
            <p>
              This phrase, or the phrase "NOT RECOMMENDED", means that
              there may exist valid reasons in particular circumstances
              to ignore the prohibitions of this guideline, but
              the full implications should be understood and carefully weighed
              before choosing a different course.
              You must ask forgiveness for violating a SHOULD NOT.
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">MAY</th>
          <td>
            <p>
              This word, or the adjective "OPTIONAL",
              means that an item is truly optional.
            </p>
          </td>
        </tr>
      </table>
      <p>
        Unlike RFCs, we don't capitalize every instance of one of the above
        keywords when it is used.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Permission and Forgiveness">
    <SUMMARY>
      There are cases where transgression of some of these rules
      is useful or even necessary.
      In some cases, you must seek permission or obtain forgiveness
      from the proper people.
    </SUMMARY>
    <BODY>
      <p>
        Permission comes from the owners of your project.
      </p>
      
      <p>
        Forgiveness is requested in a comment
        near the point of guideline violation,
        and is granted by your code reviewer.
        The original comment should be signed by you, and
        the reviewer should add a signed approval to the comment at review time.
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Conventions">
    <SUMMARY>
      You MUST follow conventions. They are not optional.
    </SUMMARY>
    <BODY>
      <p>
        Some of these guidelines are motivated by universal principles of good programming.
        Some guidelines are motivated by technical peculiarities of Common Lisp.
        Some guidelines were once motivated by a technical reason,
        but the guideline remained after the reason subsided.
        Some guidelines, such those about as comments and indentation,
        are based purely on convention, rather than on clear technical merit.
        Whatever the case may be, you must still follow these guidelines,
        as well as other conventional guidelines
        that have not been formalized in this document.
      </p>
      <p>
        You MUST follow conventions.
        They are important for readability.
        When conventions are followed by default,
        violations of the convention are a signal
        that something notable is happening and deserves attention.
        When conventions are systematically violated,
        violations of the convention are a distracting noise
        that needs to be ignored.
      </p>
      <p>
        Conventional guidelines <em>are</em> indoctrination.
        Their purpose is to make you follow the mores of the community,
        
        so you can more effectively cooperate with existing members.
        It is still useful to distinguish the parts that are technically motivated
        from the parts that are mere conventions,
        so you know when best to defy conventions for good effect,
        and when not to fall into the pitfalls that the conventions are there to help avoid.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Old Code">
    <SUMMARY>
      Fix old code as you go.
    </SUMMARY>
    <BODY>
      <p>
        A lot of our code was written before these guidelines existed.
        You should fix violations as you encounter them
        in the course of your normal coding.
      </p>
      <p>
        You must not fix violations en masse
        without warning other developers and coordinating with them,
        so as not to make the merging of large branches
        more difficult than it already is.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Future Topics">
    <SUMMARY>
      There are many topics for additional standardization
      not covered by current version of this document,
      but deferred to future versions.
    </SUMMARY>
    <BODY>
      <ul>
        <li>
          File and directory structure
        </li>
        <li>
          Packages and modularity
        </li>
        <li>
          Threads and locking
        </li>
        <li>
          How to add configurable components
        </li>
        <li>
          CLOS style: initforms, slot and accessor names, etc.
        </li>
        <li>
          Recommendations on max number of slots per class.
        </li>
        <li>
          More concrete examples of good code:
          <ul>
            <li>
              exceptions
            </li>
            <li>
              transactions, with retry
            </li>
            <li>
              XML
            </li>
            <li>
              typing
            </li>
            <li>
              encapsulation / abstraction
            </li>
            <li>
              class and slot names
            </li>
            <li>
              etc.
            </li>
          </ul>
        </li>
        <li>
          When (not) to use conditional compilation:
          <ul>
            <li>
              modifying the product
            </li>
            <li>
              conditional debugging/console output/etc.
            </li>
            <li>
              "temporarily" commenting-out blocks of code
            </li>
            <li>
              etc.
            </li>
          </ul>
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
  </CATEGORY>
<CATEGORY title="General Guidelines">
  <STYLEPOINT title="Principles">
    <SUMMARY>
      There are some basic principles for team software development
      that every developer must keep in mind.
      Whenever the detailed guidelines are inadequate, confusing or contradictory,
      refer back to these principles for guidance:
      <ul>
        <li>
          Every developer's code must be easy for another developer
          to read, understand, and modify
          — even if the first developer isn't around to explain it.
          (This is the "hit by a truck" principle.)
        </li>
        <li>
          Everybody's code should look the same.
          Ideally, there should be no way to look at lines of code
          and recognize it as "Fred's code" by its style.
        </li>
        <li>
          Be precise.
        </li>
        <li>
          Be concise.
        </li>
        <li>
          KISS — Keep It Simple, Stupid.
        </li>
        <li>
          Use the smallest hammer for the job.
        </li>
        <li>
          Use common sense.
        </li>
        <li>
          Keep related code together.
          Minimize the amount of jumping around
          someone has to do to understand an area of code.
        </li>
      </ul>
    </SUMMARY>
    <BODY>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Priorities">
    <SUMMARY>
      <p>
        When making decisions about how to write a given piece of
        code, aim for the following -ilities in this priority order:
      </p>
      <ul>
        <li>
          Usability by the customer
        </li>
        <li>
          Debuggability/Testability
        </li>
        <li>
          Readability/Comprehensibility
        </li>
        <li>
          Extensibility/Modifiability
        </li>
        <li>
          Efficiency (of the Lisp code at runtime)
        </li>
      </ul>
    </SUMMARY>
    <BODY>
      <p>
        Most of these are obvious.
      </p>
      <p>
        Usability by the customer means that the system has to do what the
        customer requires; it has to handle the customer's transaction
        volumes, uptime requirements; etc.
      </p>
      <p>
        For the Lisp efficiency point,
        given two options of equivalent complexity,
        pick the one that performs better.
        (This is often the same as the one that conses less,
        i.e. allocates less storage from the heap.)
      </p>
      <p>
        Given two options where one is more complex than the other,
        pick the simpler option and revisit the decision only if
        profiling shows it to be a performance bottleneck.
      </p>
      <p>
        However, avoid premature optimization.
        Don't add complexity to speed up something that runs rarely,
        since in the long run, it matters less whether such code is fast.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Architecture">
    <SUMMARY>
      To build code that is robust and maintainable,
      it matters a lot how the code is divided into components,
      how these components communicate,
      how changes propagate as they evolve,
      and more importantly
      how the programmers who develop these components communicate
      as these components evolve.
    </SUMMARY>
    <BODY>
      <p>
        If your work affects other groups, might be reusable across groups,
        adds new components, has an impact on other groups
        (including QA or Ops), or otherwise isn't purely local,
        you must write it up using at least a couple of paragraphs,
        and get a design approval from the other parties involved
        before starting to write code — or be ready to scratch what you have
        when they object.
      </p>
      <p>
        If you don't know or don't care about these issues,
        ask someone who does.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Using Libraries">
    <SUMMARY>
      Often, the smallest hammer is to use an existing library.
      Or one that doesn't exist yet.
      In such cases, you are encouraged to use or develop such a library,
      but you must take appropriate precautions.
    </SUMMARY>
    <BODY>
      <ul>
        <li>
          You MUST NOT start a new library
          unless you established that none is already available
          that can be fixed or completed into becoming what you need.
          That's a rule against the NIH syndrome ("Not Invented Here"),
          which is particularly strong amongst Lisp hackers.
        </li>
        <li>
          Whichever library, old or new, you pick, you MUST get permission
          to incorporate third-party code into the code base.
          You must discuss the use of such library
          in the appropriate mailing-list,
          and have your code reviewed by people knowledgeable in the domain
          and/or the Lisp library ecosystem (if any).
          Please be ready to argue why this particular solution makes sense
          as compared to other available libraries.
        </li>
        <li>
          Some libraries are distributed under licenses not compatible
          with the software you're writing, and
          must not be considered available for use.
          Be aware of these issues, or consult with people who are.
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="开源代码">
    <SUMMARY>
      <p>
        如果你编写了一个通用的库，
        或者修改了一个现有的开源库，
        我们鼓励你将结果从你的主项目中分离出来发布，然后
        让你的项目像其他开源库一样导入它。
      </p>
      
    </SUMMARY>
    <BODY>
      <p>
        根据你的判断来区分
        通用代码和业务特定代码，
        并将通用部分开源，
        同时将业务特定部分作为商业机密。
      </p>
      
      <p>
        开源代码有很多优点，
        包括能够利用第三方进行开发，
        让功能的开发由用户主导，
        并让你在代码质量方面保持诚实。
        无论你编写什么代码，你都必须维护它，
        并确保其质量足够高，以支持在生产中使用。
        因此，开源不应该增加额外的负担，
        即使是那些（至少最初）
        不能被第三方直接使用的代码。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="开发流程">
    <SUMMARY>
      开发流程不在本文档的范围内。
      但是，开发人员至少应该记住以下几点：
      代码审查，编写测试，消除警告，运行测试，避免大规模更改。
    </SUMMARY>
    <BODY>
      <p>
      </p>
      <ul>
        <li>
          所有代码更改都必须经过审查。
          你应该预料到你的代码会被其他黑客审查，
          并且你会被分配审查其他黑客的代码。
          审查标准的一部分是代码是否遵守
          本文档中的编码标准。
        </li>
        <li>
          你必须为你编写的新代码和你修复的旧错误编写并提交测试。
          每个API函数都必须有一个单元测试，
          以及任何先前失败的案例。
          只有完成这项活动，你的工作才算真正完成。
          估算任务必须包括生成这些测试所需的时间。
        </li>
        <li>
          你的代码必须编译通过，
          没有任何编译错误或警告消息。
          如果编译器发出应该忽略的警告，
          使用
          <code>UIOP:WITH-MUFFLED-COMPILER-CONDITIONS</code> 和
          <code>UIOP:*UNINTERESTING-COMPILER-CONDITIONS*</code>
          框架（<code>UIOP</code> 的一部分，<code>ASDF 3</code> 的一部分）来消除这些警告，
          可以围绕整个项目，也可以围绕单个文件
          （使用 <code>ASDF</code> 的 <code>:around-compile</code> 钩子）。
        </li>
        <li>
          所有代码都应该提交到适当的源代码控制系统中，
          以允许完全重现
          代码的构建、测试和执行，
          这些代码是、曾经是或可能被部署的。
        </li>
        <li>
          你必须运行 "precheckin" 测试，并且每个组件必须在提交任何代码之前
          成功通过其单元测试。
        </li>
        <li>
          你应该将代码覆盖率纳入你的测试流程中。
          如果测试没有覆盖所有新的和更新的代码，那么测试是不够的；
          由于任何原因无法包含在覆盖率结果中的代码
          应该清楚地标记出来，包括原因。
        </li>
        <li>
          许多人在分支上开发。
          你必须获得许可才能进行大规模更改
          （例如，大规模重新缩进），
          以便我们可以提前协调，
          并让分支上的居民有时间回到主线。
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="格式化">
  <STYLEPOINT title="拼写和缩写">
    <SUMMARY>
      <p>
        你必须在你的注释中使用正确的拼写，
        最重要的是在你的标识符中使用正确的拼写。
      </p>
      <p>
        当存在几种正确的拼写（包括美式英语和英式英语）时，
        并且开发人员之间没有达成一致意见，
        你应该选择较短的拼写。
      </p>
      <p>
        你必须只使用常见的和特定于领域的缩写，并且
        必须与这些缩写保持一致。你可以缩写
        范围有限的词法变量，以避免过长的
        符号名称。
      </p>
    </SUMMARY>
    <BODY>
      <p>
        如果你不确定，请查阅字典，
        在 Google 上搜索替代拼写，
        或咨询当地专家。
      </p>
      <p>
        以下是选择正确拼写的示例：
      </p>
      <ul>
        <li>
          使用 "complimentary" 来表示不由接收者支付的膳食或饮料，而不是 "complementary"。
        </li>
        <li>
          使用 "existent" 和 "nonexistent"，而不是 "existant"。
          使用 "existence"，而不是 "existance"。
        </li>
        <li>
          使用 "hierarchy" 而不是 "heirarchy"。
        </li>
        <li>
          使用 "precede" 而不是 "preceed"。
        </li>
        <li>
          使用 "weird"，而不是 "wierd"。
        </li>
      </ul>
      <p>
        以下是选择较短拼写的示例：
      </p>
      <ul>
        <li>
          使用 "canceled"，而不是 "cancelled"
        </li>
        <li>
          使用 "queuing"，而不是 "queueing"。
        </li>
        <li>
          使用 "signaled"，而不是 "signalled"；
        </li>
        <li>
          使用 "traveled"，而不是 "travelled"。
        </li>
        <li>
          使用 "aluminum"，而不是 "aluminium"
        </li>
        <li>
          使用 "oriented"，而不是 "orientated"
        </li>
        <li>
          使用 "color"，而不是 "colour"
        </li>
        <li>
          使用 "behavior"，而不是 "behaviour"
        </li>
      </ul>
      <p>
        对行业标准术语/行话进行适当的例外处理，
        包括普通的拼写错误。
        例如：
      </p>
      <ul>
        <li>
          在 HTTP 协议的上下文中，使用 "referer"，而不是 "referrer"。
        </li>
      </ul>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="行长度">
    <SUMMARY>
      你应该格式化源代码，使任何行的长度都不超过 100 个字符。
    </SUMMARY>
    <BODY>
      <p>
        某种行长度限制总比没有好。
        虽然旧的文本终端过去使 80 列成为标准，
        但现在，允许 100 列似乎更好，
        因为好的风格鼓励使用
        描述性变量和函数名称。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="缩进">
    <SUMMARY>
      <p>
        按照正确配置的 GNU Emacs 的方式缩进你的代码。
      </p>
      <p>
        在整个项目中保持一致的缩进风格。
      </p>
      <p>
        仔细缩进以使代码更易于理解。
      </p>
    </SUMMARY>
    <BODY>
      <p>
        Emacs 中的 Common Lisp 缩进由 cl-indent 库提供。
        最新版本的 cl-indent 与
        <a HREF="https://www.common-lisp.net/project/slime/">SLIME</a>
        一起打包（在 contrib/slime-cl-indent.el 下）。安装 SLIME 后，设置 Emacs
        使用
        <a HREF="https://www.common-lisp.net/project/slime/doc/html/Loading-Contribs.html">这些说明</a>自动加载 SLIME，将 slime-indentation 添加到
        要在调用 slime-setup 中加载的 contrib 库列表中。
     </p>
     <p>
        理想情况下，使用 slime-indentation 提供的默认缩进设置。
        如有必要，自定义缩进参数以在整个现有项目中保持一致的缩进风格。
        可以使用 define-common-lisp-style 中的 :variables 设置自定义参数。
        可以使用 define-common-lisp-style 的 :indentation 设置自定义特定形式的缩进。
        这在创建行为类似于宏或特殊运算符的形式时特别有用，
        这些形式的缩进方式与标准函数调用不同（例如 defun、labels 或 let）。
        添加一个
        <a HREF="https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html">hook</a> 到 'lisp-mode-hook，该 hook 调用 common-lisp-set-style 以自动设置
        适当的样式。
      </p>
      
      
      <p>
        使用缩进使复杂的函数应用更易于阅读。
        当一个应用不适合在一行上
        或者函数接受许多参数时，
        考虑在参数之间插入换行符，
        以便每个参数都在单独的一行上。
        但是，不要以难以分辨的方式插入换行符
        函数接受多少个参数
        或者参数形式从哪里开始和结束。
      </p>
      <BAD_CODE_SNIPPET>
        ;; Bad
        (do-something first-argument second-argument (lambda (x)
            (frob x)) fourth-argument last-argument)
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; Better
        (do-something first-argument
                      second-argument
                      #'(lambda (x) (frob x))
                      fourth-argument
                      last-argument)
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="文件头">
    <SUMMARY>
      <p>
        你应该在每个源文件的顶部包含一个描述。
      </p>
      <p>
        你不应该在源文件中包含作者身份或版权信息。
      </p>
    </SUMMARY>
    <BODY>
      <p>
        每个源文件都应该以对该文件内容的简要描述开始。
      </p>
      <p>
        在该描述之后，每个文件都应该以一个
        <code>(in-package #:<em>package-name</em>)</code> 形式开始代码本身。
      </p>
      <p>
        在该 <code>in-package</code> 形式之后，
        每个文件都应该跟随任何特定于文件的
        <code>(declaim (optimize ...))</code> 声明，
        该声明未被 <code>ASDF</code> <code>:around-compile</code> 钩子覆盖。
      </p>
      <CODE_SNIPPET>
        ;;;; Variable length encoding for integers and floating point numbers.

        (in-package #:varint)
        (declaim #.*optimize-default*)
      </CODE_SNIPPET>
      <p>
        你不应该在文件的顶部包含作者身份信息：
        可以从版本控制中获得更好的信息，
        并且这样的提及只会引起混乱和痛苦。
        事实上，在包含此类提及时，主要作者
        可能不是最终对文件做出最重要贡献的人，
        甚至更不是目前对文件负责的人。
        
      </p>
      <p>
        你不应该在单个源代码文件中包含版权信息。
        对于旨在作为独立文件传播的文件，则可以例外。
      </p>
      
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="垂直空白">
    <SUMMARY>
      垂直空白：顶级形式之间有一个空行。
    </SUMMARY>
    <BODY>
      <p>
        你应该在顶级形式之间包含一个空行，
        例如函数定义。
        例外情况是，可以在
        同一类型的简单、密切相关的定义形式之间省略空行，
        例如一组相关的类型声明或常量定义。
      </p>
      <CODE_SNIPPET>
        (defconstant +mix32+ #x12b9b0a1 "pi, an arbitrary number")
        (defconstant +mix64+ #x2b992ddfa23249d6 "more digits of pi")

        (defconstant +golden-ratio32+ #x9e3779b9 "the golden ratio")
        (defconstant +golden-ratio64+ #xe08c1d668b756f82 "more digits of the golden ratio")

        (defmacro incf32 (x y)
          "Like INCF, but for integers modulo 2**32"
          `(setf ,x (logand (+ ,x ,y) #xffffffff)))
        (defmacro incf64 (x y)
          "Like INCF, but for integers modulo 2**64"
          `(setf ,x (logand (+ ,x ,y) #xffffffffffffffff)))
      </CODE_SNIPPET>
      <p>
        空行可以用来分隔复杂函数的不同部分。
        然而，通常情况下，你应该将一个大型函数分解成更小的函数，
        而不是试图通过添加垂直空间来使其更具可读性。
        如果不能，你应该用 <code>;;</code> 注释
        来记录函数中每个分隔部分的作用。
      </p>
      <p>
        你应该努力保持顶层形式（包括注释，但不包括文档字符串）的
        适当长度；最好是短的。扩展到超过
        一页的表单应该很少见，并且它们的使用应该有理由。
        这适用于 <code>eval-when</code> 中的每个表单，
        而不是 <code>eval-when</code> 本身。
        此外，<code>defpackage</code> 表单可能会更长，
        因为它们可能包含长长的符号列表。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="水平空白">
    <SUMMARY>
      水平空白：括号周围没有。没有制表符。
    </SUMMARY>
    <BODY>
      <p>
        你不得在括号之前或之后或符号周围包含额外的水平空白。
      </p>
      <p>
        你不得将右括号单独放在一行上。
        一组连续的尾随括号必须出现在同一行上。
      </p>
      <BAD_CODE_SNIPPET>
        ;; Very Bad
        ( defun factorial ( limit )
          ( let (( product 1 ))
            ( loop for i from 1 upto limit
                  do (setf product ( * product i ) ) )
            product
          )
        )
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; Better
        (defun factorial (limit)
          (let ((product 1))
            (loop for i from 1 upto limit
                  do (setf product (* product i)))
            product))
      </CODE_SNIPPET>
      <p>
        你应该只在表单之间使用一个空格。
      </p>
      <p>
        你不应该使用空格来垂直对齐
        连续行中间的表单。
        当代码具有
        重要但以其他方式不可见的对称性
        并且你想强调它时，可以例外。
      </p>
      <BAD_CODE_SNIPPET>
        ;; Bad
        (let* ((low    1)
               (high   2)
               (sum    (+ (* low low) (* high high))))
          ...)
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; Better
        (let* ((low 1)
               (high 2)
               (sum (+ (* low low) (* high high))))
          ...))
      </CODE_SNIPPET>
      <p>
        如果嵌套表单跨越多行，则必须对齐它们。
      </p>
      <BAD_CODE_SNIPPET>
        ;; Bad
        (defun munge (a b c)
        (* (+ a b)
        c))
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; Better
        (defun munge (a b c)
          (* (+ a b)
             c))
      </CODE_SNIPPET>
      <p>
        约定是绑定表单的主体
        在表单后缩进两个空格。
        主体之前的任何绑定数据通常缩进四个空格。
        函数调用的参数与第一个参数对齐；
        如果第一个参数位于其自己的行上，
        则它与函数名称对齐。
      </p>
      <CODE_SNIPPET>
        (multiple-value-bind (a b c d)
            (function-returning-four-values x y)
          (declare (ignore c))
          (something-using a)
          (also-using b d))
      </CODE_SNIPPET>
      <p>
        对于围绕多个定义的 <code>eval-when</code> 表单，
        可以例外于禁止单独括号的规则；
        在这种情况下，在右括号后包含注释 <code>; eval-when</code>。
      </p>
      <p>
        你必须设置你的编辑器以
        避免在你编辑的文件中插入制表符。
        当编辑器在它们代表多少个空格上存在分歧时，制表符会导致混淆。
        在 Emacs 中，执行 <code>(setq-default indent-tabs-mode nil)</code>。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="文档">
  <STYLEPOINT title="记录一切">
    <SUMMARY>
      你应该在所有可见函数上使用文档字符串
      来解释如何使用你的代码。
    </SUMMARY>
    <BODY>
      <p>
        除非某些代码片段非常不言自明，
        否则请使用文档字符串（也称为 docstring）记录它。
      </p>
      <p>
        文档字符串注定要被
        使用你的代码的程序员阅读。
        它们可以从函数、类型、类、变量和宏中提取，
        并由编程工具（如 IDE）或
        REPL 查询（如 <code>(describe 'foo)</code>）显示；
        可以基于它们创建基于 Web 的文档或其他参考作品。
        因此，文档字符串是记录你的 API 的完美场所。
        它们应该描述如何使用代码
        （包括要避免的陷阱），
        而不是代码如何工作（以及在哪里需要更多工作），
        这是你将在注释中放入的内容。
      </p>
      <p>
        在定义
        顶层函数、类型、类、变量和宏时，提供文档字符串。
        通常，在语言允许的任何地方添加文档字符串。
      </p>
      <p>
        对于函数，文档字符串应描述函数的约定：
        函数做什么，
        参数的含义，
        返回什么值，
        函数可以发出什么条件信号。
        它应该以适当的抽象级别表达，
        解释预期的含义，而不是仅仅是语法。
        在文档字符串中，将 Lisp 符号的名称大写，
        例如函数参数。
        例如，“LENGTH 的值应该是一个整数。”
      </p>
      <CODE_SNIPPET>
        (defun small-prime-number-p (n)
          "Return T if N, an integer, is a prime number. Otherwise, return NIL."
          (cond ((or (&lt; n 2))
                 nil)
                ((= n 2)
                 t)
                ((divisorp 2 n)
                 nil)
                (t
                 (loop for i from 3 upto (sqrt n) by 2
                       never (divisorp i n)))))
      </CODE_SNIPPET>
      <CODE_SNIPPET>
        (defgeneric table-clear (table)
          (:documentation
            "Like clrhash, empties the TABLE of all
            associations, and returns the table itself."))
      </CODE_SNIPPET>
      <p>
        一个长的文档字符串可以有效地
        以一个简短的单句摘要开始，
        然后是文档字符串的较大主体。
      </p>
      <p>
        当使用类型名称时，
        可以通过在开头用反引号和结尾用单引号将其引起来。
        Emacs 将突出显示该类型，并且突出显示用作
        提示读者 <kbd>M-.</kbd>
        将导致符号的定义。
      </p>
      <CODE_SNIPPET>
        (defun bag-tag-expected-itinerary (bag-tag)
          "Return a list of `legacy-pnr-pax-segment' objects representing
          the expected itinerary of the `bag-tag' object, BAG-TAG."
          ...)
      </CODE_SNIPPET>
      <p>
        当专门化影响方法的作用时，
        通用函数的每个方法都应该独立记录，
        超出其通用函数的文档字符串中描述的内容。
      </p>
      <p>
        当你修复一个错误时，
        考虑一下修复后的代码所做的事情是否明显正确；
        如果不是，你必须添加注释来解释
        根据修复错误的原因来解释代码的原因。
        如果存在错误编号，也建议添加。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="注释分号">
    <SUMMARY>
      你必须使用适当数量的分号来引入注释。
    </SUMMARY>
    <BODY>
      <p>
        注释是对代码未来维护者的解释。
        即使你是唯一一个会看到和接触代码的人，
        即使你是不朽的并且永远不会退出，
        或者不关心你离开后会发生什么
        （并让你的代码在这种情况下自毁），
        你可能会发现注释你的代码很有用。
        事实上，当你重新审视你的代码时，
        几周、几个月或几年后，
        你会发现自己与编写代码的人不同，
        你会感谢之前的自己
        使代码可读。
      </p>
      <p>
        你必须注释任何复杂的事情，
        以便下一个开发人员可以理解发生了什么。
        （同样，“被卡车撞到”原则。）
      </p>
      <p>
        还可以使用注释作为指导那些阅读代码的人的一种方式，
        以便他们知道在哪里可以找到什么。
      </p>
      <ul>
        <li>
          文件头和重要注释
          适用于源文件中大段代码的注释
          应以四个分号开头。
        </li>
        <li>
          你应该使用三个分号
          来开始仅适用于
          一个顶层表单或一小组顶层表单的注释。
        </li>
        <li>
          在顶层表单中，如果注释出现在行之间，
          你应该使用两个分号来开始注释。
        </li>
        <li>
          如果它是一个附带说明
          并且出现在行尾，则应该使用一个分号。
          你应该使用空格将注释与
          它引用的代码分开，以便注释突出显示。
          你应该尝试垂直对齐
          连续相关的行尾注释。
        </li>
      </ul>
      <CODE_SNIPPET>
        ;;;; project-euler.lisp
        ;;;; File-level comments or comments for large sections of code.

        ;;; Problems are described in more detail here:  https://projecteuler.net/

        ;;; Divisibility
        ;;; Comments that describe a group of definitions.

        (defun divisorp (d n)
          (zerop (mod n d)))

        (defun proper-divisors (n)
          ...)

        (defun divisors (n)
          (cons n (proper-divisors n)))

        ;;; Prime numbers

        (defun small-prime-number-p (n)
          (cond ((or (&lt; n 2))
                 nil)
                ((= n 2)   ; parenthetical remark here
                 t)        ; continuation of the remark
                ((divisorp 2 n)
                 nil)  ; different remark
                ;; Comment that applies to a section of code.
                (t
                 (loop for i from 3 upto (sqrt n) by 2
                       never (divisorp i n)))))
      </CODE_SNIPPET>
      <p>
        你应该在分号和注释文本之间包含一个空格。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="语法和标点符号">
    <SUMMARY>
      你应该正确地标点文档。
    </SUMMARY>
    <BODY>
      <p>
        当注释是一个完整的句子时，
        你应该将第一个单词的首字母大写
        并以句点结束注释。
        一般来说，你应该使用正确的标点符号。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="需要注意">
    <SUMMARY>
      你必须遵循使用 TODO 注释的约定
      对于需要特别注意的代码。
      对于使用不明显的表单的代码，你必须包含注释。
    </SUMMARY>
    <BODY>
      <p>
        对于需要特别注意的注释，例如
        不完整的代码、待办事项、问题、中断和危险，
        包括一个 TODO 注释，指示问题的类型、
        性质以及有关如何解决它的任何说明。
      </p>
      <p>
        注释以全部大写的 <code>TODO</code> 开头，
        后跟
        
        具有关于 <code>TODO</code> 引用的问题
        的最佳上下文的人员的姓名、电子邮件地址或其他标识符。
        主要目的是拥有一个一致的 <code>TODO</code>，
        可以搜索该 <code>TODO</code> 以找出如何根据
        请求获取更多详细信息。
        <code>TODO</code> 并非承诺
        被引用的人员将修复该问题。
        因此，当你创建一个 <code>TODO</code> 时，
        几乎总是给出你的
        姓名。
      </p>
      <p>
        在签署注释时，
        你应该使用你的用户名（对于公司内部的代码）
        或完整的电子邮件地址（对于公司外部可见的代码），
        而不仅仅是首字母。
      
      </p>
      <CODE_SNIPPET>
        ;;--- TODO(george@gmail.com): 重构以提供更好的 API。
      </CODE_SNIPPET>
      <p>
        在 TODO 注释中指示时间和软件版本时要具体，并使用
        <a HREF="https://www.w3.org/TR/NOTE-datetime">YYYY-MM-DD</a>
        日期格式，以便更轻松地自动处理此类日期，
        例如，2038-01-20 表示 32 位有符号 <code>time_t</code> 的结束。
      </p>
      <CODE_SNIPPET>
        ;;--- TODO(brown): 在发布 1.7 版本后或 2012-11-30 之前删除此代码。
      </CODE_SNIPPET>
      <p>
        对于使用不明显的格式来完成任务的代码，您必须包含一条注释，
        说明该格式的目的以及它完成的任务。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="领域特定语言">
    <SUMMARY>
      您应该记录 DSL 以及
      DSL 中的任何简洁程序。
    </SUMMARY>
    <BODY>
      <p>
        您应该设计您的领域特定语言，
        以便熟悉该领域的人员易于阅读和理解。
      </p>
      <p>
        您必须正确记录您的所有领域特定语言。
      </p>
      <p>
        有时，您的 DSL 被设计为简洁。
        在这种情况下，如果从上下文中不明显，
        那么记录每个程序的作用非常重要。
      </p>
      <p>
        值得注意的是，当您使用正则表达式
        （例如，使用 <code>CL-PPCRE</code> 包）时，
        您必须始终添加注释
        （通常是前一行的双分号注释），
        至少从根本上解释正则表达式的作用，
        或使用它的目的。
        注释不需要拼出语法的每一位，但是
        应该让某人能够理解代码的逻辑，
        而无需实际解析正则表达式。
      </p>
    </BODY>
  </STYLEPOINT>

</CATEGORY>

<CATEGORY title="命名">
  <STYLEPOINT title="符号指南">
    <SUMMARY>
      您应该使用小写字母。
      您应该遵循 <a href="#Spelling_and_Abbreviations">拼写和缩写</a> 的规则
      您应该遵循标点符号约定。
    </SUMMARY>
    <BODY>
      <p>
        对所有符号使用小写字母。
        始终如一地使用小写字母可以更轻松地搜索符号名称，
        并且更具可读性。
      </p>
      <p>
        请注意，Common Lisp 是区分大小写的，
        并且您的符号的 <code>symbol-name</code>
        将为大写。
        由于这种大小写转换，
        通过大小写区分符号的尝试会失败，
        并且只会导致混乱。
        虽然可以转义符号中的字符
        以强制使用小写字母，
        但您不应使用此功能，
        除非以某种方式需要这样做
        才能与第三方软件互操作。
      </p>
      <p>
        在符号中的所有单词之间放置连字符。
        如果您不能轻松地大声说出一个标识符，
        那么它的命名可能很糟糕。
      </p>
      <p>
        您不得使用 <code>"/"</code> 或 <code>"."</code>
        代替 <code>"-"</code>，
        除非您有充分记录的总体原因，
        并且获得了审查您的提案的其他黑客的许可。
      </p>
      <p>
        有关使用缩写的指南，请参见 <a href="#Spelling_and_Abbreviations">拼写和缩写</a> 部分。
      </p>
      <BAD_CODE_SNIPPET>
        ;; 糟糕
        (defvar *default-username* "Ann")
        (defvar *max-widget-cnt* 200)
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; 更好
        (defvar *default-user-name* "Ann")
        (defvar *maximum-widget-count* 200)
      </CODE_SNIPPET>
      <p>
        Common Lisp 中存在
        在符号中使用标点符号的约定。
        您不应在这些约定之外的符号中使用标点符号。
      </p>
      <p>
        除非变量的作用域非常小，
        否则不要使用过于简短的名称，例如
        <code>i</code> 和 <code>zq</code>。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="表示意图，而不是内容">
    <SUMMARY>
      根据变量的意图而不是内容来命名变量。
    </SUMMARY>
    <BODY>
      <p>
        您应该根据变量所代表的
        高级概念来命名变量，
        而不是根据概念的低级实现细节
        来命名变量。
      </p>
      <p>
        因此，您应该避免嵌入
        数据结构或聚合类型名称，
        例如 <code>list</code>、<code>array</code> 或
        <code>hash-table</code> 在变量名称中，
        除非您正在编写适用于
        任意列表、数组、哈希表等的通用算法。
        在这种情况下，将变量命名为
        <code>list</code> 或 <code>array</code> 是完全可以的。
      </p>
      <p>
        实际上，每当对象的协议中出现一种新的意图时，
        您都应该使用 <code>DEFCLASS</code> 或 <code>DEFTYPE</code>
        引入新的抽象数据类型。
        然后，以通用方式操作此类对象的函数可以使用
        变量的名称来反映该抽象类型。
      </p>
      <p>
        例如，如果变量的值始终是一行
        （或者是一行或 <code>NIL</code>），
        那么最好将其称为 <code>row</code> 或 <code>first-row</code>
        或类似的东西。
        如果 <code>row</code> 已被
        <code>DEFTYPE</code>'d 为 <code>STRING</code>，那也没关系——
        正是因为您已经抽象掉了细节，
        而剩下的突出点是它是一行。
        在这种情况下，您不应将变量命名为 <code>STRING</code>，
        除非可能在专门操作
        行的内部结构以提供合适的抽象的低级函数中。
      </p>
      <p>
        保持一致。
        如果一个变量在一个函数中被命名为 <code>row</code>，
        并且它的值被传递给第二个函数，
        那么将其称为 <code>row</code>，而不是 <code>value</code>
        （这是一个真实的案例）。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="全局变量和常量">
    <SUMMARY>
      根据约定命名全局变量。
    </SUMMARY>
    <BODY>
      <p>
        全局常量的名称应以加号字符开头和结尾。
      </p>
      <p>
        全局变量名称应以星号开头和结尾
        （在这种上下文中也称为耳罩）。
      </p>
      <p>
        在某些项目中，通常不打算
        在正常情况下修改或绑定的参数
        （但在实验或特殊情况下可能会修改或绑定）
        应以美元符号开头（但不以美元符号结尾）。
        如果您的项目中存在此类约定，
        则应始终如一地遵循它。
        否则，您应该避免像这样命名变量。
      </p>
      <p>
        Common Lisp 没有全局词法变量，
        因此使用命名约定来确保全局变量
        （它们是动态绑定的）
        永远不会与局部变量重叠。
        可以使用不同命名的全局变量
        和 <code>DEFINE-SYMBOL-MACRO</code>
        来伪造全局词法变量。
        您不应使用此技巧，
        除非您首先发布一个抽象它的库。
      </p>
      <CODE_SNIPPET>
        (defconstant +hash-results+ #xbd49d10d10cbee50)

        (defvar *maximum-search-depth* 100)
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="谓词名称">
    <SUMMARY>
      谓词函数和变量的名称以 <code>"P"</code> 结尾。
    </SUMMARY>
    <BODY>
      <p>
        您应该使用尾随 <code>"P"</code> 或 <code>"-P"</code>
        来命名布尔值函数和变量，
        以指示它们是谓词。
        通常，当函数名称的其余部分是一个单词时，
        您应该使用 <code>"P"</code>，
        当函数名称的其余部分是多个单词时，
        您应该使用 <code>"-P"</code>。
      </p>
      <p>
        <a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node69.html">CLtL2 中关于谓词的章节</a>
        给出了此约定的理由。
      </p>
      <p>
        为了统一性，您应该遵循上述约定，
        而不是以下替代方案之一。
      </p>
      <p>
        某些现有软件包中使用的一种替代规则
        是始终使用 <code>"-P"</code>。
        某些现有软件包中使用的另一种替代规则
        是始终使用 <code>"?"</code>。
        当您开发这样的软件包时，
        您必须与软件包的其余部分保持一致。
        当您启动一个新软件包时，
        如果没有充分记录的理由，
        则不应使用这样的替代规则。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="省略库前缀">
    <SUMMARY>
      您不应在符号名称中包含库或包名称
      作为前缀。
    </SUMMARY>
    <BODY>
      <p>
        在包中命名符号（外部或内部）时，
        您不应在符号名称中包含包名称
        作为前缀。
        以这种方式命名符号会使其难以使用
        从客户端包访问符号
        通过使用包前缀限定它，
        其中包名称会出现两次
        （一次作为包前缀，
        另一次作为符号名称中的前缀）。
      </p>
      <BAD_CODE_SNIPPET>
        ;; 糟糕
        (in-package #:varint)
        (defun varint-length64 () ... )

        (in-package #:client-code)
        (defconst +padding+ (varint:varint-length64 +end-token+))
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; 更好
        (in-package #:varint)
        (defun length64 () ... )
        (in-package #:client-code)
        (defconst +padding+ (varint:length64 +end-token+))
      </CODE_SNIPPET>
      <p>
        An exception to the above rule would be to include a prefix
        for the names of variables that would otherwise be expected to clash
        with variables in packages that use the current one.
        For instance, <code>ASDF</code> exports a variable <code>*ASDF-VERBOSE*</code>
        that controls the verbosity of <code>ASDF</code> only,
        rather than of the entire Lisp program.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Packages">
    <SUMMARY>
      Use packages appropriately.
    </SUMMARY>
    <BODY>
      <p>
        Lisp packages are used to demarcate namespaces.
        Usually, each system has its own namespace.
        A package has a set of external symbols,
        which are intended to be used from outside the package,
        in order to allow other modules to use this module's facilities.
      </p>
      <p>
        The internal symbols of a package
        should never be referred to from other packages.
        That is, you should never have to use
        the double-colon <code>::</code> construct.
        (e.g. <code>QUAKE::HIDDEN-FUNCTION</code>).
        If you need to use double-colons to write real production code,
        something is wrong and needs to be fixed.
      </p>
      <p>
        As an exception,
        unit tests may use the internals of the package being tested.
        So when you refactor, watch out for
        internals used by the package's unit tests.
      </p>
      <p>
        The <code>::</code> construct is also useful for very temporary hacks,
        and at the REPL.
        But if the symbol really is part of
        the externally-visible definition of the package,
        export it.
      </p>
      <p>
        You may find that some internal symbols represent concepts
        you usually want to abstract away and hide under the hood,
        yet at times are necessary to expose for various extensions.
        For the former reason, you do not want to export them,
        yet for the latter reason, you have to export them.
        The solution is to have two different packages,
        one for your normal users to use, and
        another for the implementation and its extenders to use.
      </p>
      <p>
        Each package is one of two types:
      </p>
      <ul>
        <li>
          Intended to be included
          in the <code>:use</code> specification of other packages.
          If package <code>A</code> "uses" package <code>B</code>,
          then the external symbols of package <code>B</code>
          can be referenced from within package <code>A</code>
          without a package prefix.
          We mainly use this for low-level modules
          that provide widely-used facilities.
        </li>
        <li>
          Not intended to be "used".
          To reference a facility provided by package <code>B</code>,
          code in package <code>A</code> must use an explicit package prefix,
          e.g. <code>B:DO-THIS</code>.
        </li>
      </ul>
      <p>
        If you add a new package, it should always be of the second type,
        unless you have a special reason and get permission.
        Usually a package is designed to be one or the other,
        by virtue of the names of the functions.
        For example, if you have an abstraction called <code>FIFO</code>,
        and it were in a package of the first type
        you'd have functions named things like
        <code>FIFO-ADD-TO</code> and <code>FIFO-CLEAR-ALL</code>.
        If you used a package of the second type,
        you'd have names like <code>ADD-TO</code> and <code>CLEAR-ALL</code>,
        because the callers would be saying
        <code>FIFO:ADD-TO</code> and <code>FIFO:CLEAR-ALL</code>.
        (<code>FIFO:FIFO-CLEAR-ALL</code> is redundant and ugly.)
      </p>
      <p>
        Another good thing about packages is that
        your symbol names won't "collide" with the names of other packages,
        except the ones your packages "uses".
        So you have to stay away from symbols
        that are part of the Lisp implementation (since you always "use" that)
        and that are part of any other packages you "use",
        but otherwise you are free to make up your own names,
        even short ones, and not worry about some else
        having used the same name.
        You're isolated from each other.
      </p>
      <p>
        Your package must not shadow (and thus effectively redefine)
        symbols that are part of the Common Lisp language.
        There are certain exceptions,
        but they should be very well-justified and extremely rare:
      </p>
      <ul>
        <li>
          If you are explicitly replacing a Common Lisp symbol
          by a safer or more featureful version.
        </li>
        <li>
          If you are defining a package not meant to be "used",
          and have a good reason to export a symbol
          that clashes with Common Lisp,
          such as <code>log:error</code> and <code>log:warn</code>
          and so on.
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Language usage guidelines">
  <STYLEPOINT title="Mostly Functional Style">
    <SUMMARY>
      You should avoid side-effects when they are not necessary.
    </SUMMARY>
    <BODY>
      <p>
        Lisp is best used as a "mostly functional" language.
      </p>
      <p>
        Avoid modifying local variables, try rebinding instead.
      </p>
      <p>
        Avoid creating objects and the SETFing their slots.
        It's better to set the slots during initialization.
      </p>
      <p>
        Make classes as immutable as possible, that is, avoid giving slots
        setter functions if at all possible.
      </p>
      <p>
        Using a mostly functional style makes it much easier
        to write concurrent code that is thread-safe.
        It also makes it easier to test the code.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Recursion">
    <SUMMARY>
      You should favor iteration over recursion.
    </SUMMARY>
    <BODY>
      <p>
        Common Lisp systems are not required to implement
        function calls from tail positions without leaking stack space
        — which is known as proper tail calls (PTC),
        tail call elimination (TCE),
        or tail call optimization (TCO).
        This means that indefinite recursion through tail calls
        may quickly blow out the stack,
        which hampers functional programming.
        Still, most serious implementations (including SBCL and CCL)
        do implement proper tail calls, but with restrictions:
      </p>
      <ul>
        <li>
          The <code>(DECLARE (OPTIMIZE ...))</code> settings
          must favor <code>SPEED</code> enough and
          not favor <code>DEBUG</code> too much,
          for some compiler-dependent meanings of "enough" and "too much".
          (For instance, in SBCL, you should avoid <code>(SPEED 0)</code>
          and <code>(DEBUG 3)</code> to achieve proper tail calls.)
        </li>
        <li>
          There should not be dynamic bindings around the call
          (even though some Scheme compilers are able to properly treat
          such dynamic bindings, called parameters in Scheme parlance).
        </li>
      </ul>
      <p>
        For compatibility with all compilers and optimization settings,
        and to avoid stack overflow when debugging,
        you should prefer iteration or the built in mapping functions
        to relying on proper tail calls.
      </p>
      <p>
        If you do rely on proper tail calls,
        you must prominently document the fact,
        and take appropriate measures to ensure an appropriate compiler is used
        with appropriate optimization settings.
        For fully portable code, you may have to use trampolines instead.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Special variables">
    <SUMMARY>
      Use special variables sparingly.
    </SUMMARY>
    <BODY>
      <p>
        Using Lisp "special" (dynamically bound) variables
        as implicit arguments to functions should be used sparingly,
        and only in cases where it won't surprise the person reading the code,
        and where it offers significant benefits.
      </p>
      <p>
        Indeed, each special variable constitutes state.
        Developers have to mentally track the state of all relevant variables
        when trying to understand what the code does and how it does it;
        tests have to be written and run with all relevant combinations;
        to isolate some activity, care has to be taken to locally bind
        all relevant variables, including those of indirectly used modules.
        They can hide precious information from being printed in a backtrace.
        Not only is there overhead associated to each new variable,
        but interactions between variables
        can make the code exponentially more complex
        as the number of such variables increases.
        The benefits have to match the costs.
      </p>
      <p>
        Note though that a Lisp special variable is not a global variable
        in the sense of a global variable in, say, BASIC or C.
        As special variables can be dynamically bound to a local value,
        they are much more powerful than
        global value cells where all users necessarily interfere with each other.
      </p>
      <p>
        Good candidates for such special variables
        are items for which "the current" can be naturally used as prefix,
        such as "the current database connection" or
        "the current business data source".
        They are singletons as far as the rest of the code is concerned,
        and often passing them as an explicit argument
        does not add anything to the readability or maintainability
        of the source code in question.
      </p>
      <p>
        They can make it easier to write code that can be refactored.
        If you have a request processing chain,
        with a number of layers that all operate upon a "current" request,
        passing the request object explicitly to every function
        requires that every function in the chain have a request argument.
        Factoring out code into new functions often requires
        that these functions also have this argument,
        which clutters the code with boilerplate.
      </p>
      <p>
        You should treat special variables
        as though they are per-thread variables.
        By default, you should leave a special variable
        with no top-level binding at all,
        and each thread of control
        that needs the variable should bind it explicitly.
        This will mean that any incorrect use of the variable
        will result in an "unbound variable" error, and
        each thread will see its own value for the variable.
        Variables with a default global value should usually be
        locally bound at thread creation time.
        You should use suitable infrastructure
        to automate the appropriate declaration of such variables.
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="赋值">
    <SUMMARY>
      在赋值形式上保持一致。
    </SUMMARY>
    <BODY>
      <p>
        处理赋值和副作用有几种风格；
        无论给定的包使用哪种风格，
        在修改该包时，始终保持一致。
        在启动新包时，选择一种有意义的风格。
      </p>
      <p>
        关于同一形式中的多重赋值，有两种流派：
        第一种风格是将尽可能多的赋值组合成一个
        <code>SETF</code> 或 <code>PSETF</code> 形式，
        从而最大限度地减少具有副作用的形式的数量；
        第二种风格是将赋值拆分为尽可能多的单独
        <code>SETF</code>（或 <code>SETQ</code>，见下文）形式，
        以最大限度地提高通过 grep 查找 <code>(setf (foo ...</code> 来定位修改某种位置的形式的机会。
        grep 模式实际上必须包含与您在程序中可能使用的位置修改形式一样多的形式，这可能会使这种基本原理令人信服或毫无意义，具体取决于代码的其余风格。
        您应该遵循您正在修改的包中使用的约定。
        我们建议新包采用第一种约定。
      </p>
      <p>
        关于 <code>SETF</code> 和 <code>SETQ</code>，
        有两种流派：
        第一种将 <code>SETQ</code>
        视为一种过时的实现细节，
        并完全避免使用它，而倾向于使用 <code>SETF</code>；
        第二种将 <code>SETF</code>
        视为一个额外的复杂层，
        并尽可能避免使用它，而倾向于使用 <code>SETQ</code>
        （即，只要分配的位置是变量或符号宏）。
        您应该遵循您正在修改的包中使用的约定。
        我们建议新包采用第一种约定。
      </p>
      <p>
        本着主要纯函数式风格的精神，
        这使得测试和维护更容易，
        我们邀请您考虑如何以最少的赋值来完成事情。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="断言和条件">
    <SUMMARY>
      您必须正确使用断言和条件。
    </SUMMARY>
    <BODY>
      <ul>
        <li>
          <code>ASSERT</code> 应该仅用于检测内部错误。
          代码应该 <code>ASSERT</code> 不变量，其失败表明
          软件本身已损坏。
          不正确的输入应在运行时正确处理，
          并且不得导致断言冲突。
          <code>ASSERT</code> 失败的受众是开发人员。
          不要在 <code>ASSERT</code> 中使用 data-form 和 argument-form
          来指定要发出的条件。
          可以使用它们来打印出用于调试的消息
          （并且由于它仅用于调试，因此不存在
          国际化的问题）。
        </li>
        <li>
          <code>CHECK-TYPE</code>,
          <code>ETYPECASE</code> 也是断言的形式。
          当其中一个失败时，这是一个检测到的错误。
          您应该更喜欢使用 <code>CHECK-TYPE</code>
          而不是 (DECLARE (TYPE ...))
          作为函数的输入。
        </li>
        <li>
          您的代码应该自由地使用断言和类型检查。
          越早发现错误越好！
          只有性能关键路径中的代码
          和内部助手才应避免
          显式断言和类型检查。
        </li>
        <li>
          无效的输入，例如读取的文件
          但不符合预期格式，
          不应被视为断言冲突。
          始终检查以确保输入有效，
          如果无效，则采取适当的措施，
          例如发出实际错误。
        </li>
        <li>
          <code>ERROR</code> 应该用于
          检测用户数据、请求、权限等问题，
          或向调用者报告“异常结果”。
        </li>
        <li>
          <code>ERROR</code> 应该始终被调用
          使用显式条件类型；
          它不应该简单地使用字符串调用。
          这实现了国际化。
        </li>
        <li>
          通过发出条件来报告异常结果的函数
          应在其合同中明确说明
          （其文本描述，在文档和文档字符串等中）。
          当函数发出一个条件
          其合同未指定时，这是一个错误。
          合同应清楚地指定条件类。
          然后，该函数可以发出任何条件
          它是任何这些条件的类型。
          也就是说，发出已记录的条件类的子类的实例是可以的。
        </li>
        <li>
          复杂的错误检查可能需要使用 <code>ERROR</code>
          而不是 <code>ASSERT</code>。
          
        </li>
        <li>
          在编写服务器时，您不得调用 <code>WARN</code>。
          相反，您应该使用适当的日志记录框架。
          
        </li>
        <li>
          代码不得调用 <code>SIGNAL</code>。
          相反，使用 <code>ERROR</code> 或 <code>ASSERT</code>。
        </li>
        <li>
          代码不应使用 <code>THROW</code> 和 <code>CATCH</code>；
          而是使用 <code>restart</code> 工具。
        </li>
        <li>
          代码不应泛型地处理所有条件，
          例如类型 <code>T</code>，或使用 <code>IGNORE-ERRORS</code>。
          相反，让未知条件传播到
          用于处理的标准最终处理程序。
          
        </li>
        <li>
          在少数地方，处理所有条件是合适的，
          但它们很少见。
          问题在于处理所有条件可能会掩盖程序错误。
          如果您<em>确实</em>需要处理“所有条件”，
          您必须仅处理 <code>ERROR</code>，<em>而不是</em> <code>T</code>
          而不是 <code>SERIOUS-CONDITION</code>。
          （这尤其因为 CCL 的进程关闭
          取决于能够发出 <code>process-reset</code>
          并让 CCL 的处理程序处理它，
          因此我们不得插入我们自己的处理程序。）
        </li>
        <li>
          <code>(error (make-condition 'foo-error ...))</code>
          等效于 <code>(error 'foo-error ...)</code> —
          代码必须使用较短的形式。
        </li>
        <li>
          代码不应从
          <code>UNWIND-PROTECT</code> 的清理形式内部发出条件
          （除非它们始终在清理形式内部处理），
          否则不要从清理处理程序中进行非本地退出
          在处理程序之外，例如 <code>INVOKE-RESTART</code>。
        </li>
        <li>
          不要通过重新发出信号来清理。
          如果您这样做，并且该条件未处理，
          堆栈跟踪将在重新发出信号的点停止，
          隐藏其余部分。
          其余部分是我们真正关心的部分！
          <BAD_CODE_SNIPPET>
            ;; Bad
            (handler-case
              (catch 'ticket-at
                (etd-process-blocks))
              (error (c)
                (reset-parser-values)
                  (error c)))
          </BAD_CODE_SNIPPET>
          <CODE_SNIPPET>
            ;; Better
            (unwind-protect
              (catch 'ticket-at
                (etd-process-blocks))
              (reset-parser-values))
          </CODE_SNIPPET>
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="类型检查">
    <SUMMARY>
      如果您知道某物的类型，则应明确说明
      以便启用编译时和运行时健全性检查。
    </SUMMARY>
    <BODY>
      
      <p>
        如果您的函数使用特殊变量作为隐式参数，
        最好为特殊变量添加 <code>CHECK-TYPE</code>，
        原因有两个：
        为了让阅读代码的人知道
        此变量被隐式用作参数，
        并且还有助于检测错误。
      </p>
      
      <p>
        使用 <code>(declare (type ...))</code>
        是最不理想的机制
        因为，正如 Scott McKay 所说：
      </p>
      <blockquote>
        <p>
          事实是，<code>(declare (type ...))</code> 做的事情不同
          取决于速度、安全性等的编译器设置。
          在某些编译器中，当速度大于安全性时，
          <code>(declare (type ...))</code> 会告诉编译器
          “请假设这些变量具有这些类型”
          <em>而不</em>生成任何类型检查。
          也就是说，如果某个变量的值为 <code>1432</code>，
          并且您将其声明为 <code>string</code> 类型，
          编译器可能会直接使用它，就好像它是一个字符串一样。
        </p>
        <p>
          道德：不要使用 <code>(declare (type ...))</code>
          来声明任何 API 函数的合同，
          这不是正确的事情。
          当然，将其用于“helper”函数，但不要用于 API 函数。
        </p>
      </blockquote>
      <p>
        当然，您应该在内部底层函数中使用适当的声明
        其中这些声明用于优化。
        但是，当您这样做时，请参阅我们对
        <a href="#Unsafe_Operations">不安全操作</a>的建议。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="CLOS">
    <SUMMARY>
      适当地使用 CLOS。
    </SUMMARY>
    <BODY>
      <p>
        当通用函数旨在从其他
        模块（代码的其他部分）调用时，应该有一个
        显式的 <code>DEFGENERIC</code> 形式，
        带有 <code>:DOCUMENTATION</code> 字符串
        解释函数的通用合同
        （而不是它对某些特定类的行为）。
        通常最好进行显式的 <code>DEFGENERIC</code> 形式，
        但对于模块入口点，这是强制性的。
      </p>
      <p>
        当通用函数的参数列表包含
        <code>&amp;KEY</code> 时，
        <code>DEFGENERIC</code> 应该始终显式列出
        所有可接受的关键字参数，
        并解释它们的含义。
        （Common Lisp 不需要这样做，但这是一个好的形式，
        并且它可以避免 SBCL 上出现虚假警告。）
      </p>
      <p>
        您应该避免 <code>SLOT-VALUE</code> 和 <code>WITH-SLOTS</code>，
        除非您绝对打算规避
        可能对该槽有效的任何类型的组合方法。
        罕见的例外包括 <code>INITIALIZE-INSTANCE</code>
        和 <code>PRINT-OBJECT</code> 方法以及
        访问方法的底层实现中通常隐藏的槽
        提供用户可见的抽象。
        否则，您应该使用访问器，
        <code>WITH-ACCESSORS</code>
      </p>
      
      <p>
        访问器名称通常遵循
        <code>&lt;协议名称&gt;-&lt;槽名称&gt;</code> 的约定，
        其中“协议”在这种情况下宽泛地表示
        一组具有明确定义的行为的函数。
      </p>
      <p>
        并不一定意味着正式的“协议”概念，
        更不用说一流的“协议”对象了。
        但是，实际上可能存在一个抽象的 CLOS 类
        或者一个
        <a href="https://common-lisp.net/~frideau/lil-ilc2012/lil-ilc2012.html">接口传递风格</a> 接口
        来体现该协议。
        进一步的（子）类或（子）接口然后可以通过为协议中的（通用）函数定义
        一些方法来实现协议的全部或部分，
        包括读取器和写入器。
      </p>
      <p>
        例如，如果有一个假想的协议叫做
        <code>pnr</code>，其访问器为 <code>pnr-segments</code>
        和 <code>pnr-passengers</code>，那么
        类 <code>air-pnr</code>、<code>hotel-pnr</code> 和
        <code>car-pnr</code> 都可以合理地实现
        <code>pnr-segments</code> 和 <code>pnr-passengers</code>
        作为访问器的方法。
      </p>
      <p>
        默认情况下，抽象基类名称用作
        假想的协议名称，因此访问器名称默认为
        <code>&lt;类名&gt;-&lt;槽名&gt;</code>；
        虽然这样的名称非常普遍，
        但这种形式既不是必需的，也不是首选的。
        一般来说，它会导致“符号膨胀”，
        并且在许多情况下导致了“跳板”方法的激增。
      </p>
      <p>
        不应使用名为 <code>&lt;槽名&gt;-of</code> 的访问器。
      </p>
      <p>
        当存在
        （或者预计将会有）
        多个 <code>DEFMETHOD</code> 用于该通用函数时，
        应使用显式的 <code>DEFGENERIC</code> 形式。
        原因是通用函数的文档
        解释了该函数的抽象契约，
        而不是解释单个方法对
        某些特定类所做的事情。
      </p>
      <p>
        在没有假想协议的情况下，您不得使用通用函数。
        更具体地说，
        如果您有多个通用函数专门化其第 N 个参数，
        则专门化的类都应该是单个类的后代。
        通用函数不得用于“重载”，
        即简单地为两个完全不相关的类型使用相同的名称。
      </p>
      <p>
        更准确地说，
        真正重要的不是
        它们是否从一个共同的超类继承，
        而是它们是否遵守相同的“协议”。
        也就是说，这两个类应该处理同一组通用函数，
        就好像每个方法都有一个显式的 <code>DEFGENERIC</code>。
      </p>
      <p>
        这是另一种说法。
        假设您有两个类 A 和 B，以及一个通用函数 F。
        F 有两个方法，
        它们根据参数的类型是 A 和 B 进行分派。
        在程序中是否有可能存在某个函数调用
        调用 F，
        其中参数有时在运行时
        是 A 类，而另一些时候是 B 类？
        如果不是，您可能正在重载，并且
        不应该使用单个通用函数。
      </p>
      <p>
        我们允许此规则的一个例外：
        如果相应的参数“意味着”相同的事情，
        则可以进行重载。
        通常，一个重载允许一个 X 对象，
        另一个允许 X 对象的名称，
        这可能是一个符号或其他东西。
      </p>
      <p>
        您不得在运行时使用 MOP “代求”操作。
        您不应在编译时使用 MOP “代求”操作。
        在运行时，它们充其量是一种危险，充其量是一个性能问题。
        在编译时，通常更简洁的做法是
        宏应该一次性正确设置，
        而不是需要通过代求进行第二次修复；
        但有时，修复是必要的，以解决前向引用，
        并且在这种情况下允许代求。
        MOP 代求是交互式开发的一个很好的工具，
        您可以在开发和调试时享受它；
        但您不应在普通应用程序中使用它。
      </p>
      <p>
        如果一个类定义创建了一个方法
        作为 <code>:READER</code>、<code>:WRITER</code>
        或 <code>:ACCESSOR</code>，
        请不要重新定义该方法。
        可以添加 <code>:BEFORE</code>、<code>:AFTER</code>
        和 <code>:AROUND</code> 方法，
        但不要覆盖主要方法。
      </p>
      <p>
        在带有关键字参数的方法中，
        您必须始终使用 <code>&amp;KEY</code>，
        即使该方法不关心任何键的值，
        并且您永远不应使用 <code>&amp;ALLOW-OTHER-KEYS</code>。
        只要通用函数的任何方法接受一个关键字，
        就可以在通用函数中使用它，
        即使同一通用函数的其他方法
        没有明确提及它。
        这对于
        <code>INITIALIZE-INSTANCE</code> 方法尤其重要，
        因为如果您确实使用了 <code>&amp;ALLOW-OTHER-KEYS</code>，
        它将禁用对 <code>MAKE-INSTANCE</code> 调用中拼写错误或错误的关键字的错误检查！
      </p>
      
      <p>
        一个典型的 <code>PRINT-OBJECT</code> 方法可能如下所示：
      </p>
      <CODE_SNIPPET>
        (defmethod print-object ((p person) stream)
          (print-unreadable-object (p stream :type t :identity t)
            (with-slots (first-name last-name) p
              (safe-format stream "~a ~a" first-name last-name))))
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Meta-language guidelines">
  <STYLEPOINT title="Macros">
    <SUMMARY>
      在适当的时候使用宏，这通常是这样。
      在适当的时候定义宏，这很少发生。
    </SUMMARY>
    <BODY>
      <p>
        宏带来了语法抽象，这是一件很棒的事情。
        它通过描述您的意图来帮助您使代码更清晰，
        而不会陷入实现细节
        （实际上是将这些细节抽象掉）。
        它通过消除冗余和不相关的细节来帮助您使代码更简洁和更具可读性。
        但这会给读者带来成本，
        即为每个宏学习一个新的语法概念。
        因此，不应滥用它。
      </p>
      <p>
        一般的结论是，不应该有
        任何可识别的<em>设计模式</em>
        在一个好的 Common Lisp 程序中。
        唯一的一个模式是：<em>使用该语言</em>，
        其中包括定义和使用语法抽象。
      </p>
      <p>
        每当现有宏通过以更简洁的方式传达意图来使代码更清晰时，
        就必须使用它们，
        这通常是这样。
        当您的项目中有一个宏
        表达了您正在使用的概念时，
        您不得编写扩展而不是使用宏。
      </p>
      <p>
        应在适当的时候定义新宏，
        这应该很少发生，
        因为该语言及其各种库
        已经提供了常见的宏，
        并且您的程序通常只需要相对于其大小的
        少量新宏。
      </p>
      <p>
        您应该遵循 OAOOM 经验法则
        来决定何时创建新的抽象，
        无论是语法的还是非语法的：
        如果一个特定的模式被使用了两次以上，
        它可能应该被抽象掉。
        一个更精细的规则来决定何时使用抽象
        应该考虑到
        使用次数和每次使用的收益方面的收益，
        以及在必须习惯于阅读代码方面的成本。
        对于语法抽象，对读者的成本和收益
        通常比对编写者的成本和收益更重要，
        因为好的代码通常编写一次
        并被许多人阅读多次
        （包括必须在忘记程序后维护程序的
        同一程序员）。
        然而，编写宏的编写者的成本
        也应该被考虑在内；
        但是，在这样做时，它应该与
        程序员编写可能具有更高收益的
        其他代码的成本进行比较。
      </p>
      <p>
        正确使用 Lisp 宏需要品味。
        避免编写复杂的宏，
        除非收益明显大于成本。
        您的其他开发人员需要付出更多的努力来学习您的宏，
        因此您应该仅在表达方面的收益
        足够大以证明该成本合理时才使用宏。
        与往常一样，如果您不确定，请随时咨询您的同事，
        因为如果没有大量的 Lisp 经验，
        很难做出此判断。
      </p>
      <p>
        您绝不能在可以使用函数的地方使用宏。
        也就是说，如果您正在编写的内容的语义
        符合函数的语义，
        那么您必须将其编写为函数而不是宏。
      </p>
      <p>
        您不得出于性能原因将函数转换为宏。
        如果分析表明您在
        特定的 <code>FOO</code> 函数中存在性能问题，
        请适当地记录需求和分析结果，
        并
        <code>(declaim (inline foo))</code>。
      </p>
      
      <p>
        您还可以使用编译器宏
        作为通过指定源到源转换来加速函数执行的一种方式。
        请注意，它会干扰跟踪优化的函数。
      </p>
      <p>
        当您编写一个宏定义宏
        （一个生成宏的宏）时，
        请特别清楚地记录和注释它，
        因为这些更难理解。
      </p>
      <p>
        未经您的系统开发人员达成共识，
        您不得安装新的读取器宏。
        读取器宏不得从使用它们的系统泄漏到
        该系统的客户端或在同一项目中使用的其他系统。
        您必须使用诸如
        <code>cl-syntax</code> 或 <code>named-readtables</code>
        之类的软件来控制读取器宏的使用方式。
        希望使用它的客户端可以使用与您相同的读取器宏。
        在任何情况下，即使对于不使用这些读取器宏的客户端，
        您的系统也必须可用。
      </p>
      <p>
        如果您的宏有一个参数是一个 Lisp 形式，
        该形式将在扩展代码运行时进行评估，
        则应使用后缀 <code>-form</code> 命名该参数。
        此约定有助于使宏的用户更清楚地了解
        哪些参数是要评估的 Lisp 形式，哪些不是。
        常见的名称 <code>body</code> 和 <code>end</code> 是
        此规则的例外。
      </p>
      <p>
        您应该在适用时遵循所谓的 <code>CALL-WITH</code> 风格。
        这种风格在
        <a href="http://random-state.net/log/3390120648.html">http://random-state.net/log/3390120648.html</a> 中有详细解释。
        总的原则是，宏严格限于处理语法，
        并且尽可能多的语义保留在普通函数中。
        因此，宏 <code>WITH-<em>FOO</em></code> 通常仅限于
        使用从宏参数推导出的参数
        生成对辅助函数
        <code>CALL-WITH-<em>FOO</em></code> 的调用。
        宏 <code>&amp;body</code> 参数通常
        被包装成一个 lambda 表达式，它们成为该表达式的主体，
        该表达式作为辅助函数的参数之一传递。
      </p>
      <p>
        语法和语义关注点的分离
        是一种通用的风格原则，
        它适用于
        <code>WITH-</code> 宏的情况之外。
        它的优点很多。
        通过将语义保留在宏之外，
        宏变得更简单，更容易正确，并且更不容易更改，
        这使得它更容易开发和维护。
        语义是用一种更简单的语言编写的——一种没有分期的语言——
        这也使得它更容易开发和维护。
        可以在不必重新编译宏的所有客户端的情况下
        调试和更新语义函数。
        语义函数出现在堆栈跟踪中，
        这也有助于调试客户端函数。
        宏扩展变得更短，并且
        每个扩展与其他扩展共享更多的代码，
        这降低了内存压力，进而通常会使事情更快。
        首先编写语义函数，
        最后编写宏作为其上的语法糖也是有意义的。
        您应该使用这种风格，除非宏用于
        性能至关重要的紧密循环中；
        即使那样，请参阅我们关于优化的规则。
      </p>
      <p>
        宏创建的任何函数（闭包）都应该被命名，
        这可以使用 <code>FLET</code> 完成。

      </p>
      <p>
        这也能让你声明函数为动态范围
        （如果它是——而且通常是；但请参阅下面关于
        <a href="#DYNAMIC-EXTENT">DYNAMIC-EXTENT</a>）。
      </p>
      <p>
        如果一个宏调用包含一个形式，
        并且宏展开包含该形式的多个副本，
        则该形式可以被多次求值，
        并且它包含的代码可以被多次宏展开和编译。
        如果有人使用该宏并使用
        具有副作用或需要很长时间计算的形式来调用它，
        则行为将是不希望的
        （除非你故意编写
        一个控制结构，例如循环）。
        避免此问题的一个便捷方法
        是仅对该形式求值一次，
        并将（生成的）变量绑定到结果。
        有一个非常有用的宏叫做 <code>ALEXANDRIA:ONCE-ONLY</code>
        ，它生成代码来执行此操作。
        另请参阅 <code>ALEXANDRIA:WITH-GENSYMS</code>，
        以在生成的代码中创建一些临时变量。
        请注意，如果你遵循我们的 <code>CALL-WITH</code> 风格，
        你通常只展开一次代码，作为
        辅助函数的参数，或者
        作为传递给它的 lambda 的主体；
        因此，你可以避免上述复杂性。
      </p>
      <p>
        当你编写带有主体的宏时，
        例如 <code>WITH-xxx</code> 宏，
        即使没有任何参数，
        你也应该为它们留出空间。
        例如，如果你发明了 <code>WITH-LIGHTS-ON</code>，
        不要让对它的调用看起来像
        <code>(defmacro with-lights-on (&amp;body b) ...)</code>。
        相反，应该写成 <code>(defmacro with-lights-on (() &amp;body b) ...)</code>。
        这样，如果将来需要参数，
        你可以添加它们，而不必更改
        宏的所有用法。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="EVAL-WHEN">
    <SUMMARY>
      当使用 <code>EVAL-WHEN</code> 时，你应该几乎总是使用所有
      <code>(:compile-toplevel :load-toplevel :execute)</code>。
    </SUMMARY>
    <BODY>
      <p>
        Lisp 求值发生在几个时间点，
        其中一些是交错的。
        编写宏时要注意它们。
        <a href="https://fare.livejournal.com/146698.html">EVAL-WHEN 对你的心理健康有害</a>。
      </p>
      <p>
        总结上面链接的文章，
        除非你正在进行真正高级的宏编程，
        否则 <code>EVAL-WHEN</code> 中唯一有效的组合
        是包含所有
        <code>(eval-when (:compile-toplevel :load-toplevel :execute) ...)</code>
      </p>
      <p>
        每当你定义函数、类型、类、常量、变量等
        将在宏中使用的内容时，
        都必须使用
        <code>(eval-when (:compile-toplevel :load-toplevel :execute) ...)</code>。
      </p>
      <p>
        省略 <code>:execute</code> 通常是一个错误，
        因为它阻止了 <code>LOAD</code> 源代码而不是 fasl 文件。
        省略 <code>:load-toplevel</code> 通常是一个错误
        （除非修改例如 readtables 和编译时设置），
        因为它阻止了 <code>LOAD</code> 未来的文件
        或交互式编译依赖于编译时发生的效果的代码，
        除非当前文件是在同一 Lisp 会话中 <code>COMPILE-FILE</code> 编译的。
      </p>
      <p>
        关于变量，请注意，由于宏可能在与运行展开代码相同的进程中展开，也可能不在，
        因此你不得依赖于编译时和运行时效果
        在另一个时间点是可见的还是不可见的。
        在宏中使用变量仍然有一些有效的用途：
      </p>
      <ul>
        <li>
          某些变量可能保存字典
          用于某种新的定义和其他元数据。
          如果此类元数据要在运行时和/或在其他文件中可见，
          你必须确保宏展开为代码，该代码
          将在加载时将定义注册到这些元数据结构，
          除了在编译时生效注册之外。
          通常，你的顶层定义会展开
          为执行注册的代码。
          如果你的代码没有在顶层展开，
          你有时可以使用 <code>LOAD-TIME-VALUE</code> 来获得良好的效果。
          在极端情况下，你可能需要使用
          <code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code>。
        </li>
        <li>
          某些变量可能保存临时数据
          仅在同一文件的编译时使用，
          并且可以在文件编译结束时清除。
          预定义的此类变量将包括 <code>*readtable*</code>
          或编译器内部变量，其中包含
          当前的优化设置。
          你通常可以使用 <code>ASDF</code> 的 <code>:AROUND-COMPILE</code> 钩子来管理现有和新的此类变量。
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Read-time evaluation">
    <SUMMARY>
      你应该谨慎使用 <code>#.</code>，
      并且必须避免读取时副作用。
    </SUMMARY>
    <BODY>
      <p>
        <code>#.</code> 标准读取宏
        将读取一个对象，对该对象求值，并且
        让读取器返回结果值。
      </p>
      <p>
        你不得在可以使用其他习惯用法的地方使用它，例如
        使用 <code>EVAL-WHEN</code> 在编译时评估副作用，
        使用常规宏返回在编译时计算的表达式，
        使用 <code>LOAD-TIME-VALUE</code> 在加载时计算它。
      </p>
      <p>
        读取时求值通常用作一种快速方法
        来获取在编译时求值的内容
        （实际上是“读取时”，但它与同一件事）。
        如果你使用此方法，则求值不得有任何副作用
        并且不得依赖于任何变量全局状态。
        <code>#.</code> 应该被视为一种方式
        来强制“常量折叠”，
        一个足够聪明的编译器
        可以自己弄清楚，
        当编译器不够聪明
        并且差异很重要时。
      </p>
      <p>
        <code>#.</code> 的另一个用途是在既不是表达式也不是（准）引用的地方
        展开等效于宏的内容，
        例如 lambda 列表。但是，如果你发现自己经常使用它，
        那么可能是时候定义宏来替换你的 lambda 列表使用者
        ，用一些可以识别扩展的东西来替换它们。
      </p>
      <p>
        每当你打算使用 <code>#.</code> 时，
        你应该考虑使用 <code>DEFCONSTANT</code> 及其变体，
        可能在 <code>EVAL-WHEN</code> 中，
        给该值一个解释其含义的名称。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="EVAL">
    <SUMMARY>
      你不得在运行时使用 <code>EVAL</code>。
    </SUMMARY>
    <BODY>
      <p>
        实际适合使用 <code>EVAL</code> 的地方
        非常少，以至于你必须咨询你的审查员；
        它很容易被滥用。
      </p>
      <p>
        如果你的代码在运行时操作符号
        并且需要获取符号的值，
        请使用 <code>SYMBOL-VALUE</code>，而不是 <code>EVAL</code>。
      </p>
      <p>
        通常，你真正需要的是编写一个宏，
        而不是使用 <code>EVAL</code>。
      </p>
      <p>
        你可能会想使用 <code>EVAL</code> 作为一种快捷方式
        来评估语言安全子集中的表达式。
        但是，正确检查和清理
        <code>EVAL</code> 的所有可能输入通常需要更多的审查
        ，而不是构建一个专用评估器。
        你不得在运行时以这种方式使用 <code>EVAL</code>。
      </p>
      <p>
        可以使用 <code>EVAL</code> 的地方是：
      </p>
      <ul>
        <li>
          交互式开发工具的实现。
        </li>
        <li>
          构建基础设施。
        </li>
        <li>
          作为测试框架一部分的后门。
          （你不得在生产代码中包含此类后门。）
        </li>
        <li>
          在编译时折叠常量的宏。
        </li>
        <li>
          将定义注册到元数据结构的宏；
          注册形式有时在编译时进行评估
          以及包含在宏展开中，
          因此它可以立即供其他宏使用。
        </li>
      </ul>
      <p>
        请注意，在后一种情况下，
        如果宏不会在顶层使用，
        则可能无法使这些定义作为展开的一部分可用。
        在 <code>DEFTYPE</code> 展开中，
        或在宏使用的辅助函数中，也可能发生相同的现象。
        在这些情况下，你实际上可能需要在宏中使用
        <code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code>。
        它不仅会在宏展开时 <code>EVAL</code> 你的定义
        以供立即使用，
        它还会将该形式保存下来，以包含在
        你需要包含在正在编译的文件的末尾
        （或在需要该形式之前）的
        <code>(ASDF-FINALIZERS:FINAL-FORMS)</code> 中。
        这样，副作用在加载 fasl 时存在
        而无需编译它，以及在编译它时；
        在任何一种情况下，该形式都可以在加载时使用。
        <code>ASDF-FINALIZERS</code> 确保该形式存在，
        如果你省略它，则会抛出错误。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="INTERN and UNINTERN">
    <SUMMARY>
      你不得在运行时使用 <code>INTERN</code> 或 <code>UNINTERN</code>。
    </SUMMARY>
    <BODY>
      <p>
        你不得在运行时使用 <code>INTERN</code>。
        它不仅会 cons，
        它还会创建一个不会被收集的永久符号
        或提供对内部符号的访问权限。
        这会造成内存泄漏、拒绝服务攻击、
        未经授权访问内部信息、与其他符号冲突的机会。
      </p>
      <p>
        你不得 <code>INTERN</code> 一个字符串
        只是为了将其与关键字进行比较；
        使用 <code>STRING=</code> 或 <code>STRING-EQUAL</code>。
      </p>
      <BAD_CODE_SNIPPET>
        (member (intern str :keyword) $keys) ; Bad
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (member str $keys :test #'string-equal) ; Better
      </CODE_SNIPPET>
      <p>
        你不得在运行时使用 <code>UNINTERN</code>。
        它会破坏依赖于动态绑定的代码。
        它使调试变得更加困难。
        你不得动态地 intern 任何新符号，
        因此你不需要动态地 unintern 任何东西。
      </p>
      <p>
        你当然可以在编译时使用 <code>INTERN</code>，
        在某些宏的实现中。
        即便如此，通常更合适
        使用它之上的抽象，例如
        <code>ALEXANDRIA:SYMBOLICATE</code> 或
        <code>ALEXANDRIA:FORMAT-SYMBOL</code>
        来创建你需要的符号。
      </p>
      
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Data Representation">
  <STYLEPOINT title="NIL: empty-list, false and I Don't Know">
    <SUMMARY>
      适当地使用或避免使用 <code>NIL</code>。
    </SUMMARY>
    <BODY>
      <p>
        <code>NIL</code> 可以有几种不同的解释：
      </p>
      <ul>
        <li>
          “假”。
          在这种情况下，使用 <code>NIL</code>。
          你应该使用运算符 <code>NOT</code> 或
          使用谓词函数 <code>NULL</code> 来测试假 <code>NIL</code>。
        </li>
        <li>
          “空列表”。
          在这种情况下，使用 <code>'()</code>。
          （调用宏时要注意引用空列表。）
          当已知参数是正确的列表时，你应该使用 <code>ENDP</code> 来测试空列表，
          否则使用 <code>NULL</code>。
        </li>
        <li>
          关于某些值未指定的声明。
          在这种情况下，你可以使用 <code>NIL</code>
          如果你的代码中任何地方都没有歧义的风险；
          否则，你应该使用显式的、描述性的符号。
        </li>
        <li>
          关于已知某些值不存在的声明。
          在这种情况下，你应该使用显式的、描述性的符号
          而不是 <code>NIL</code>。
        </li>
      </ul>
      <p>
        你不得在你的数据表示中引入歧义
        ，这会导致必须调试代码的人头疼。
        如果存在任何歧义的风险，
        你应该为每种情况使用显式的、描述性的符号或关键字
        ，而不是为任何一种情况使用 <code>NIL</code>。
        如果你确实使用 <code>NIL</code>，
        你必须确保对该区别进行了充分的记录。
      </p>
      <p>
        在许多情况下，
        与其将“我不知道”表示为特定值，
        不如使用多个值，
        一个用于已知的值（如果有），
        另一个用于表示该值是否已知或找到。
      </p>
      
      <p>
        在使用数据库类时，请记住 <code>NIL</code> 不一定总是映射到 <code>'NULL'</code>（反之亦然）！
        数据库的需求可能与 Lisp 的需求不同。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="不要滥用列表">
    <SUMMARY>
      你必须选择合适的数据表示。
      你不能滥用 <code>LIST</code> 数据结构。
    </SUMMARY>
    <BODY>
      <p>
        即使早在 1958 年，LISP 是 "LISt Processing" 的缩写，
        但它的继任者 Common Lisp 自 20 世纪 80 年代以来
        一直是一种具有现代数据结构的现代编程语言。
        你必须在你的程序中使用合适的数据结构。
      </p>
      <p>
        即使 Common Lisp 使其特别容易使用，
        你也不得滥用内置的（单链）<code>LIST</code> 数据结构，
        在不适合使用它的地方。
      </p>
      <p>
        你必须只在列表的性能特征
        适合手头的算法时才使用列表：
        对列表的整个内容进行顺序迭代。
      </p>
      <p>
        一个适合使用列表的例外情况是
        当事先知道列表的大小将保持非常短时
        （例如，少于 16 个元素）。
      </p>
      <p>
        列表数据结构通常（但并非总是）
        适用于宏和宏使用的函数在编译时使用：
        事实上，不仅源代码在 Common Lisp 中作为列表传递，
        而且宏展开和编译过程
        通常会按顺序遍历整个源代码一次。
        （请注意，高级宏系统不直接使用列表，而是
        使用跟踪源代码位置和范围的抽象语法对象；
        但是，目前 Common Lisp 中没有这种高级宏系统。）
      </p>
      <p>
        另一个适合使用列表的例外情况是
        用于引入字面常量，
        这些常量将在编译时或加载时转换为更合适的数据结构。
        最好有一个名称相对较短的函数
        来从这些字面量构建程序的数据结构。
      </p>
      <p>
        在许多列表不适合作为数据结构的情况下，
        各种库，例如
        <a href="http://cliki.net/cl-containers">cl-containers</a> 或
        <a href="http://cliki.net/lisp-interface-library">lisp-interface-library</a>
        提供了许多不同的数据结构，
        应该满足你的程序的所有基本需求。
        如果现有库不令人满意，请参阅上面关于
        <a href="#Using_Libraries">使用库</a> 和
        <a href="#Open-Sourcing_Code">开源代码</a> 的内容。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="列表 vs. 结构 vs. 多个值">
    <SUMMARY>
      你应该为产品类型使用适当的表示。
    </SUMMARY>
    <BODY>
      <p>
        你应该避免将列表用作任何东西，
        除了相同类型元素的容器。
        你不得使用列表作为传递
        不同类型的多个单独值
        进出函数调用的方法。
        有时使用列表作为
        一个小型的临时结构很方便，
        即“列表的第一个元素是 FOO，第二个元素是 BAR”，
        但这应该尽量少用，
        因为它越来越难记住这个小约定。
        你必须仅在以下情况下以这种方式使用列表：
        解构函数中的参数列表，
        或创建参数列表
        以 <code>APPLY</code> 函数。
      </p>
      <p>
        传递包含多个异构类型值的对象的
        正确方法是使用 <code>DEFSTRUCT</code>
        或 <code>DEFCLASS</code> 定义的结构。
      </p>
      <p>
        你应该仅在函数返回少量值时才使用多个值，
        这些值旨在由调用者立即解构，
        而不是作为参数一起传递给其他函数。
      </p>
      <p>
        你不应该将条件对象作为
        一组多个值中的一个返回。
        相反，你应该发出条件信号以表示不寻常的结果。
      </p>
      <p>
        你应该发出条件信号以表示不寻常的结果，
        而不是依赖于特殊的返回类型。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="列表 vs. 对">
    <SUMMARY>
      在操作列表时使用适当的函数。
    </SUMMARY>
    <BODY>
      <p>
        使用 <code>FIRST</code> 访问列表的第一个元素，
        使用 <code>SECOND</code> 访问第二个元素，等等。
        使用 <code>REST</code> 访问列表的尾部。
        使用 <code>ENDP</code> 测试列表的结尾。
      </p>
      <p>
        当 cons 单元未用于实现正确的列表
        而是被视为一对更通用的对象时，
        使用 <code>CAR</code> 和 <code>CDR</code>。
        在这种情况下，使用 <code>NULL</code> 测试 <code>NIL</code>。
      </p>
      <p>
        后一种情况在 alist 之外应该很少见，
        因为你应该在使用结构和类的地方使用它们，
        并且在你想要树时使用数据结构库。
      </p>
      <p>
        例外情况下，你可以在手动解构列表时
        在列表上使用 <code>CDADR</code> 和其他变体，
        而不是使用多个列表访问器函数的组合。
        在这种情况下，使用 <code>CAR</code> 和 <code>CDR</code>
        代替 <code>FIRST</code> 和 <code>REST</code> 也是有意义的。
        但是，请记住，在这种情况下，使用更高级别的构造（例如
        <code>DESTRUCTURING-BIND</code> 或 <code>OPTIMA:MATCH</code>）可能更合适。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="列表 vs. 数组">
    <SUMMARY>
      如果随机访问很重要，你应该使用数组而不是列表。
    </SUMMARY>
    <BODY>
      <p>
        当在列表上使用时，<code>ELT</code> 具有 <i>O(n)</i> 行为。
        如果你要在对象上使用随机元素访问，
        请改用数组和 <code>AREF</code>。
      </p>
      <p>
        例外情况是对于关键路径之外的代码，
        其中已知列表无论如何都很小。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="列表 vs. 集合">
    <SUMMARY>
      你应该只将列表用作非常小的列表的集合。
    </SUMMARY>
    <BODY>
      <p>
        使用列表作为集合的表示是一个坏主意，
        除非你知道列表会很小，
        因为访问器是 <i>O(n)</i> 而不是 <i>O(log n)</i>。
        对于任意大的集合，使用平衡二叉树，
        例如使用 <code>lisp-interface-library</code>。
      </p>
      <p>
        如果你仍然使用列表作为集合，
        你不应该仅仅为了搜索它们而 <code>UNION</code> 列表。
      </p>
      <BAD_CODE_SNIPPET>
        (member foo (union list-1 list-2)) ; Bad
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (or (member foo list-1) (member foo list-2)) ; Better
      </CODE_SNIPPET>
      <p>
        事实上，<code>UNION</code> 不仅不必要地 cons，
        而且在某些实现上可能是 <i>O(n^2)</i>，
        即使它是 <i>O(n)</i>，速度也相当慢。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="正确的形式">
  <p>
    你必须遵循关于
    众所周知的函数、宏和特殊形式的正确用法。
  </p>
  <STYLEPOINT title="定义常量">
    <SUMMARY>
      你必须为常量值使用正确的定义形式。
    </SUMMARY>
    <BODY>
      <p>
        我们主要使用的 Lisp 系统 SBCL 非常挑剔，
        并且每当常量被重新定义为与之前的设置不 <code>EQL</code> 的值时，
        都会发出一个条件信号。
        在定义不是
        数字、字符或符号（包括布尔值和关键字）的变量时，
        你不得使用 <code>DEFCONSTANT</code>。
        相反，始终如一地使用为你的项目推荐的任何替代方案。
      </p>
      <BAD_CODE_SNIPPET>
        ;; Bad
        (defconstant +google-url+ "https://www.google.com/")
        (defconstant +valid-colors+ '(red green blue))
      </BAD_CODE_SNIPPET>
      
      
      
      
      <p>
        开源库可以使用
        <code>ALEXANDRIA:DEFINE-CONSTANT</code>
        用于数字、字符和符号（包括布尔值和关键字）以外的常量。
        你可以使用 <code>:TEST</code> 关键字参数
        来指定相等谓词。
      </p>
      <CODE_SNIPPET>
        ;; Better, for Open-Source code:
        (define-constant +google-url+ "https://www.google.com/" :test #'string=)
        (define-constant +valid-colors+ '(red green blue))
      </CODE_SNIPPET>
      <p>
        请注意，对于优化实现（例如 SBCL 或 CMUCL），
        以这种方式定义常量会阻止任何后续的重新定义，
        除非 <code>UNINTERN</code> 该符号
        并重新编译其所有客户端。
        这可能会使在 REPL 中调试事物
        或部署实时代码升级变得“有趣”。
        如果你的“常量”在你的服务器进程的生命周期内
        在考虑到计划内和计划外的代码补丁后，
        有可能不是常量，
        你应该考虑使用
        <code>DEFPARAMETER</code> 或 <code>DEFVAR</code> 代替，
        或者可能是 <code>DEFINE-CONSTANT</code> 的变体，
        它建立在一些未来的库之上，该库实现全局词法作用域，
        而不是 <code>DEFCONSTANT</code>。
        在这种情况下，你可以保留 <code>+plus+</code> 约定
        来记录参数作为常量的意图。
      </p>
      <p>
        另请注意，<code>LOAD-TIME-VALUE</code> 可能会帮助你
        避免对已定义常量的需求。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="定义函数">
    <SUMMARY>
      你应该正确使用
      <code>&amp;OPTIONAL</code> 和
      <code>&amp;KEY</code> 参数。
      你不应该使用 <code>&amp;AUX</code> 参数。
    </SUMMARY>
    <BODY>
      <p>
        你应该避免使用 <code>&amp;ALLOW-OTHER-KEYS</code>，
        因为它模糊了函数的约定。
        几乎任何真正的函数（通用的或非通用的）都允许一定的
        固定关键字集，就其调用者而言，
        这些关键字是其约定的一部分。
        如果你正在实现泛型函数的方法，
        并且它不需要知道
        某些关键字参数的值，
        你应该显式地 <code>(DECLARE (IGNORE ...))</code>
        所有你没有使用的参数。
        除非你明确想要禁用对所有方法的允许键的检查，
        否则你不得使用 <code>&amp;ALLOW-OTHER-KEYS</code>，
        当在与此特定方法匹配的参数上调用泛型函数时。
        请注意，泛型函数的约定属于
        <code>DEFGENERIC</code>，而不是 <code>DEFMETHOD</code>，
        就泛型函数的调用者而言，
        后者基本上是泛型函数的“实现细节”。
      </p>
      <p>
        <code>&amp;ALLOW-OTHER-KEYS</code> 适用的情况是
        当你编写一个包装函数来包装其他一些函数时，
        这些函数可能会有所不同（在计算中或在开发过程中），
        并将 plist 作为 <code>&amp;REST</code> 参数传递。
      </p>
      <p>
        你应该避免使用 <code>&amp;AUX</code> 参数。
      </p>
      <p>
        你应该避免同时使用 <code>&amp;OPTIONAL</code>
        和 <code>&amp;KEY</code> 参数，
        除非在未指定所有可选参数时，
        指定关键字参数永远没有意义。
        当你的函数同时具有 <code>&amp;OPTIONAL</code>
        和 <code>&amp;KEY</code> 参数时，
        你不得为你的 <code>&amp;OPTIONAL</code> 参数设置非 <code>NIL</code> 默认值。
      </p>
      <p>
        为了库的最大可移植性，良好的形式是
        <code>DEFMETHOD</code> 定义应该
        <code>(DECLARE (IGNORABLE ...))</code>
        所有它们没有使用的必需参数。
        事实上，如果你 <code>(DECLARE (IGNORE ...))</code> 这些参数，
        某些实现会发出警告，
        而如果你未能 <code>(DECLARE (IGNORE ...))</code> 它们，
        其他实现会发出警告。
        <code>(DECLARE (IGNORABLE ...))</code> 适用于所有实现。
      </p>
      <p>
        你应该避免在函数内部过度嵌套绑定形式。
        如果你的函数最终出现大量嵌套，
        你应该将其分解为多个函数或宏。
        如果它确实是一个单一的概念单元，
        请考虑使用诸如 <code>FARE-UTILS:NEST</code> 之类的宏
        至少减少所需的缩进量。
        在典型的短函数中使用 <code>NEST</code> 是一种不好的形式，
        这些函数具有 4 个或更少的嵌套级别，
        但在具有 10 个或更多嵌套级别的特殊长函数中不使用它也是一种不好的形式。
        运用你的判断力并咨询你的审阅者。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="条件表达式">
    <SUMMARY>
      使用适当的条件形式。
    </SUMMARY>
    <BODY>
      <p>
        当只有一个备选项时，使用 <code>WHEN</code> 和 <code>UNLESS</code>。
        当有两个备选项时，使用 <code>IF</code>，
        当有多个备选项时，使用 <code>COND</code>。
      </p>
      <p>
        但是，不要为 <code>IF</code> 子句使用 <code>PROGN</code>
        — 使用 <code>COND</code>、<code>WHEN</code> 或 <code>UNLESS</code>。
      </p>
      <p>
        请注意，在 Common Lisp 中，
        当条件不满足时，<code>WHEN</code> 和 <code>UNLESS</code> 返回 <code>NIL</code>。
        你可以利用这一点。
        尽管如此，如果你有坚持返回值的特定理由，
        你可以使用 <code>IF</code> 显式返回 <code>NIL</code>。
        你也可以类似地包含一个直通子句 <code>(t nil)</code>
        作为你的 <cond>COND</cond> 中的最后一个，
        或者 <code>(otherwise nil)</code> 作为你的 <cond>CASE</cond> 中的最后一个，
        以强调条件语句返回的值很重要，
        并且这种情况将被使用。
        当条件语句用于副作用时，你应该省略直通子句。
      </p>
      <p>
        当使用 <code>AND</code> 和 <code>OR</code> 比使用
        <code>IF</code>、<code>COND</code>、
        <code>WHEN</code> 或 <code>UNLESS</code> 更简洁，
        并且不涉及副作用时，你应该优先使用 <code>AND</code> 和 <code>OR</code>。
        你也可以在 <code>OR</code> 的最后一个子句中使用 <code>ERROR</code>
        作为副作用。
      </p>
      <p>
        你应该只使用 <code>CASE</code> 和 <code>ECASE</code>
        来比较数字、字符或符号
        （包括布尔值和关键字）。
        实际上，<code>CASE</code> 使用 <code>EQL</code> 进行比较，
        因此字符串、路径名和结构可能不会以你期望的方式进行比较，
        并且 <code>1</code> 将不同于 <code>1.0</code>。
      </p>
      <p>
        你应该优先使用 <code>ECASE</code> 和 <code>ETYPECASE</code>
        而不是 <code>CASE</code> 和 <code>TYPECASE</code>。
        尽早捕获错误值更好。
      </p>
      <p>
        你根本不应该使用 <code>CCASE</code> 或 <code>CTYPECASE</code>。
        至少，你不应该在服务器进程中使用它们，
        除非你拥有非常健壮的错误处理基础设施
        并确保不会以这种方式泄露敏感数据。
        这些是为交互式使用而设计的，
        如果它们导致数据或控制权泄露给攻击者，
        可能会造成有趣的损害。
      </p>
      <p>
        你不得在 <code>CASE</code> 形式中使用无意义的单引号。
        这是一个常见的错误：
      </p>
      <BAD_CODE_SNIPPET>
        (case x ; Bad: silently returns NIL on mismatch
          ('bar :bar) ; Bad: catches QUOTE
          ('baz :baz)) ; Bad: also would catch QUOTE
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (ecase x ; Better: will error on mismatch
          ((bar) :bar) ; Better: won't match QUOTE
          ((baz) :baz)) ; Better: same reason
      </CODE_SNIPPET>
      <p>
        <code>'BAR</code> 在这里是 <code>(QUOTE BAR)</code>，
        这意味着如果 <code>X</code> 是 <code>QUOTE</code>，
        则将执行 case 的这一分支...
        第二个分支也是如此
        （尽管 <code>QUOTE</code> 将被第一个子句捕获）。
        这不太可能是你真正想要的。
      </p>
      <p>
        在 <code>CASE</code> 形式中，
        当你表示“如果其他子句失败，则执行此子句”时，
        你必须使用 <code>otherwise</code> 而不是 <code>t</code>。
        当你表示“匹配符号 T”而不是“匹配任何内容”时，
        你必须使用 <code>((t) ...)</code>。
        当你表示“匹配符号 NIL”而不是“匹配任何内容”时，
        你还必须使用 <code>((nil) ...)</code>。
      </p>
      <p>
        因此，如果你想将布尔值 <code>NIL</code> 和 <code>T</code>
        映射到相应的符号 <code>:BAR</code> 和 <code>:QUUX</code>，
        你应该避免前一种方式，而采用后一种方式：
      </p>
      <BAD_CODE_SNIPPET>
        (ecase x ; Bad: has no actual error case!
          (nil :bar)) ; Bad: matches nothing
          (t :quux)) ; Bad: matches anything
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (ecase x ; Better: will actually catch non-booleans
          ((nil) :bar)) ; Better: matches NIL
          ((t) :quux)) ; Better: matches T
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="标识、相等和比较">
    <SUMMARY>
      比较对象时，应使用适当的谓词。
    </SUMMARY>
    <BODY>
      <p>
        Lisp 提供了四个通用的相等谓词：
        <code>EQ</code>、<code>EQL</code>、<code>EQUAL</code> 和 <code>EQUALP</code>，
        它们的语义略有不同。
        此外，Lisp 还提供了特定于类型的谓词
        <code>=</code>、<code>CHAR=</code>、<code>CHAR-EQUAL</code>、
        <code>STRING=</code> 和 <code>STRING-EQUAL</code>。
        了解它们之间的区别！
      </p>
      <p>
        你应该使用 <code>EQL</code> 来比较对象和符号的<em>标识</em>。
      </p>
      <p>
        你不得使用 <code>EQ</code> 来比较数字或字符。
        Common Lisp 不要求两个 <code>EQL</code> 的数字或字符
        是 <code>EQ</code> 的。
      </p>
      <p>
        在 <code>EQ</code> 和 <code>EQL</code> 之间进行选择时，
        你应该使用 <code>EQL</code>，除非你正在编写
        对性能至关重要的底层代码。
        <code>EQL</code> 减少了一类令人尴尬的错误的可能性
        （即，如果曾经比较过数字或字符）。
        相对于 <code>EQ</code>，可能会有很小的性能成本，
        尽管在 SBCL 下，它通常会完全编译掉。
        <code>EQ</code> 相当于 <code>EQL</code> 和类型声明，
        并且将其用于优化应像对待任何此类
        <a href="#Unsafe_Operations">不安全操作</a>一样对待。
      </p>
      <p>
        你应该使用 <code>CHAR=</code>
        进行区分大小写的字符比较，
        并使用 <code>CHAR-EQUAL</code> 进行忽略大小写的字符比较。
      </p>
      <p>
        你应该使用 <code>STRING=</code>
        进行区分大小写的字符串比较，
        并使用 <code>STRING-EQUAL</code> 进行忽略大小写的字符串比较。
      </p>
      <p>
        在字符串上使用 <code>SEARCH</code> 时，一个常见的错误
        是将 <code>STRING=</code> 或 <code>STRING-EQUAL</code>
        作为 <code>:TEST</code> 函数提供。
        <code>:TEST</code> 函数
        被赋予两个序列元素进行比较。
        如果序列是字符串，
        则在两个字符上调用 <code>:TEST</code> 函数，
        因此正确的测试是 <code>CHAR=</code> 或 <code>CHAR-EQUAL</code>。
        如果你使用 <code>STRING=</code> 或 <code>STRING-EQUAL</code>，
        结果是你所期望的，
        但在某些 Lisp 实现中，它会慢得多。
        例如，CCL（至少截至 2008 年 8 月）
        在每次比较时创建一个单字符字符串，
        这非常昂贵。
      </p>
      <p>
        此外，你应该使用 <code>:START</code> 和 <code>:END</code> 参数
        来 <code>STRING=</code> 或 <code>STRING-EQUAL</code>，
        而不是使用 <code>SUBSEQ</code>；
        例如，<code>(string-equal (subseq s1 2 6) s2)</code> 应该改为
        <code>(string-equal s1 s2 :start1 2 :end1 6)</code>
        这是首选的，因为它不会 cons。
      </p>
      <p>
        你应该使用 <code>ZEROP</code>、
        <code>PLUSP</code> 或 <code>MINUSP</code>，
        而不是将值与 <code>0</code> 或 <code>0.0</code> 进行比较。
      </p>
      <p>
        你不得对浮点数使用精确比较，
        因为浮点运算的模糊性质
        可能会在数值中产生小的“误差”。
        你应该将绝对值与阈值进行比较。
      </p>
      <p>
        你必须使用 <code>=</code> 来比较数字，
        除非你真的希望 <code>0</code>、
        <code>0.0</code> 和 <code>-0.0</code> 比较不相等，
        在这种情况下，你应该使用 <code>EQL</code>。
        但是，你通常不得对浮点数使用精确比较。
      </p>
      <p>
        货币金额应使用十进制（有理数）
        以避免浮点运算的复杂性和舍入误差。
        诸如
        <a href="http://wukix.com/lisp-decimals">wu-decimal</a>
        之类的库可能会对你有所帮助；
        再次，如果此库不令人满意，请参阅上面关于
        <a href="#Using_Libraries">使用库</a> 和
        <a href="#Open-Sourcing_Code">开源代码</a>。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="迭代">
    <SUMMARY>
      使用适当的迭代形式。
    </SUMMARY>
    <BODY>
      <p>
        在简单的情况下，当你不会使用任何
        <code>LOOP</code> 功能（例如
        绑定、集合或块返回）时，
        你应该使用更简单的形式，例如
        <code>DOLIST</code> 或 <code>DOTIMES</code>
        而不是 <code>LOOP</code>。
      </p>
      <p>
        当使用 <code>LOOP</code> 的 <code>WITH</code> 子句
        可以避免使用 <code>LET</code> 进行嵌套时，请使用它。
        如果在使用 <code>LOOP</code> 之后返回其中一个绑定变量更清晰，
        而不是使用笨拙的 <code>FINALLY (RETURN ...)</code> 形式，
        你可以使用 <code>LET</code>。
      </p>
      <p>
        在 <code>DOTIMES</code> 的主体中，
        不要设置迭代变量。
        （如果你这样做，CCL 将发出编译器警告。）
      </p>
      <p>
        大多数系统使用当前包中未修饰的符号
        作为 <code>LOOP</code> 关键字。
        其他系统使用来自 <code>KEYWORD</code> 包的实际 <code>:keywords</code>
        作为 <code>LOOP</code> 关键字。
        你必须与你的系统中使用的约定保持一致。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="I/O">
    <SUMMARY>
      使用适当的 I/O 函数。
    </SUMMARY>
    <BODY>
      <p>
        在编写服务器时，
        代码不得将输出发送到标准流，例如
        <code>*STANDARD-OUTPUT*</code> 或 <code>*ERROR-OUTPUT*</code>。
        相反，代码必须使用适当的日志记录框架
        来输出用于调试的消息。
        我们正在作为服务器运行，因此没有控制台！
      </p>
      <p>
        代码不得使用 <code>PRINT-OBJECT</code>
        与用户通信 —
        <code>PRINT-OBJECT</code> 仅用于调试目的。
        修改任何 <code>PRINT-OBJECT</code> 方法
        不得破坏任何公共接口。
      </p>
      <p>
        你应该避免使用一系列 <code>WRITE-XXX</code>，
        而可以使用单个 <code>FORMAT</code> 字符串。
        如果将来需要，使用 format 允许你
        参数化格式控制字符串。
      </p>
      <p>
        你应该使用 <code>WRITE-CHAR</code> 发出一个字符，
        而不是使用 <code>WRITE-STRING</code>
        发出一个单字符字符串。
      </p>
      <p>
        你不应该使用 <code>(format nil "~A" value)</code>；
        你应该使用 <code>PRINC-TO-STRING</code> 代替。
      </p>
      <p>
        你应该在格式字符串中使用 <code>~&lt;Newline&gt;</code>
        或 <code>~@&lt;Newline&gt;</code>
        以防止它们在 100 列的编辑器窗口中换行，
        或者缩进节或子句以使其更具可读性。
      </p>
      <p>
        你不应该在格式控制参数上使用 <code>STRING-UPCASE</code>
        或 <code>STRING-DOWNCASE</code>；
        相反，它应该使用 <code>"~:@(~A~)"</code> 或 <code>"~(~A~)"</code>。
      </p>
      <p>
        使用 <code>FORMAT</code> 条件指令时要小心。
        参数很容易忘记。
      </p>
      <dl>
        <dt>没有参数，例如 <code>"~[Siamese~;Manx~;Persian~] Cat"</code></dt>
        <dd>
          接受一个格式参数，该参数应为整数。
          使用它来选择一个子句。子句编号从零开始。
          如果数字超出范围，则不打印任何内容。
          你可以通过在最后一个 <code>";"</code> 前面放置一个 <code>":"</code> 来提供默认值。
          例如，在 <code>"~[Siamese~;Manx~;Persian~:;Alley~] Cat"</code> 中，
          超出范围的参数打印 <code>"Alley"</code>。
        </dd>
        <dt><code>:</code> 参数，例如 <code>"~:[Siamese~;Manx~]"</code></dt>
        <dd>
          接受一个格式参数。如果它是 <code>NIL</code>，
          则使用第一个子句，否则使用第二个子句。
        </dd>
        <dt><code>@</code> 参数，例如 <code>"~@[Siamese ~a~]"</code></dt>
        <dd>
          如果下一个格式参数为真，
          则使用该选择，但不接受该参数。
          如果为假，则接受一个格式参数并且不打印任何内容。
          （通常，该子句使用格式参数。）
        </dd>
        <dt><code>#</code> 参数，例如 <code>"~#[ none~; ~s~; ~s and ~s~]"</code></dt>
        <dd>
          使用要格式化的参数数量
          作为选择子句的数字。
          在所有其他方面与没有参数相同。
          这是一个完整的复杂示例：
          <code>"Items: ~#[ none~; ~S~; ~S and ~S~:;~@{~S~^~#[~; and ~:;, ~]~}~]."</code>
        </dd>
      </dl>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="优化">
  <STYLEPOINT title="避免分配">
    <SUMMARY>
      你应该避免不必要的内存分配。
    </SUMMARY>
    <BODY>
      <p>
        在具有自动存储管理的语言（如 Lisp 或 Java）中，
        口语化的短语“内存泄漏”指的是这样一种情况：
        实际上不需要的存储空间
        由于仍然可访问而永远不会被释放。
      </p>
      <p>
        你应该小心，当你创建对象时，
        不要在它们不再需要后仍然保持可访问！
      </p>
      <p>
        这是一个 Common Lisp 中特别容易让人掉进去的陷阱。
        如果你创建了一个带有填充指针的数组，并将对象放入其中，
        然后将填充指针设置回零，
        那么就 Lisp 而言，这些对象仍然是可访问的
        （Common Lisp 规范指出，引用超出填充指针末尾的数组条目仍然是可以的）。
      </p>
      <p>
        不要不必要地 cons（即分配）。
        垃圾回收不是魔法。
        过度分配通常是一个性能问题。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="不安全操作">
    <SUMMARY>
      只有在有明确的性能需求
      并且你可以记录为什么它是正确的情况下，
      你才能使用更快的不安全操作。
    </SUMMARY>
    <BODY>
      <p>
        Common Lisp 实现通常提供后门
        以不安全的方式更快地计算某些操作。
        例如，一些库提供算术运算，
        这些运算设计为仅与 fixnum 一起使用，
        如果提供正确的参数，则可以更快地产生正确的结果。
        缺点是，如果发生溢出，此类操作的结果
        是不正确的，并且在使用除 fixnum 之外的任何参数调用时，可能会
        具有未定义的行为。
      </p>
      
      <p>
        更一般地说，不安全的操作
        将比等效的安全操作更快地产生正确的结果，
        如果参数满足某些不变式，例如
        是正确的类型并且足够小；
        但是，如果参数未能满足所需的不变式，
        则该操作可能具有未定义的行为，
        例如使软件崩溃，或者，
        有时更糟糕的是，默默地给出错误的答案。
        根据软件是驾驶飞机
        还是其他生命攸关的设备，
        或者它是否负责处理大量资金，
        这种未定义的行为可能会导致人员死亡或破产。
        然而，适当的速度有时可以区分
        软件慢得无法使用和软件能够完成其工作，
        或者区分净亏损的软件
        和可以产生利润的软件。
      </p>
      <p>
        如果没有分析结果表明需要此优化，
        并且没有仔细的文档解释为什么使用它们是安全的，
        则不得定义或使用不安全的操作。
        不安全的操作应仅限于内部函数；
        你应该仔细记录使用错误的参数使用这些函数有多么不安全。
        你应该只在包内部的函数中使用不安全的操作，并且
        你应该记录声明的使用，
        因为使用错误类型的参数调用函数
        可能会导致未定义的行为。
        在从包导出的函数中使用 <code>check-type</code>
        来清理输入参数，
        以便永远不会将非法值传递给内部函数。
      </p>
      <p>
        在某些编译器上，
        通常可以通过将
        类型声明与具有足够高的 <code>SPEED</code> 和低 <code>SAFETY</code> 的 <code>OPTIMIZE</code> 声明相结合来定义新的不安全操作。
        除了为生产代码提供更快的速度外，
        此类声明可能比 <code>check-type</code> 断言
        更有助于在编译时查找错误，
        在具有类型推断的编译器上。
        如果你切换到更安全和更慢的优化设置，
        这些编译器可能会将这些声明解释为断言；
        这对于在开发过程中定位代码中的动态错误很有用，
        但不应用于生产代码，因为它破坏了声明作为性能技巧的目的。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="DYNAMIC-EXTENT">
    <SUMMARY>
      只有在对性能有影响的地方
      并且你可以记录为什么它是正确的情况下，
      你才应该使用 <code>DYNAMIC-EXTENT</code>。
    </SUMMARY>
    <BODY>
      <p>
        <code>DYNAMIC-EXTENT</code> 声明是
        <a href="#Unsafe_Operations">不安全操作</a> 的一个特例。
      </p>
      <p>
        <code>DYNAMIC-EXTENT</code> 声明的目的是
        通过减少垃圾回收来提高性能，
        在某些情况下，对象的生命周期
        显然在函数的“动态范围”内。
        这意味着对象是在调用函数后的某个时间点创建的，并且
        在函数以任何方式退出后，该对象始终无法访问。
      </p>
      <p>
        通过声明变量或局部函数 <code>DYNAMIC-EXTENT</code>，
        程序员向 Lisp <em>断言</em>
        作为该变量的值的任何对象
        或作为函数定义的闭包
        在声明变量的（最内层）函数的动态范围内具有生命周期。
      </p>
      <p>
        然后，Lisp 实现可以自由地使用该信息
        来使程序更快。
        通常，Lisp 实现可以利用这些知识
        来进行堆栈分配：
      </p>
      <ul>
        <li>
          创建的用于存储 <code>&amp;REST</code> 参数的列表。
        </li>
        <li>
          在函数中分配的列表、向量和结构。
        </li>
        <li>
          闭包。
        </li>
      </ul>
      <p>
        如果断言是错误的，即如果程序员的声明不正确，
        则结果可能是<em>灾难性的</em>：
        Lisp 可以在函数返回后的任何时间终止，
        或者它可以永远挂起，或者——最糟糕的是——
        它可以产生不正确的结果而没有任何运行时错误！
      </p>
      <p>
        即使断言是正确的，
        将来对函数的更改可能会引入
        对断言的违反。
        这增加了危险。
      </p>
      <p>
        在大多数情况下，此类对象是短暂的。
        现代 Lisp 实现使用分代垃圾回收器，
        在这种情况下，分代垃圾回收器非常有效。
      </p>
      <p>
        因此，<code>DYNAMIC-EXTENT</code> 声明
        应谨慎使用。你只有在以下情况下才能使用它们：
      </p>
      <ol>
        <li>
          有充分的理由认为
          对性能的总体影响是显着的，并且
        </li>
        <li>
          绝对清楚断言是正确的。
        </li>
        <li>
          代码不太可能被更改
          以导致声明变为假。
        </li>
      </ol>
      <p>
        第 (1) 点是
        避免过早优化原则的一个特例。
        像这样的优化只有在以非常高的速率分配此类对象时才重要，例如“在内部循环中”。
      </p>
      <p>
        请注意，通过分析函数被调用的位置以及
        它传递给哪些其他函数，相对容易确定
        函数不会逃脱当前调用帧的动态范围；
        因此，你应该对声明函数
        <code>DYNAMIC-EXTENT</code> 有些警惕，但这并不是一个高压力的声明。
        另一方面，更难确定
        绑定或分配给该变量的任何对象
        及其任何子对象
        都不会逃脱当前调用帧的动态范围，
        并且它们在将来对函数的任何修改中仍然不会逃脱。
        因此，你应该非常警惕
        声明变量 <code>DYNAMIC-EXTENT</code>。
      </p>
      <p>
        通常很难预测这种优化对性能的影响。
        在编写作为可重用代码库一部分的函数或宏时，
        没有先验的方法知道代码将运行多少次。
        理想情况下，应该有工具可以发现
        基于运行模拟和测试用例来使用这种优化的可用性和适用性，但是
        在实践中，这并不像它应该的那样容易。
        这是一个权衡。
        如果你非常非常确定断言是正确的
        （绑定到变量的任何对象及其任何子对象
        仅在指定范围的动态范围内使用），
        并且不清楚会节省多少时间
        并且不容易测量，
        那么最好放入声明而不是将其排除在外。
        （理想情况下，进行此类测量应该比
        实际情况更容易。）
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="REDUCE vs APPLY">
    <SUMMARY>
      你应该在适当的时候使用 <code>REDUCE</code>
      而不是 <code>APPLY</code>。
    </SUMMARY>
    <BODY>
      <p>
        你应该使用 <code>REDUCE</code>
        而不是 <code>APPLY</code> 和一个 cons 起来的列表，
        其中第一个运算符参数的语义
        以其他方式保证相同的语义。
        当然，如果 <code>APPLY</code> 做了你想要的事情而 <code>REDUCE</code> 没有，
        你必须使用 <code>APPLY</code>。
        例如：
      </p>
      <BAD_CODE_SNIPPET>
        ;; 糟糕
        (apply #'+ (mapcar #'acc frobs))
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; 更好
        (reduce #'+ frobs :key #'acc :initial-value 0)
      </CODE_SNIPPET>
      <p>
        这是首选的，因为它不会进行额外的 consing，
        并且不会冒着超出 <code>CALL-ARGUMENTS-LIMIT</code> 的风险，
        在限制很小的实现中，
        这可能会在长列表上耗尽堆栈
        （我们希望避免代码中不必要的非可移植性）。
      </p>
      <p>
        但是，你必须小心不要以
        不必要地增加计算的复杂性类别的方式使用 <code>REDUCE</code>。
        例如，<code>(REDUCE 'STRCAT ...)</code> 是 <i>O(n^2)</i>，
        而适当的实现仅为 <i>O(n)</i>。
        此外，<code>(REDUCE 'APPEND ...)</code>
        也是 <i>O(n^2)</i>，除非你指定 <code>:FROM-END T</code>。
        在这种情况下，你绝不能使用 <code>REDUCE</code>，
        并且你绝不能使用 <code>(APPLY 'STRCAT ...)</code>
        或 <code>(APPLY 'APPEND ...)</code>。
        相反，你必须使用来自合适的库的适当抽象
        （你可能需要为此做出贡献），
        该库可以正确处理这些情况
        而不会让用户承担实现细节。
        例如，请参见 <code>UIOP:REDUCE/STRCAT</code>。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="避免 NCONC">
    <SUMMARY>
      你应该避免使用 <code>NCONC</code>；
      你应该使用 <code>APPEND</code> 代替，
      或者更好的数据结构。
    </SUMMARY>
    <BODY>
      <p>
        你几乎永远不应该使用 <code>NCONC</code>。
        当你不依赖任何副作用时，你应该使用 <code>APPEND</code>。
        当你需要更新变量时，你应该使用 <code>ALEXANDRIA:APPENDF</code>。
        你可能不应该依赖于
        使用当前 CONS 单元的 <code>CDR</code> 进行的游戏
        （有些人可能会认为这是规范建议但未保证的）；
        如果你这样做，你必须包含一个突出的
        注释，解释 <code>NCONC</code> 的使用；
        并且你可能应该重新考虑你的数据表示策略。
      </p>
      <p>
        通过扩展，你应该避免 <code>MAPCAN</code>
        或 <code>LOOP</code> 的 <code>NCONC</code> 功能。
        你应该分别使用
        <code>ALEXANDRIA:MAPPEND</code>
        和 <code>LOOP</code> 的 <code>APPEND</code> 功能。
      </p>
      <p>
        <code>NCONC</code> 很少是一个好主意，
        因为它的时间复杂度类别不优于 <code>APPEND</code>，
        在没有人共享副作用列表的常见情况下，它的空间复杂度类别也不优于 <code>APPEND</code>，
        并且它的错误复杂度类别远高于 <code>APPEND</code>。
      </p>
      <p>
        如果由于 <code>APPEND</code> 与 <code>NCONC</code> 相比
        造成的微小性能损失是你程序中的一个限制因素，
        那么你遇到了一个大问题，并且可能使用了错误的数据结构：
        你应该使用具有恒定时间附加的序列
        （请参阅 Okasaki 的书，并将它们添加到 lisp-interface-library），
        或者更简单地说，你应该在树中累积数据，
        该树将在累积阶段完成后以线性时间展平一次。
      </p>
      <p>
        你只能在性能重要的底层函数中使用 <code>NCONC</code>、<code>MAPCAN</code>
        或 <code>LOOP</code> 的 <code>NCONC</code> 功能，
        其中列表作为数据结构的使用已经过审查，
        因为已知这些列表很短，
        并且函数或表达式（其结果被累积）
        在其合同中明确承诺它只返回新的列表
        （特别是，它不能是常量引用或反引用表达式）。
        即使那样，此类原语的使用也必须很少见，
        并且附有证明文档。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="陷阱">
  <STYLEPOINT title="#'FUN vs. 'FUN">
    <SUMMARY>
      通常你应该使用 <code>#'FUN</code> 而不是 <code>'FUN</code> 来引用函数。
    </SUMMARY>
    <BODY>
      <p>
        前者，可以理解为 <code>(FUNCTION FUN)</code>，
        引用的是函数对象，并且是词法作用域。
        后者，可以理解为 <code>(QUOTE FUN)</code>，
        引用的是符号，当调用时
        使用该符号的全局 <code>FDEFINITION</code>。
      </p>
      <p>
        当使用接受函数式参数的函数时
        (例如，<code>MAPCAR</code>、<code>APPLY</code>、
        <code>:TEST</code> 和 <code>:KEY</code> 参数)，
        你应该使用 <code>#'</code> 来引用函数，
        而不仅仅是单引号。
      </p>
      <p>
        一个例外是当你明确想要动态链接时，
        因为你预计
        全局函数绑定会被更新。
      </p>
      <p>
        另一个例外是当你明确想要访问
        全局函数绑定，
        并避免可能的遮蔽词法绑定。
        这种情况不应该经常发生，因为当你想使用被遮蔽的函数时，遮蔽函数通常不是一个好主意；
        只需为词法函数使用不同的名称。
      </p>
      <p>
        你必须始终如一地使用 <code>#'(lambda ...)</code>
        或 <code>(lambda ...)</code>，不要到处使用 <code>#'</code>。
        与 <code>#'symbol</code> vs <code>'symbol</code> 的情况不同，
        这只是一个语法上的差异，没有语义上的影响，
        除了前者在 Genera 上有效，而后者无效。
        
        如果你的代码旨在作为库
        与所有 Common Lisp 实现具有最大的兼容性，则必须使用前一种风格；
        否则，你可以选择使用哪种风格。
        <code>#'</code> 可以被视为一个提示，
        表明你正在表达式上下文中引入一个函数；
        但 <code>lambda</code> 本身通常就足以作为提示，
        而且简洁是好的。
        明智地选择，但最重要的是，
        在同一个文件、包、系统、项目等中，与你自己和其他开发人员保持一致。
      </p>
      <p>
        请注意，如果你开始编写一个采用
        重度函数式风格的新系统，
        你可以考虑使用
        <a href="http://cliki.net/lambda-reader">lambda-reader</a>，
        一个允许你使用 Unicode 字符 <code>λ</code>
        代替 <code>LAMBDA</code> 的系统。
        但是，在没有获得其他开发人员的许可的情况下，你不得在现有系统中开始使用这种语法扩展。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="路径名">
    <SUMMARY>
      Common Lisp 路径名很棘手。注意陷阱。使用 <code>UIOP</code>。
    </SUMMARY>
    <BODY>
      <p>
        令人惊讶的是，在 Common Lisp 中正确处理路径名非常困难。
      </p>
      <p>
        <code>ASDF 3</code> 附带了一个可移植性库 <code>UIOP</code>，
        它使得在 Common Lisp 中以可移植的方式 — 并且正确地 — 处理路径名<em>容易得多</em>。
        你应该在适当的时候使用它。
      </p>
      <p>
        首先，要注意
        Common Lisp 路径名的语法之间的差异，
        这取决于你使用的实现和操作系统，
        以及你的操作系统上路径名的原生语法。
        Lisp 语法可能涉及引用特殊字符，
        例如 <code>#\.</code> 和 <code>#\*</code> 等，
        此外还有引用字符串中的
        <code>#\\</code> 和 <code>#\"</code>。
        相比之下，你的操作系统的其他
        系统编程语言
        （shell、C、脚本语言）
        可能只有一层引用，进入字符串。
      </p>
      <p>
        其次，当使用 <code>MERGE-PATHNAMES</code> 时，
        要注意 <code>HOST</code> 组件的处理，
        这在非 Unix 平台上非常重要
        （甚至在某些 Unix 实现上也是如此）。
        你可能应该使用
        <code>UIOP:MERGE-PATHNAMES*</code> 或 <code>UIOP:SUBPATHNAME</code>
        而不是 <code>MERGE-PATHNAMES</code>，
        特别是如果你的相对路径名的期望
        受到它们在 Unix 或 Windows 中的工作方式的影响；
        否则你可能会遇到奇怪的错误，即在某些实现上，
        将相对路径名与绝对路径名合并
        会导致覆盖绝对路径名的主机
        并将其替换为
        <code>*DEFAULT-PATHNAME-DEFAULTS*</code> 的值中的主机
        在创建相对路径名时。
      </p>
      <p>
        第三，要注意 <code>DIRECTORY</code>
        在如何处理通配符、子目录、符号链接等方面
        在不同实现之间是不可移植的。
        同样，<code>UIOP</code> 提供了几个
        用于处理路径名的通用抽象，
        但只能做到这么好。
        对于完整的可移植解决方案，请使用 IOLib —
        尽管它对 Windows 的支持滞后。
      </p>
      <p>
        <code>LOGICAL-PATHNAME</code>s 不是可移植的抽象，
        不应在可移植代码中使用。
        许多实现中都存在错误，即使它们受到支持。
        SBCL 对它们的实现非常好，
        但严格执行标准允许的字符限制，
        这限制了它们的适用性。
        其他实现允许在此类路径名中使用任意字符，
        但这样做并不符合标准，
        并且在许多方面仍然彼此不兼容。
        你应该使用其他路径名抽象，
        例如 <code>ASDF:SYSTEM-RELATIVE-PATHNAME</code> 或
        底层的 <code>UIOP:SUBPATHNAME</code> 和
        <code>UIOP:PARSE-UNIX-NAMESTRING</code>。
      </p>
      
      <p>
        最后，请注意，在
        你为应用程序构建 Lisp 镜像的时间，
        和你从其镜像运行应用程序的时间之间，路径可能会发生变化。
        你应该小心地重置你的镜像，
        以忘记不相关的构建时路径，并
        从当前环境变量重新初始化任何搜索路径。
        例如，<code>ASDF</code> 要求你使用 <code>UIOP:CLEAR-CONFIGURATION</code> 重置其路径。
        <code>UIOP</code> 提供了钩子
        在转储镜像之前调用函数，
        从中重置或 <code>makunbound</code> 相关变量。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="SATISFIES">
    <SUMMARY>
      在使用类型说明符中的 <code>SATISFIES</code> 子句时，必须小心。
    </SUMMARY>
    <BODY>
      <p>
        大多数 Common Lisp 实现无法基于 <code>SATISFIES</code> 类型进行优化，
        但许多实现基于以下形式的类型提供简单的优化：
        <code>(AND FOO (SATISFIES BAR-P))</code>
        其中 <code>AND</code> 子句的第一项
        描述了对象的结构，
        没有任何 <code>SATISFIES</code>，
        第二项是 <code>SATISFIES</code>。
      </p>
      <BAD_CODE_SNIPPET>
        (deftype prime-number () (satisfies prime-number-p)) ; 糟糕
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (deftype prime-number () (and integer (satisfies prime-number-p)) ; 更好
      </CODE_SNIPPET>
      <p>
        但是，<code>DEFTYPE</code> 语言中的 <code>AND</code>
        不是像表达式语言中那样的从左到右的短路运算符；
        它是一个对称连接器，允许重新排序子项
        并且不保证短路。
        因此，在上面的例子中，
        你不能依赖于 <code>INTEGER</code> 性的测试
        来保护函数 <code>PRIME-NUMBER-P</code>
        免受提供非整数参数
        来测试是否为该类型实例的影响。
        实现可能会，并且有些<em>会</em>，
        在编译时调用 <code>SATISFIES</code> 指定的函数
        来测试各种相关的对象。
      </p>
      <p>
        这就是为什么在 <code>SATISFIES</code> 子句中指定的任何函数
        必须接受任何类型的对象作为函数的参数，
        并且必须在 <code>EVAL-WHEN</code> 中定义
        （以及它使用的任何变量或调用的函数）：
      </p>
      <BAD_CODE_SNIPPET>
        (defun prime-number-p (n) ; 双重糟糕！
          (let ((m (abs n)))
            (if (&lt;= m *prime-number-cutoff*)
                (small-prime-number-p m)
                (big-prime-number-p m))))
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (eval-when (:compile-toplevel :load-toplevel :execute) ; 更好
          (defun prime-number-p (n)
            (when (integerp n) ; 更好
              (let ((m (abs n)))
                (if (&lt;= m *prime-number-cutoff*)
                    (small-prime-number-p m)
                    (big-prime-number-p m))))))
      </CODE_SNIPPET>
      <p>
        特别是，以上意味着
        <a href="https://www.lispworks.com/documentation/HyperSpec/Body/t_satisf.htm">示例</a>
        在 Common Lisp 标准中使用的是错误的：
        <code>(and integer (satisfies evenp))</code>
        <em>不是</em>一个安全、符合标准的类型说明符，
        因为当传递一个非整数作为参数时，<code>EVENP</code> 会抛出一个错误，
        而不是返回 <code>NIL</code>。
      </p>
      <p>
        最后，当你的 <code>DEFTYPE</code> 代码扩展
        到具有动态生成函数的 <code>SATISFIES</code> 时，会有一个陷阱：
      </p>
      <ul>
        <li>
          你无法控制实现何时会或不会
          扩展 <code>DEFTYPE</code>。
        </li>
        <li>
          扩展本身不能包含函数定义
          或表达式语言中的任何代码。
        </li>
        <li>
          你无法控制何时使用扩展，
          它可能发生在不同的进程中，
          该进程没有扩展定义。
        </li>
      </ul>
      <p>
        因此，你不能仅仅通过在类型扩展时
        使用 <code>EVAL</code> 作为扩展的副作用来创建函数。
        解决方案是使用
        <code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code> 代替。
        请参阅关于 <a href="#EVAL">EVAL</a> 的讨论中的最后一点。
      </p>
      <p>
        Common Lisp 很难满足。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<HR/>

<small>Credits:
   Adam Worrall, Dan Pierson, Matt Marjanovic, Matt Reklaitis,
   Paul Weiss, Scott McKay, Sundar Narasimhan,
   and several other people contributed.
   Special thanks to Steve Hain,
   and to the previous editors,
   in reverse chronological order Dan Weinreb and Jeremy Brown.
</small>

<p align="right">
Revision 1.28
</p>


<address>
Robert Brown
</address>

<address>
  <a HREF="mailto:tunes@google.com">François-René Rideau</a>
</address>



</GUIDE>
