<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<title>Google C++ 风格指南</title>
<link rel="stylesheet" href="include/styleguide.css">
<script src="include/styleguide.js"></script>
<link rel="shortcut icon" href="/styleguide/favicon.ico">
</head>
<body onload="initStyleGuide();">
<div id="content">
<h1>Google C++ 风格指南</h1>
<div class="horizontal_toc" id="tocDiv"></div>

<h2 id="Background" class="ignoreLink">背景</h2>

<p>C++ 是 Google 许多开源项目使用的主要开发语言之一。正如每个 C++ 程序员所知，该语言具有许多强大的功能，但这种力量带来了复杂性，反过来可能使代码更容易出错，且更难阅读和维护。</p>

<p>本指南的目标是通过详细描述编写 C++ 代码的应做和不应做来管理这种复杂性。这些规则的存在是为了在允许编码人员有效使用 C++ 语言功能的同时，保持代码库的可管理性。</p>

<p><em>风格</em>，也称为可读性，是我们对管理 C++ 代码的惯例的称呼。风格这个术语有点误导，因为这些惯例涵盖的不仅仅是源文件格式化。</p>

<p>
Google 开发的大多数开源项目都符合本指南中的要求。
</p>

<p>请注意，本指南不是 C++ 教程：我们假设读者已经熟悉该语言。</p>

<h3 id="Goals">风格指南的目标</h3>

<p>我们为什么需要这份文档？</p>

<p>我们认为这份指南应该服务于几个核心目标。这些是所有单个规则背后的根本<b>原因</b>。通过突出这些理念，我们希望为讨论提供基础，并使我们的更广泛社区更清楚规则存在的理由以及为何做出特定决定。如果您理解每条规则服务的目标，那么当规则可以被豁免时（有些可以），对每个人来说应该更清楚需要什么样的论据或替代方案来更改指南中的规则。</p>

<p>我们目前认为的风格指南的目标如下：</p>
<dl>
<dt>风格规则应发挥其作用</dt>
<dd>风格规则的益处必须足够大，以证明要求我们所有工程师记住它是合理的。益处是相对于没有该规则时我们将得到的代码库来衡量的，因此，如果人们不太可能做某事，那么反对一种非常有害的做法的规则可能仍然只有很小的益处。这条原则主要解释了我们没有的规则，而不是我们有的规则：例如，<code>goto</code>违反了许多以下原则，但已经非常罕见，因此风格指南没有讨论它。</dd>

<dt>为读者而不是作者优化</dt>
<dd>我们的代码库（以及提交给它的大多数单个组件）预计将持续相当长的时间。因此，我们的代码将花费更多的时间阅读而不是编写。我们明确选择优化我们平均软件工程师在我们的代码库中阅读、维护和调试代码的体验，而不是编写代码时的便利性。“为读者留下痕迹”是这一原则的一个特别常见的子点：当代码片段中发生令人惊讶或不寻常的事情时（例如，指针所有权的转移），在使用点为读者留下文本提示是有价值的（<code>std::unique_ptr</code>在调用点明确展示了所有权转移）。</dd>

<dt>与现有代码保持一致</dt>
<dd>在我们的代码库中一致地使用一种风格让我们能够专注于其他（更重要）的议题。一致性还允许自动化：只有当您的代码与工具的期望一致时，格式化您的代码或调整您的<code>#include</code>的工具才能正常工作。在许多情况下，归因于“保持一致”的规则归结为“选择一个并停止担心它”；允许在这些点上灵活性的潜在价值被人们争论这些点所带来的成本所抵消。然而，一致性是有限度的；当没有明确的技术论据，也没有长期方向时，它是一个很好的决策依据。它在本地（每文件，或对于一组紧密相关的接口）应用得更重。一般来说，不应将一致性用作在不考虑新风格的好处或代码库随时间趋向于新风格的倾向的情况下，继续使用旧风格的理由。</dd>

<dt>在适当的时候与更广泛的C++社区保持一致</dt>
<dd>与其他组织使用C++的方式保持一致具有与我们代码库内一致性相同的价值。如果C++标准中的一个特性解决了一个问题，或者某种习惯用法被广泛认可和接受，那就是使用它的论据。然而，有时标准特性和习惯用法是有缺陷的，或者只是在设计时没有考虑到我们的代码库的需求。在这些情况下（如下所述），限制或禁止标准特性是适当的。在某些情况下，我们更倾向于使用自制或第三方库，而不是C++标准中定义的库，要么是因为认为其优越性，要么是因为转换到标准接口的代码库价值不足。</dd>

<dt>避免令人惊讶或危险的构造</dt>
<dd>C++有一些特性比乍看之下更令人惊讶或危险。一些风格指南的限制是为了防止陷入这些陷阱。对于此类限制，风格指南的豁免标准很高，因为豁免此类规则往往直接冒着损害程序正确性的风险。</dd>

<dt>避免我们的平均C++程序员会觉得棘手或难以维护的构造</dt>
<dd>C++有一些特性可能不适合普遍使用，因为它们给代码引入了复杂性。在广泛使用的代码中，使用更棘手的语言构造可能是可以接受的，因为更复杂实现的任何好处都会因使用而被广泛放大，并且在处理代码库的新部分时，不需要再次支付理解复杂性的成本。当有疑问时，可以通过询问您的项目负责人来寻求此类规则的豁免。这对于我们的代码库特别重要，因为代码所有权和团队成员身份会随时间变化：即使目前与某段代码一起工作的所有人都理解它，这种理解在几年后也不保证仍然有效。</dd>

<dt>注意我们的规模</dt>
<dd>拥有超过1亿行的代码库和数千名工程师，一个工程师的错误和简化可能会对许多人造成成本。例如，避免污染全局命名空间特别重要：在数亿行的代码库中，名称冲突很难处理且难以避免，如果每个人都将东西放入全局命名空间中。</dd>

<dt>在必要时让步于优化</dt>
<dd>性能优化有时是必要且适当的，即使它们与本文档的其他原则相冲突。</dd>
</dl>

<p>这份文档的意图是提供最大限度的指导，同时保持合理的限制。如往常一样，常识和良好的品味应该占上风。我们在这里特别指的是整个Google C++社区的既定惯例，而不仅仅是您的个人偏好或您的团队的偏好。对巧妙或不寻常的构造持怀疑和不情愿的态度：没有禁止并不意味着可以继续。使用您的判断，如果您不确定，请不要犹豫，询问您的项目负责人以获得更多意见。</p>

<h2 id="C++_Version">C++版本</h2>

<p>目前，代码应针对C++20，即不应使用C++23特性。本指南所针对的C++版本将随着时间（积极地）前进。</p>

<p>不要使用<a href="#Nonstandard_Extensions">非标准扩展</a>。</p>

<div>
<p>在您的项目中使用C++17和C++20的特性之前，请考虑到其他环境的可移植性。</p>
</div>
<h2 id="Header_Files">头文件</h2>

<p>一般来说，每个 <code>.cc</code> 文件都应该有一个关联的 <code>.h</code> 文件。一些常见的例外情况包括单元测试和只包含 <code>main()</code> 函数的小型 <code>.cc</code> 文件。</p>

<p>正确使用头文件可以极大地影响代码的可读性、大小和性能。</p>

<p>以下规则将指导您如何避免使用头文件时可能遇到的各种陷阱。</p>

<a id="The_-inl.h_Files"></a>
<h3 id="Self_contained_Headers">自包含头文件</h3>

<p>头文件应该自包含（能够独立编译）并以 <code>.h</code> 结尾。非头文件但用于包含的文件应以 <code>.inc</code> 结尾，并且应谨慎使用。</p>

<p>所有头文件都应该是自包含的。用户和重构工具不应需要遵循特殊条件来包含头文件。具体来说，头文件应该有 <a href="#The__define_Guard">头文件保护</a> 并包含它所需的所有其他头文件。</p>

<p>当头文件声明内联函数或模板时，如果这些函数或模板将由头文件的客户端实例化，那么这些内联函数和模板的定义也必须在头文件中，直接或通过它包含的文件。不要将这些定义移动到单独包含的头文件（<code>-inl.h</code>）中；这种做法在过去很常见，但现在不再允许。当一个模板的所有实例化都发生在一个 <code>.cc</code> 文件中时，无论是因为它们是 <a href="https://en.cppreference.com/w/cpp/language/class_template#Explicit_instantiation">显式</a> 的，还是因为定义只对 <code>.cc</code> 文件可访问，模板定义可以保存在该文件中。</p>

<p>在极少数情况下，设计用于包含的文件可能不是自包含的。这些文件通常打算在不常见的地方包含，例如在另一个文件的中间。它们可能不使用 <a href="#The__define_Guard">头文件保护</a>，并且可能不包含其前提条件。将此类文件命名为 <code>.inc</code> 扩展名。谨慎使用，并在可能的情况下优先使用自包含头文件。</p>

<h3 id="The__define_Guard">#define 保护</h3>

<p>所有头文件都应该有 <code>#define</code> 保护以防止多次包含。符号名称的格式应为

<code><i>&lt;PROJECT&gt;</i>_<i>&lt;PATH&gt;</i>_<i>&lt;FILE&gt;</i>_H_</code>。</p>

<div>
<p>为了保证唯一性，它们应该基于项目源代码树中的完整路径。例如，项目 <code>foo</code> 中的文件 <code>foo/src/bar/baz.h</code> 应该有以下保护：</p>
</div>

<pre>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
</pre>

<h3 id="Include_What_You_Use">包含你所使用的内容</h3>

<p>如果源文件或头文件引用了在其他地方定义的符号，该文件应直接包含一个头文件，该头文件明确打算提供该符号的声明或定义。不要出于其他原因包含头文件。</p>

<p>不要依赖传递包含。这允许人们从他们的头文件中删除不再需要的 <code>#include</code> 语句，而不会破坏客户端。这也适用于相关头文件 - 如果 <code>foo.cc</code> 使用了其中的符号，即使 <code>foo.h</code> 包含了 <code>bar.h</code>，<code>foo.cc</code> 也应该包含 <code>bar.h</code>。</p>

<h3 id="Forward_Declarations">前向声明</h3>

<p>尽可能避免使用前向声明。相反，<a href="#Include_What_You_Use">包含你需要的头文件</a>。</p>

<p class="definition"></p>
<p>“前向声明”是指没有关联定义的实体声明。</p>
<pre>// 在 C++ 源文件中：
class B;
void FuncInB();
extern int variable_in_b;
ABSL_DECLARE_FLAG(flag_in_b);
</pre>

<p class="pros"></p>
<ul>
  <li>前向声明可以节省编译时间，因为 <code>#include</code> 会迫使编译器打开更多文件并处理更多输入。</li>

  <li>前向声明可以减少不必要的重新编译。 <code>#include</code> 可能会因为头文件中的无关更改而迫使您的代码更频繁地重新编译。</li>
</ul>

<p class="cons"></p>
<ul>
  <li>前向声明可以隐藏依赖关系，允许用户代码在头文件更改时跳过必要的重新编译。</li>

  <li>与 <code>#include</code> 语句相比，前向声明使得自动工具难以发现定义符号的模块。</li>

  <li>前向声明可能会因库的后续更改而失效。前向声明函数和模板可能会阻止头文件所有者对其 API 进行其他兼容的更改，例如扩大参数类型、添加具有默认值的模板参数或迁移到新的命名空间。</li>

  <li>从命名空间 <code>std::</code> 前向声明符号会导致未定义行为。</li>

  <li>很难确定是需要前向声明还是完整的 <code>#include</code>。用前向声明替换 <code>#include</code> 可能会悄无声息地改变代码的含义：
<pre>// b.h:
struct B {};
struct D : B {};

// good_user.cc:
#include "b.h"
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // 调用 f(B*)
</pre>
  如果用 <code>B</code> 和 <code>D</code> 的前向声明替换了 <code>#include</code>，<code>test()</code> 将调用 <code>f(void*)</code>。
  </li>

  <li>从一个头文件中前向声明多个符号可能比简单地 <code>#include</code> 该头文件更冗长。</li>

  <li>为了启用前向声明而结构化代码（例如，使用指针成员而不是对象成员）可能会使代码变得更慢和更复杂。</li>
</ul>

<p class="decision"></p>
<p>尽量避免前向声明在另一个项目中定义的实体。</p>
<h3 id="Inline_Functions">内联函数</h3>

<p>仅当函数较小时（例如，不超过10行）才定义为内联函数。</p>

<p class="definition"></p>
<p>您可以以一种允许编译器将函数扩展为内联的方式声明函数，而不是通过通常的函数调用机制调用它们。</p>

<p class="pros"></p>
<p>内联函数可以生成更高效的目标代码，只要内联的函数较小即可。可以随意内联访问器和修改器，以及其他短小的、性能关键的函数。</p>

<p class="cons"></p>
<p>过度使用内联实际上可能会使程序变慢。根据函数的大小，内联它可能会导致代码大小增加或减少。内联一个非常小的访问器函数通常会减少代码大小，而内联一个非常大的函数可能会显著增加代码大小。在现代处理器上，较小的代码通常运行得更快，因为它更好地利用了指令缓存。</p>

<p class="decision"></p>
<p>一个不错的经验法则是，如果函数超过10行长，就不要将其内联。注意析构函数，它们通常因为隐式的成员和基类析构函数调用而比看起来更长！</p>

<p>另一个有用的经验法则是，内联带有循环或switch语句的函数通常不划算（除非在常见情况下，循环或switch语句从未执行）。</p>

<p>重要的是要知道，即使函数被声明为内联，它们也不总是被内联；例如，虚函数和递归函数通常不会被内联。通常递归函数不应该被内联。使虚函数内联的主要原因是将其定义放在类中，要么为了方便，要么为了记录其行为，例如，对于访问器和修改器。</p>

<h3 id="Names_and_Order_of_Includes">包含文件的名称和顺序</h3>

<p>按以下顺序包含头文件：相关头文件，C系统头文件，C++标准库头文件，其他库的头文件，您的项目的头文件。</p>

<p>
项目的所有头文件都应列为项目源目录的后代，不使用UNIX目录别名
<code>.</code>（当前目录）或 <code>..</code>
（父目录）。例如，

<code>google-awesome-project/src/base/logging.h</code>
应包含为：</p>

<pre>#include "base/logging.h"
</pre>

<p>只有当库要求您这样做时，才应使用尖括号路径包含头文件。特别是，以下头文件需要使用尖括号：</p>

<ul>
<li>C和C++标准库头文件（例如 <code>&lt;stdlib.h&gt;</code>
  和 <code>&lt;string&gt;</code>）。</li>
<li>POSIX、Linux和Windows系统头文件（例如 <code>&lt;unistd.h&gt;</code>
  和 <code>&lt;windows.h&gt;</code>）。</li>
<li>在极少数情况下，第三方库（例如 <code>&lt;Python.h&gt;</code>）。</li>
</ul>

<p>在 <code><var>dir/foo</var>.cc</code> 或
<code><var>dir/foo_test</var>.cc</code> 中，其主要目的是实现或测试
<code><var>dir2/foo2</var>.h</code> 中的内容，按以下顺序排列您的包含文件：</p>

<ol>
  <li><code><var>dir2/foo2</var>.h</code>。</li>

  <li>一个空行</li>

  <li>C系统头文件，以及任何其他带有 <code>.h</code> 扩展名的尖括号中的头文件，例如 <code>&lt;unistd.h&gt;</code>，
    <code>&lt;stdlib.h&gt;</code>，<code>&lt;Python.h&gt;</code>。</li>

  <li>一个空行</li>

  <li>C++标准库头文件（无文件扩展名），例如，
    <code>&lt;algorithm&gt;</code>，<code>&lt;cstddef&gt;</code>。</li>

  <li>一个空行</li>

  <div>
  <li>其他库的 <code>.h</code> 文件。</li>

  <li>一个空行</li>
  </div>

  <li>
  您的项目的 <code>.h</code>
  文件。</li>
</ol>

<p>用一个空行分隔每个非空组。</p>

<p>使用首选顺序，如果相关头文件
<code><var>dir2/foo2</var>.h</code> 省略了任何必要的包含，
<code><var>dir/foo</var>.cc</code> 或 <code><var>dir/foo</var>_test.cc</code> 的构建将会失败。
因此，此规则确保构建失败首先显示给正在处理这些文件的人，而不是其他包中的无辜人士。</p>

<p><code><var>dir/foo</var>.cc</code> 和
<code><var>dir2/foo2</var>.h</code> 通常位于同一目录中（例如，<code>base/basictypes_test.cc</code> 和
<code>base/basictypes.h</code>），但有时也可能位于不同的目录中。</p>

<p>请注意，像 <code>stddef.h</code> 这样的C头文件基本上可以与其C++对应物
(<code>cstddef</code>) 互换。
两种风格都可以接受，但应与现有代码保持一致性。</p>

<p>在每个部分中，包含文件应按字母顺序排列。请注意，旧代码可能不符合此规则，应在方便时进行修复。</p>

<p>例如，

<code>google-awesome-project/src/foo/internal/fooserver.cc</code>
中的包含文件可能如下所示：</p>

<pre>#include "foo/server/fooserver.h"

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#include &lt;string&gt;
#include &lt;vector&gt;

#include "base/basictypes.h"
#include "foo/server/bar.h"
#include "third_party/absl/flags/flag.h"
</pre>

<p><b>例外情况：</b></p>

<p>有时，特定于系统的代码需要条件包含。此类代码可以在其他包含之后放置条件包含。当然，请保持您的特定于系统的代码小而局部化。示例：</p>

<pre>#include "foo/public/fooserver.h"

#include "base/port.h"  // 为了LANG_CXX11。

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11
</pre>

<h2 id="Scoping">作用域</h2>
<h3 id="Namespaces">命名空间</h3>

<p>除了少数例外情况，代码应放置在命名空间中。命名空间应基于项目名称，并可能基于其路径来命名。不要使用<i>using指令</i>（例如，<code>using namespace foo</code>）。不要使用内联命名空间。关于未命名命名空间，请参见<a href="#Internal_Linkage">内部链接</a>。

</p><p class="definition"></p>
<p>命名空间将全局作用域细分为不同的命名作用域，因此有助于防止全局作用域中的名称冲突。</p>

<p class="pros"></p>

<p>命名空间提供了一种方法，可以在大型程序中防止名称冲突，同时允许大多数代码使用合理简短的名称。</p>

<p>例如，如果两个不同的项目在全局作用域中都有一个类<code>Foo</code>，这些符号可能会在编译时或运行时发生冲突。如果每个项目将其代码放置在命名空间中，<code>project1::Foo</code>和<code>project2::Foo</code>现在是不同的符号，不会发生冲突，并且每个项目命名空间内的代码可以继续引用<code>Foo</code>而无需前缀。</p>

<p>内联命名空间会自动将其名称放置在封闭作用域中。例如，考虑以下代码片段：</p>

<pre class="neutralcode">namespace outer {
inline namespace inner {
  void foo();
}  // namespace inner
}  // namespace outer
</pre>

<p>表达式<code>outer::inner::foo()</code>和<code>outer::foo()</code>是可以互换的。内联命名空间主要用于跨版本的ABI兼容性。</p>

<p class="cons"></p>

<p>命名空间可能会引起混淆，因为它们使确定名称所指的定义的机制变得复杂。</p>

<p>特别是内联命名空间可能会引起混淆，因为名称实际上并不限于它们声明的命名空间。它们仅在某些更大的版本策略的一部分中才有用。</p>

<p>在某些情况下，需要反复引用符号的完全限定名称。对于深度嵌套的命名空间，这可能会增加很多杂乱。</p>

<p class="decision"></p>

<p>应按以下方式使用命名空间：</p>

<ul>
  <li>遵循<a href="#Namespace_Names">命名空间名称</a>的规则。
  </li><li>如给定示例所示，用注释结束多行命名空间。
  </li><li>

  <p>命名空间应包裹整个源文件，位于包含文件、<a href="https://gflags.github.io/gflags/">gflags</a>定义/声明以及来自其他命名空间的类的前向声明之后。</p>

<pre>// 在.h文件中
namespace mynamespace {

// 所有声明都在命名空间作用域内。
// 注意没有缩进。
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
</pre>

<pre>// 在.cc文件中
namespace mynamespace {

// 函数的定义在命名空间作用域内。
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace
</pre>

  <p>更复杂的<code>.cc</code>文件可能有额外的细节，如标志或using声明。</p>

<pre>#include "a.h"

ABSL_FLAG(bool, someflag, false, "一个标志");

namespace mynamespace {

using ::foo::Bar;

...mynamespace的代码...    // 代码靠左边界对齐。

}  // namespace mynamespace
</pre>
  </li>

  <li>要将生成的协议消息代码放置在命名空间中，请在<code>.proto</code>文件中使用<code>package</code>说明符。详情请参见<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#package">协议缓冲区包</a>。</li>

  <li>不要在<code>std</code>命名空间中声明任何内容，包括标准库类的前向声明。在<code>std</code>命名空间中声明实体是未定义行为，即不可移植的。要声明标准库中的实体，请包含相应的头文件。</li>

  <li><p>你不能使用<i>using指令</i>来使命名空间中的所有名称可用。</p>

<pre class="badcode">// 禁止使用 - 这会污染命名空间。
using namespace foo;
</pre>
  </li>

  <li><p>不要在头文件的命名空间作用域中使用<i>命名空间别名</i>，除非在明确标记为内部使用的命名空间中，因为在头文件中导入到命名空间中的任何内容都将成为该文件导出的公共API的一部分。</p>

<pre>// 在.cc文件中缩短对一些常用名称的访问。
namespace baz = ::foo::bar::baz;
</pre>

<pre>// 在.h文件中缩短对一些常用名称的访问。
namespace librarian {
namespace internal {  // 内部使用，不属于API的一部分。
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace internal

inline void my_inline_function() {
  // 局部于函数（或方法）的命名空间别名。
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</pre>

  </li><li>不要使用内联命名空间。</li>

  <li><p>使用命名空间中包含"internal"的名称来记录API的部分，这些部分不应由API的用户提及。
    </p>

<pre class="badcode">// 我们不应在非absl代码中使用这个内部名称。
using ::absl::container_internal::ImplementationDetail;
</pre>
  </li>

  <li><p>在新代码中，首选单行嵌套命名空间声明，但这不是必需的。</p>
  </li>
</ul>

<a id="Unnamed_Namespaces_and_Static_Variables"></a>
<h3 id="Internal_Linkage">内部链接</h3>

<p>当<code>.cc</code>文件中的定义不需要在该文件之外被引用时，通过将它们放置在未命名命名空间中或声明为<code>static</code>来赋予它们内部链接。在<code>.h</code>文件中不要使用这些构造。

</p><p class="definition"></p>
<p>通过将声明放置在未命名命名空间中，可以赋予所有声明内部链接。函数和变量也可以通过声明为<code>static</code>来赋予内部链接。这意味着你声明的任何内容都不能从另一个文件中访问。如果另一个文件声明了相同名称的东西，那么这两个实体是完全独立的。</p>

<p class="decision"></p>

<p>鼓励在<code>.cc</code>文件中使用内部链接，对于所有不需要在其他地方引用的代码。在<code>.h</code>文件中不要使用内部链接。</p>

<p>将未命名命名空间的格式设置为与命名命名空间相同。在终止注释中，保留命名空间名称为空：</p>

<pre>namespace {
...
}  // namespace
</pre>

<h3 id="Nonmember,_Static_Member,_and_Global_Functions">非成员函数、静态成员函数和全局函数</h3>

<p>优先将非成员函数放置在命名空间中；很少使用完全全局的函数。不要仅仅为了分组静态成员而使用类。类的静态方法通常应与类的实例或类的静态数据密切相关。</p>


<p class="pros"></p>
<p>非成员函数和静态成员函数在某些情况下可能很有用。将非成员函数放置在命名空间中可以避免污染全局命名空间。</p>

<p class="cons"></p>
<p>非成员函数和静态成员函数可能更适合作为新类的成员，特别是如果它们访问外部资源或有重大依赖关系时。</p>

<p class="decision"></p>
<p>有时定义一个不绑定到类实例的函数是有用的。这样的函数可以是静态成员函数或非成员函数。非成员函数不应依赖外部变量，并且几乎总是应该存在于命名空间中。不要仅仅为了分组静态成员而创建类；这与只是给名称一个共同前缀没有区别，而且这种分组通常是不必要的。</p>

<p>如果您定义了一个非成员函数，并且它只在其<code>.cc</code>文件中需要，请使用<a href="#Internal_Linkage">内部链接</a>来限制其作用域。</p>

<h3 id="Local_Variables">局部变量</h3>

<p>将函数的变量放在尽可能窄的作用域内，并在声明时初始化变量。</p>

<p>C++允许您在函数中的任何位置声明变量。我们鼓励您在尽可能局部的作用域中声明它们，并且尽可能靠近首次使用的地方。这使得读者更容易找到声明，并看到变量的类型以及它被初始化为什么。特别是，应该使用初始化而不是声明和赋值，例如：</p>

<pre class="badcode">int i;
i = f();      // 不好 - 初始化与声明分开。
</pre>

<pre>int i = f();  // 好 - 声明包含初始化。
</pre>


<pre class="badcode">int jobs = NumJobs();
// 更多代码...
f(jobs);      // 不好 - 声明与使用分开。
</pre>

<pre>int jobs = NumJobs();
f(jobs);      // 好 - 声明紧接着（或紧密跟随）使用。
</pre>

<pre class="badcode">std::vector&lt;int&gt; v;
v.push_back(1);  // 建议使用大括号初始化。
v.push_back(2);
</pre>

<pre>std::vector&lt;int&gt; v = {1, 2};  // 好 - v 开始时已初始化。
</pre>

<p>用于<code>if</code>、<code>while</code>和<code>for</code>语句的变量通常应在这些语句内声明，以便这些变量被限制在这些作用域内。例如：</p>

<pre>while (const char* p = strchr(str, '/')) str = p + 1;
</pre>

<p>有一个注意事项：如果变量是一个对象，每次进入作用域时都会调用其构造函数，每次离开作用域时都会调用其析构函数。</p>

<pre class="badcode">// 低效实现：
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // 我的构造函数和析构函数各被调用1000000次。
  f.DoSomething(i);
}
</pre>

<p>在循环外声明此类变量可能更有效：</p>

<pre>Foo f;  // 我的构造函数和析构函数各被调用一次。
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>
<h3 id="Static_and_Global_Variables">静态和全局变量</h3>

<p>具有
<a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">
静态存储期</a>的对象是禁止的，除非它们是
<a href="http://en.cppreference.com/w/cpp/types/is_destructible">平凡可销毁</a>的。
非正式地讲，这意味着析构函数不执行任何操作，即使考虑到成员和基类的析构函数。
更正式地说，这意味着该类型没有用户定义的或虚拟的析构函数，并且所有基类和非静态成员都是平凡可销毁的。
静态函数局部变量可以使用动态初始化。
在有限的情况下，允许对静态类成员变量或命名空间范围内的变量使用动态初始化，但不鼓励这样做；详见下文。</p>

<p>作为经验法则：如果一个全局变量的声明，在孤立考虑的情况下，可以是 <code>constexpr</code>，那么它就满足这些要求。</p>

<p class="definition"></p>
<p>每个对象都有一个 <dfn>存储期</dfn>，它与其生命周期相关联。具有静态存储期的对象从初始化开始一直存在到程序结束。
这样的对象出现在命名空间范围内的变量（“全局变量”）、类的静态数据成员，或者使用 <code>static</code> 说明符声明的函数局部变量中。
函数局部静态变量在控制首次通过其声明时初始化；所有其他具有静态存储期的对象在程序启动时初始化。
所有具有静态存储期的对象在程序退出时被销毁（这发生在未连接的线程终止之前）。</p>

<p>初始化可能是 <dfn>动态</dfn> 的，这意味着在初始化期间会发生一些非平凡的事情。（例如，考虑一个分配内存的构造函数，或者一个用当前进程ID初始化的变量。）
另一种初始化是 <dfn>静态</dfn> 初始化。这两者并不完全是相反的：静态初始化 <em>总是</em> 发生在具有静态存储期的对象上（将对象初始化为给定的常量或所有字节设置为零的表示），而动态初始化在需要时随后发生。</p>

<p class="pros"></p>
<p>全局和静态变量对于许多应用程序非常有用：命名常量、某些翻译单元内部的辅助数据结构、命令行标志、日志记录、注册机制、后台基础设施等。</p>

<p class="cons"></p>
<p>使用动态初始化或具有非平凡析构函数的全局和静态变量会产生复杂性，容易导致难以发现的错误。动态初始化在翻译单元之间没有顺序，销毁也是如此（除了销毁以初始化的相反顺序发生）。
当一个初始化引用另一个具有静态存储期的变量时，可能会导致在对象生命周期开始之前（或结束之后）访问该对象。
此外，当程序启动未在退出时连接的线程时，这些线程可能会在对象的生命周期结束后尝试访问对象，如果它们的析构函数已经运行的话。</p>

<p class="decision"></p>
<h4>关于销毁的决策</h4>

<p>当析构函数是平凡的时，它们的执行完全不受顺序的影响（它们实际上不被“运行”）；否则我们就面临在对象生命周期结束后访问对象的风险。
因此，我们只允许具有静态存储期的对象如果它们是平凡可销毁的。
基本类型（如指针和 <code>int</code>）是平凡可销毁的，同样，数组的平凡可销毁类型也是如此。
请注意，用 <code>constexpr</code> 标记的变量是平凡可销毁的。</p>
<pre>const int kNum = 10;  // 允许

struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // 允许

void foo() {
  static const char* const kMessages[] = {"hello", "world"};  // 允许
}

// 允许：constexpr 保证平凡析构函数。
constexpr std::array&lt;int, 3&gt; kArray = {1, 2, 3};</pre>
<pre class="badcode">// 错误：非平凡析构函数
const std::string kFoo = "foo";

// 出于相同原因错误，即使 kBar 是引用（该规则也适用于生命周期延长的临时对象）。
const std::string&amp; kBar = StrCat("a", "b", "c");

void bar() {
  // 错误：非平凡析构函数。
  static std::map&lt;int, int&gt; kData = {{1, 0}, {2, 0}, {3, 0}};
}</pre>

<p>请注意，引用不是对象，因此不受可销毁性约束的影响。不过，动态初始化的约束仍然适用。
特别是，形式为 <code>static T&amp; t = *new T;</code> 的函数局部静态引用是允许的。</p>

<h4>关于初始化的决策</h4>

<p>初始化是一个更复杂的话题。这是因为我们不仅必须考虑类构造函数是否执行，还必须考虑初始化表达式的评估：</p>
<pre class="neutralcode">int n = 5;    // 很好
int m = f();  // ?（取决于 f）
Foo x;        // ?（取决于 Foo::Foo）
Bar y = g();  // ?（取决于 g 和 Bar::Bar）
</pre>

<p>除了第一条语句外，其余都暴露了不确定的初始化顺序。</p>

<p>我们寻找的概念在 C++ 标准的正式语言中称为 <em>常量初始化</em>。它意味着初始化表达式是一个常量表达式，如果对象通过构造函数调用初始化，那么构造函数也必须指定为 <code>constexpr</code>：</p>
<pre class="goodcode">struct Foo { constexpr Foo(int) {} };

int n = 5;  // 很好，5 是一个常量表达式。
Foo x(2);   // 很好，2 是一个常量表达式，并且选择的构造函数是 constexpr。
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // 很好</pre>

<p>常量初始化总是被允许的。静态存储期变量的常量初始化应标记为 <code>constexpr</code> 或 <code>constinit</code>。
任何未标记为此的非局部静态存储期变量都应假定为具有动态初始化，并应非常仔细地审查。</p>

<p>相比之下，以下初始化存在问题：</p>

<pre class="badcode">// 下面使用的一些声明。
```cpp
time_t time(time_t*);      // 不是constexpr！
int f();                   // 不是constexpr！
struct Bar { Bar() {} };

// 有问题的初始化。
time_t m = time(nullptr);  // 初始化表达式不是常量表达式。
Foo y(f());                // 同上
Bar b;                     // 选择的构造函数Bar::Bar()不是constexpr。
```
</pre>

<p>不鼓励非局部变量的动态初始化，通常情况下这是被禁止的。然而，如果程序的任何方面都不依赖于这种初始化与所有其他初始化的顺序，我们是允许的。在这些限制下，初始化的顺序不会产生可观察的差异。例如：</p>
<pre>int p = getpid();  // 允许的，只要没有其他静态变量
                   // 在其自身初始化中使用p。</pre>

<p>静态局部变量的动态初始化是允许的（并且很常见）。</p>

<h4>常见模式</h4>

<ul>
  <li>全局字符串：如果您需要一个命名的全局或静态字符串常量，请考虑使用<code>constexpr</code>变量的<code>string_view</code>、字符数组或字符指针，指向字符串字面量。字符串字面量已经具有静态存储持续时间，通常就足够了。参见<a href="https://abseil.io/tips/140">TotW #140.</a></li>
  <li>映射、集合和其他动态容器：如果您需要一个静态的、固定的集合，例如用于搜索的集合或查找表，您不能将标准库中的动态容器用作静态变量，因为它们具有非平凡的析构函数。相反，请考虑使用简单数组的平凡类型，例如，一个整数数组的数组（用于“从整数到整数的映射”），或一对数组（例如，<code>int</code>和<code>const char*</code>的对）。对于小集合，线性搜索完全足够（并且由于内存局部性而高效）；考虑使用<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/algorithm/container.h">absl/algorithm/container.h</a>中的设施进行标准操作。如果需要，请保持集合按排序顺序，并使用二分搜索算法。

    如果您确实更喜欢标准库中的动态容器，请考虑使用下文描述的函数局部静态指针。</li>
  <li>智能指针（<code>std::unique_ptr</code>、<code>std::shared_ptr</code>）：智能指针在销毁时执行清理操作，因此被禁止。考虑您的用例是否符合本节中描述的其他模式。一个简单的解决方案是使用指向动态分配对象的普通指针，并且永远不删除它（参见最后一项）。</li>
  <li>自定义类型的静态变量：如果您需要静态的、常量的数据，并且需要自己定义类型，请为该类型提供一个平凡的析构函数和一个<code>constexpr</code>构造函数。</li>
  <li>如果一切都失败了，您可以通过使用函数局部静态指针或引用（例如，<code>static const auto&amp; impl = *new T(args...);</code>）来动态创建对象并永远不删除它。</li>
</ul>
<h3 id="thread_local">thread_local 变量</h3>

<p>不在函数内部声明的 <code>thread_local</code> 变量必须使用真正的编译时常量进行初始化，并且必须通过使用
<a href="https://en.cppreference.com/w/cpp/language/constinit">
  <code>constinit</code></a>
属性来强制执行此要求。应优先使用 <code>thread_local</code> 而不是其他定义线程本地数据的方式。</p>

<p class="definition"></p>
<p>变量可以使用 <code>thread_local</code> 说明符声明：</p>
<pre>thread_local Foo foo = ...;
</pre>
<p>这样的变量实际上是一组对象，因此当不同线程访问它时，它们实际上是在访问不同的对象。
<code>thread_local</code> 变量在许多方面类似于
<a href="#Static_and_Global_Variables">静态存储期变量</a>。
例如，它们可以在命名空间范围内、函数内部或作为静态类成员声明，但不能作为普通类成员声明。</p>

<p><code>thread_local</code> 变量实例的初始化方式与静态变量类似，只是它们必须为每个线程分别初始化，而不是在程序启动时初始化一次。这意味着在函数内部声明的 <code>thread_local</code> 变量是安全的，但其他 <code>thread_local</code> 变量会受到与静态变量相同（甚至更多）的初始化顺序问题的影响。</p>

<p><code>thread_local</code> 变量有一个微妙的销毁顺序问题：在线程关闭期间，<code>thread_local</code> 变量将以与其初始化顺序相反的顺序销毁（这在 C++ 中通常是正确的）。如果任何 <code>thread_local</code> 变量的析构函数触发的代码引用了该线程上已销毁的 <code>thread_local</code>，我们将遇到特别难以诊断的使用后释放问题。</p>

<p class="pros"></p>
<ul>
  <li>线程本地数据本质上是安全的，不会发生竞争（因为通常只有一个线程可以访问它），这使得 <code>thread_local</code> 在并发编程中非常有用。</li>
  <li><code>thread_local</code> 是创建线程本地数据的唯一标准支持方式。</li>
</ul>

<p class="cons"></p>
<ul>
  <li>访问 <code>thread_local</code> 变量可能会在线程启动或在给定线程上的首次使用时触发执行不可预测和不可控制的其他代码量。</li>
  <li><code>thread_local</code> 变量实际上是全局变量，具有除线程安全性之外的所有全局变量的缺点。</li>
  <li><code>thread_local</code> 变量消耗的内存随运行线程的数量（在最坏情况下）成比例增加，这在程序中可能相当大。</li>
  <li>数据成员不能是 <code>thread_local</code>，除非它们也是 <code>static</code> 的。</li>
  <li>如果 <code>thread_local</code> 变量具有复杂的析构函数，我们可能会遭受使用后释放错误。特别是，任何此类变量的析构函数不得（传递地）调用任何引用可能已销毁的 <code>thread_local</code> 的代码。此属性难以强制执行。</li>

  <li>在全局/静态上下文中避免使用后释放的方法对 <code>thread_local</code> 不适用。具体来说，跳过全局和静态变量的析构函数是允许的，因为它们的生命周期在程序关闭时结束。因此，任何“泄漏”都会立即由操作系统清理我们的内存和其他资源。相比之下，跳过 <code>thread_local</code> 变量的析构函数会导致资源泄漏，这些泄漏与程序生命周期内终止的线程总数成比例。</li>

</ul>

<p class="decision"></p>
  <p>类或命名空间范围内的 <code>thread_local</code> 变量必须使用真正的编译时常量进行初始化（即，它们不得有动态初始化）。为了强制执行这一点，类或命名空间范围内的 <code>thread_local</code> 变量必须使用
  <a href="https://en.cppreference.com/w/cpp/language/constinit">
    <code>constinit</code></a>
  （或 <code>constexpr</code>，但这应该很少见）进行注释：</p>

  <pre>   constinit thread_local Foo foo = ...;
  </pre>

  <p>函数内部的 <code>thread_local</code> 变量没有初始化问题，但在线程退出时仍有使用后释放的风险。请注意，您可以通过定义一个函数或静态方法来暴露它，从而使用函数范围内的 <code>thread_local</code> 来模拟类或命名空间范围内的 <code>thread_local</code>：</p>

<pre>Foo&amp; MyThreadLocalFoo() {
  thread_local Foo result = ComplicatedInitialization();
  return result;
}
</pre>

  <p>请注意，<code>thread_local</code> 变量会在线程退出时销毁。如果任何此类变量的析构函数引用了其他（可能已销毁的）<code>thread_local</code>，我们将遭受难以诊断的使用后释放错误。应优先使用简单类型，或在销毁时证明不运行任何用户提供的代码的类型，以尽量减少访问任何其他 <code>thread_local</code> 的可能性。
  </p>

<p>应优先使用 <code>thread_local</code> 而不是其他机制来定义线程本地数据。</p>

<h2 id="Classes">类</h2>

<p>类是 C++ 中的基本代码单元。自然，我们广泛使用它们。本节列出了编写类时应遵循的主要做法和禁忌。</p>
<h3 id="Doing_Work_in_Constructors">在构造函数中执行工作</h3>

<p>避免在构造函数中调用虚函数，并且避免可能失败的初始化操作，如果无法发出错误信号的话。</p>

<p class="definition"></p>
<p>可以在构造函数的主体中执行任意初始化操作。</p>

<p class="pros"></p>
<ul>
  <li>无需担心类是否已初始化。</li>

  <li>通过构造函数调用完全初始化的对象可以是<code>const</code>，并且可能更容易与标准容器或算法一起使用。</li>
</ul>

<p class="cons"></p>
<ul>
  <li>如果工作调用了虚函数，这些调用不会分派到子类的实现。如果你的类当前没有被子类化，未来对类的修改可能会悄悄引入这个问题，造成很大的混乱。</li>

  <li>构造函数没有简单的方法来发出错误信号，除了崩溃程序（不总是合适的）或使用异常（这是<a href="#Exceptions">禁止的</a>）。</li>

  <li>如果工作失败，我们现在有一个初始化代码失败的对象，因此它可能处于一种需要<code>bool IsValid()</code>状态检查机制（或类似机制）的异常状态，这种机制很容易忘记调用。</li>

  <li>无法获取构造函数的地址，因此在构造函数中执行的工作无法轻松地移交给例如另一个线程。</li>
</ul>

<p class="decision"></p>
<p>构造函数永远不应调用虚函数。如果适合你的代码，终止程序可能是适当的错误处理响应。否则，考虑使用工厂函数或如<a href="https://abseil.io/tips/42">TotW #42</a>中描述的<code>Init()</code>方法。避免在没有其他状态影响可调用公共方法的对象上使用<code>Init()</code>方法（这种形式的半构造对象特别难以正确处理）。</p>

<a id="Explicit_Constructors"></a>
<h3 id="Implicit_Conversions">隐式转换</h3>

<p>不要定义隐式转换。对于转换运算符和单参数构造函数，使用<code>explicit</code>关键字。</p>

<p class="definition"></p>
<p>隐式转换允许一种类型的对象（称为源类型）在期望不同类型（称为目标类型）的地方使用，例如将<code>int</code>参数传递给接受<code>double</code>参数的函数时。</p>

<p>除了语言定义的隐式转换外，用户可以通过向源类型或目标类型的类定义中添加适当的成员来定义自己的隐式转换。源类型中的隐式转换由以目标类型命名的类型转换运算符定义（例如，<code>operator bool()</code>）。目标类型中的隐式转换由可以接受源类型作为其唯一参数（或唯一没有默认值的参数）的构造函数定义。</p>

<p><code>explicit</code>关键字可以应用于构造函数或转换运算符，以确保它只能在使用点明确指定目标类型时使用，例如使用强制转换。这不仅适用于隐式转换，也适用于列表初始化语法：</p>
<pre>class Foo {
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);
</pre>
<pre class="badcode">Func({42, 3.14});  // 错误
</pre>
<p>这种代码在技术上不是隐式转换，但就<code>explicit</code>而言，语言将其视为一种隐式转换。</p>

<p class="pros"></p>
<ul>
<li>隐式转换可以通过消除在明显的情况下显式命名类型的需要，使类型更易用和更具表达力。</li>
<li>隐式转换可以作为重载的更简单替代方案，例如，当一个带有<code>string_view</code>参数的单一函数替代了<code>std::string</code>和<code>const char*</code>的单独重载时。</li>
<li>列表初始化语法是初始化对象的简洁且富有表现力的方式。</li>
</ul>

<p class="cons"></p>
<ul>
<li>隐式转换可以隐藏类型不匹配的错误，其中目标类型与用户的期望不符，或者用户不知道将发生任何转换。</li>

<li>隐式转换可能使代码更难阅读，特别是在存在重载的情况下，因为它使实际调用的代码变得不那么明显。</li>

<li>接受单个参数的构造函数可能会意外地用作隐式类型转换，即使它们不是为了这样做的。</li>

<li>当单参数构造函数未标记为<code>explicit</code>时，没有可靠的方法来判断它是打算定义隐式转换，还是作者只是忘记标记它了。</li>

<li>隐式转换可能导致调用点的歧义，特别是当存在双向隐式转换时。这可能是由两种类型都提供隐式转换引起的，或者由单一类型同时具有隐式构造函数和隐式类型转换运算符引起的。</li>

<li>如果目标类型是隐式的，列表初始化可能会遇到相同的问题，特别是当列表只有一个元素时。</li>
</ul>

<p class="decision"></p>
<p>类型转换运算符和可使用单个参数调用的构造函数必须在类定义中标记为<code>explicit</code>。作为例外，复制和移动构造函数不应标记为<code>explicit</code>，因为它们不执行类型转换。</p>

<p>对于设计为可互换的类型，有时隐式转换是必要且适当的，例如当两种类型的对象只是相同底层值的不同表示时。在这种情况下，请联系你的项目负责人请求豁免此规则。</p>

<p>不能使用单个参数调用的构造函数可以省略<code>explicit</code>。接受单个<code>std::initializer_list</code>参数的构造函数也应省略<code>explicit</code>，以支持复制初始化（例如，<code>MyType m = {1, 2};</code>）。</p>
<h3 id="Copyable_Movable_Types">可复制和可移动类型</h3>
<a id="Copy_Constructors"></a>

<p>类的公共API必须明确指出该类是可复制的、仅可移动的，还是既不可复制也不可移动的。如果这些操作对您的类型来说是清晰且有意义的，请支持复制和/或移动操作。</p>

<p class="definition"></p>
<p>可移动类型是指可以从临时对象初始化和赋值的类型。</p>

<p>可复制类型是指可以从同一类型的任何其他对象初始化或赋值的类型（因此按定义也是可移动的），前提是源对象的值不会改变。<code>std::unique_ptr&lt;int&gt;</code>是一个可移动但不可复制的类型的例子（因为在赋值给目标时，源<code>std::unique_ptr&lt;int&gt;</code>的值必须被修改）。<code>int</code>和<code>std::string</code>是既可移动又可复制的类型的例子。（对于<code>int</code>，移动和复制操作是相同的；对于<code>std::string</code>，存在一个比复制更便宜的移动操作。）</p>

<p>对于用户定义的类型，复制行为由复制构造函数和复制赋值运算符定义。移动行为由移动构造函数和移动赋值运算符定义，如果它们存在的话，否则由复制构造函数和复制赋值运算符定义。</p>

<p>复制/移动构造函数在某些情况下可以被编译器隐式调用，例如在按值传递对象时。</p>

<p class="pros"></p>
<p>可复制和可移动类型的对象可以按值传递和返回，这使得API更简单、更安全、更通用。与按指针或引用传递对象不同，不存在对所有权、生命周期、可变性等问题的混淆风险，也不需要在合同中指定这些。它还防止了客户端和实现之间的非本地交互，使它们更易于理解、维护和由编译器优化。此外，这样的对象可以与需要按值传递的通用API一起使用，例如大多数容器，并且它们允许在类型组合等方面提供额外的灵活性。</p>

<p>复制/移动构造函数和赋值运算符通常比<code>Clone()</code>、<code>CopyFrom()</code>或<code>Swap()</code>等替代方案更容易正确定义，因为它们可以由编译器生成，无论是隐式地还是使用<code>= default</code>。它们简洁，并确保所有数据成员都被复制。复制和移动构造函数通常也更有效，因为它们不需要堆分配或单独的初始化和赋值步骤，并且它们有资格进行优化，例如<a href="http://en.cppreference.com/w/cpp/language/copy_elision">复制消除</a>。</p>

<p>移动操作允许从右值对象隐式且高效地转移资源。这在某些情况下允许更简单的编码风格。</p>

<p class="cons"></p>
<p>有些类型不需要可复制，为这样的类型提供复制操作可能会引起混淆、无意义或完全错误。表示单例对象（<code>Registerer</code>）、与特定作用域绑定的对象（<code>Cleanup</code>）或与对象身份密切相关的类型（<code>Mutex</code>）不能有意义地复制。用于多态的基类类型的复制操作是危险的，因为使用它们可能导致<a href="https://en.wikipedia.org/wiki/Object_slicing">对象切片</a>。默认或粗心实现的复制操作可能是不正确的，结果的错误可能令人困惑且难以诊断。</p>

<p>复制构造函数被隐式调用，这使得调用容易被忽略。这可能对习惯于按引用传递是常规或强制性的语言的程序员造成混淆。它也可能鼓励过多的复制，这可能导致性能问题。</p>

<p class="decision"></p>

<p>每个类的公共接口必须明确指出该类支持哪些复制和移动操作。这通常应采取在声明中的<code>public</code>部分明确声明和/或删除适当操作的形式。</p>

<p>具体来说，可复制类应明确声明复制操作，仅可移动类应明确声明移动操作，不可复制/移动类应明确删除复制操作。可复制类还可以声明移动操作以支持高效移动。明确声明或删除所有四个复制/移动操作是允许的，但不是必需的。如果您提供了复制或移动赋值运算符，您还必须提供相应的构造函数。</p>

<pre>class Copyable {
 public:
  Copyable(const Copyable&amp; other) = default;
  Copyable&amp; operator=(const Copyable&amp; other) = default;

  // 上述声明抑制了隐式移动操作。
  // 您可以明确声明移动操作以支持高效移动。
};

class MoveOnly {
 public:
  MoveOnly(MoveOnly&amp;&amp; other) = default;
  MoveOnly&amp; operator=(MoveOnly&amp;&amp; other) = default;

  // 复制操作被隐式删除，但您可以
  // 明确指出这一点如果您愿意：
  MoveOnly(const MoveOnly&amp;) = delete;
  MoveOnly&amp; operator=(const MoveOnly&amp;) = delete;
};

class NotCopyableOrMovable {
 public:
  // 不可复制或移动
  NotCopyableOrMovable(const NotCopyableOrMovable&amp;) = delete;
  NotCopyableOrMovable&amp; operator=(const NotCopyableOrMovable&amp;)
      = delete;

  // 移动操作被隐式禁用，但您可以
  // 明确指出这一点如果您愿意：
  NotCopyableOrMovable(NotCopyableOrMovable&amp;&amp;) = delete;
  NotCopyableOrMovable&amp; operator=(NotCopyableOrMovable&amp;&amp;)
      = delete;
};
</pre>

<p>这些声明/删除操作只有在它们显而易见时才可以省略：</p>
<ul>
<li>如果类没有<code>private</code>部分，如<a href="#Structs_vs._Classes">结构体</a>或仅接口的基类，那么可复制性/可移动性可以通过任何公共数据成员的可复制性/可移动性来确定。
</li><li>如果基类显然不可复制或不可移动，那么派生类自然也不会是。仅接口的基类留下这些操作隐式是不足以使具体子类明确的。
</li><li>请注意，如果您明确声明或删除了复制构造函数或赋值操作的任一个，那么另一个复制操作不是显而易见的，必须声明或删除。移动操作也是如此。
</li></ul>
<p>如果复制/移动的含义对普通用户来说不清楚，或者会产生意外的成本，那么类型就不应该可以复制/移动。对于可复制的类型，移动操作严格来说是一种性能优化，并且可能是错误和复杂性的潜在来源，因此除非它们比相应的复制操作显著更有效，否则避免定义它们。如果您的类型提供了复制操作，建议您设计类，使这些操作的默认实现是正确的。请像审查其他代码一样审查任何默认操作的正确性。</p>

<p>为了消除切片的风险，建议通过将构造函数设为受保护、声明析构函数为受保护，或为其提供一个或多个纯虚成员函数，使基类成为抽象类。建议避免从具体类派生。</p>

<h3 id="Structs_vs._Classes">结构体与类</h3>

<p>仅对携带数据的被动对象使用<code>struct</code>；其他一切都应使用<code>class</code>。</p>

<p>在C++中，<code>struct</code>和<code>class</code>关键字的行为几乎相同。我们为每个关键字添加了自己的语义含义，因此您应该为您定义的数据类型使用适当的关键字。</p>

<p><code>struct</code>应用于携带数据的被动对象，并且可以有相关的常量。所有字段必须是公共的。结构体不得有暗示不同字段之间关系的不变量，因为直接用户访问这些字段可能会破坏这些不变量。可以存在构造函数、析构函数和辅助方法；然而，这些方法不得要求或强制执行任何不变量。</p>

<p>如果需要更多功能或不变量，或者结构体具有广泛的可见性并预计会发展，那么<code>class</code>更为合适。如果有疑问，请将其设为<code>class</code>。</p>

<p>为了与STL保持一致，对于无状态类型，如特征、<a href="#Template_metaprogramming">模板元函数</a>和某些函子，可以使用<code>struct</code>而不是<code>class</code>。</p>

<p>请注意，结构体和类中的成员变量有<a href="#Variable_Names">不同的命名规则</a>。</p>

<h3 id="Structs_vs._Tuples">结构体与对和元组</h3>

<p>只要元素可以有有意义的名称，就应优先使用<code>struct</code>而不是对或元组。</p>

<p>虽然使用对和元组可以避免定义自定义类型，在<em>编写</em>代码时可能节省工作，但有意义的字段名称在<em>阅读</em>代码时几乎总是比<code>.first</code>、<code>.second</code>或<code>std::get&lt;X&gt;</code>更清晰。虽然C++14引入了<code>std::get&lt;Type&gt;</code>来按类型而不是索引访问元组元素（当类型唯一时），有时可以部分缓解这个问题，但字段名称通常比类型更清晰、更有信息量。</p>

<p>在通用代码中，如果对或元组的元素没有特定的含义，使用对和元组可能是合适的。它们的使用也可能需要与现有代码或API进行互操作。</p>

<a id="Multiple_Inheritance"></a>
<h3 id="Inheritance">继承</h3>

<p>组合通常比继承更合适。使用继承时，使其为<code>public</code>。</p>

<p class="definition"></p>
<p>当子类从基类继承时，它包含了基类定义的所有数据和操作的定义。“接口继承”是指从一个纯抽象基类（没有状态或定义方法的类）继承；所有其他继承都是“实现继承”。</p>

<p class="pros"></p>
<p>实现继承通过重用基类代码来减少代码大小，因为它专门化了现有类型。由于继承是编译时声明，您和编译器可以理解操作并检测错误。接口继承可以用来以编程方式强制类暴露特定的API。同样，编译器可以检测错误，在这种情况下，当类未定义API的必要方法时。</p>

<p class="cons"></p>
<p>对于实现继承，由于实现子类的代码分布在基类和子类之间，可能更难理解实现。子类不能覆盖非虚函数，因此子类不能更改实现。</p>

<p>多重继承特别成问题，因为它通常会带来更高的性能开销（事实上，从单一继承到多重继承的性能下降往往比从普通到虚调度时的性能下降更大），而且它有导致“菱形”继承模式的风险，这种模式容易引起歧义、混乱和明显的错误。</p>

<p class="decision"></p>

<p>所有继承都应该是<code>public</code>的。如果您想进行私有继承，您应该将基类的实例作为成员包含在内。当您不打算支持将它们用作基类时，可以在类上使用<code>final</code>。</p>

<p>不要过度使用实现继承。组合通常更合适。尽量将继承的使用限制在“is-a”情况下：如果可以合理地说<code>Bar</code>是<code>Foo</code>的一种，那么<code>Bar</code>子类<code>Foo</code>。</p>

<p>将<code>protected</code>的使用限制在那些可能需要从子类访问的成员函数上。请注意，<a href="#Access_Control">数据成员应为<code>private</code></a>。</p>

<p>在声明虚函数或虚析构函数的覆盖时，明确使用<code>override</code>或（较少使用）<code>final</code>之一进行注释。声明覆盖时不要使用<code>virtual</code>。理由：标记为<code>override</code>或<code>final</code>的函数或析构函数如果不是基类虚函数的覆盖，将无法编译，这有助于捕捉常见错误。这些说明符作为文档；如果没有说明符，读者必须检查所讨论类的所有祖先，以确定该函数或析构函数是否为虚函数。</p>

<p>允许多重继承，但强烈不鼓励多重<em>实现</em>继承。</p>
<h3 id="Operator_Overloading">运算符重载</h3>

<p>谨慎使用运算符重载。不要使用用户定义的字面量。</p>

<p class="definition"></p>
<p>C++允许用户代码使用<code>operator</code>关键字
<a href="http://en.cppreference.com/w/cpp/language/operators">声明内置运算符的重载版本</a>，只要其中一个参数是用户定义类型。 <code>operator</code>关键字还允许用户代码使用<code>operator""</code>定义新的字面量类型，并定义类型转换函数，如<code>operator bool()</code>。</p>

<p class="pros"></p>
<p>运算符重载可以通过使用户定义类型的行为与内置类型相同，使代码更加简洁和直观。重载运算符是某些操作的习惯用法名称（例如，<code>==</code>，<code>&lt;</code>，<code>=</code>和<code>&lt;&lt;</code>），遵循这些惯例可以使用户定义类型更易读，并使它们能够与期望这些名称的库进行互操作。</p>

<p>用户定义的字面量是创建用户定义类型对象的非常简洁的表示法。</p>

<p class="cons"></p>
<ul>
  <li>提供正确、一致且不令人惊讶的运算符重载集需要一些谨慎，如果没有做到这一点，可能会导致混淆和错误。</li>

  <li>过度使用运算符可能会导致代码晦涩难懂，特别是如果重载运算符的语义不遵循惯例的话。</li>

  <li>函数重载的危险同样适用于运算符重载，甚至可能更严重。</li>

  <li>运算符重载可能会误导我们的直觉，让我们认为昂贵的操作是廉价的内置操作。</li>

  <li>查找重载运算符的调用位置可能需要一个了解C++语法的搜索工具，而不仅仅是例如grep这样的工具。</li>

  <li>如果重载运算符的参数类型错误，你可能会得到不同的重载而不是编译器错误。例如，<code>foo &lt; bar</code>可能做一件事，而<code>&amp;foo &lt; &amp;bar</code>可能做完全不同的事情。</li>

  <li>某些运算符重载本质上是危险的。重载一元<code>&amp;</code>可能会导致同一段代码在重载声明是否可见的情况下具有不同的含义。重载<code>&amp;&amp;</code>，<code>||</code>和<code>,</code>（逗号）无法匹配内置运算符的求值顺序语义。</li>

  <li>运算符通常在类外部定义，因此存在不同文件引入同一运算符的不同定义的风险。如果这两个定义都被链接到同一个二进制文件中，这将导致未定义行为，表现为微妙的运行时错误。</li>

  <li>用户定义的字面量（UDLs）允许创建新的语法形式，即使是经验丰富的C++程序员也可能不熟悉，例如<code>"Hello World"sv</code>作为<code>std::string_view("Hello World")</code>的简写。现有的表示法更清晰，尽管不太简洁。</li>

  <li>由于它们不能使用命名空间限定，使用UDLs还需要使用using-directives（我们禁止使用）或using-declarations（我们禁止在头文件中使用，除非导入的名称是该头文件暴露的接口的一部分）。鉴于头文件必须避免使用UDL后缀，我们更倾向于避免在头文件和源文件之间对字面量的约定有所不同。
  </li>
</ul>

<p class="decision"></p>
<p>仅当运算符的含义显而易见、不令人惊讶且与相应的内置运算符一致时，才定义重载运算符。例如，使用<code>|</code>作为按位或逻辑或，而不是作为shell风格的管道。</p>

<p>仅在你自己的类型上定义运算符。更具体地说，在操作类型的相同头文件、<code>.cc</code>文件和命名空间中定义它们。这样，运算符在类型所在的任何地方都可用，最大限度地减少了多重定义的风险。如果可能，避免将运算符定义为模板，因为它们必须对任何可能的模板参数满足此规则。如果你定义了一个运算符，也要定义任何相关的、合理的运算符，并确保它们定义一致。</p>

<p>优先将非修改的二元运算符定义为非成员函数。如果二元运算符被定义为类成员，隐式转换将应用于右侧参数，但不应用于左侧参数。如果<code>a + b</code>可以编译但<code>b + a</code>不能编译，这会让你的用户感到困惑。</p>

<p>对于可以比较相等的值的类型<code>T</code>，定义一个非成员<code>operator==</code>并说明何时认为两个类型<code>T</code>的值相等。如果类型<code>T</code>的值<code>t1</code>小于另一个这样的值<code>t2</code>有一个明显的概念，那么你也可以定义<code>operator&lt;=&gt;</code>，它应该与<code>operator==</code>一致。尽量不要重载其他比较和排序运算符。</p>

<p>不要刻意避免定义运算符重载。例如，优先定义<code>==</code>，<code>=</code>和<code>&lt;&lt;</code>，而不是<code>Equals()</code>，<code>CopyFrom()</code>和<code>PrintTo()</code>。相反，不要仅仅因为其他库期望它们而定义运算符重载。例如，如果你的类型没有自然的排序，但你想将其存储在<code>std::set</code>中，使用自定义比较器而不是重载<code>&lt;</code>。</p>

<p>不要重载<code>&amp;&amp;</code>，<code>||</code>，<code>,</code>（逗号）或一元<code>&amp;</code>。不要重载<code>operator""</code>，即，不要引入用户定义的字面量。也不要使用其他人提供的任何此类字面量（包括标准库）。</p>

<p>类型转换运算符在<a href="#Implicit_Conversions">隐式转换</a>部分中介绍。<code>=</code>运算符在<a href="#Copy_Constructors">复制构造函数</a>部分中介绍。重载<code>&lt;&lt;</code>用于流的部分在<a href="#Streams">流</a>部分中介绍。另见<a href="#Function_Overloading">函数重载</a>的规则，这些规则也适用于运算符重载。</p>
<h3 id="Access_Control">访问控制</h3>

<p>除非它们是<a href="#Constant_Names">常量</a>，否则将类的成员数据设为<code>private</code>。这样做简化了对不变量的推理，尽管可能需要一些简单的访问器（通常是<code>const</code>）作为代价，如果有必要的话。</p>

<p>出于技术原因，我们允许在<code>.cc</code>文件中定义的测试夹具类的成员数据在使用<a href="https://github.com/google/googletest">Google Test</a>时设为<code>protected</code>。如果测试夹具类是在它所使用的<code>.cc</code>文件之外定义的，例如在<code>.h</code>文件中，则应将成员数据设为<code>private</code>。</p>

<h3 id="Declaration_Order">声明顺序</h3>

<p>将相似的声明分组在一起，并将<code>public</code>部分放在前面。</p>

<p>类定义通常应以<code>public:</code>部分开始，接着是<code>protected:</code>，然后是<code>private:</code>。省略空的部分。</p>

<p>在每个部分内，优先将相似的声明类型分组在一起，并优先按以下顺序排列：</p>

<ol>
  <li>类型和类型别名（<code>typedef</code>、<code>using</code>、<code>enum</code>、嵌套的结构体和类，以及<code>friend</code>类型）</li>

  <li>（仅限结构体，可选）非<code>static</code>数据成员</li>

  <li>静态常量</li>

  <li>工厂函数</li>

  <li>构造函数和赋值运算符</li>

  <li>析构函数</li>

  <li>所有其他函数（<code>static</code>和非<code>static</code>成员函数，以及<code>friend</code>函数）</li>

  <li>所有其他数据成员（静态和非静态）</li>
</ol>

<p>不要在类定义中内联放置大型方法定义。通常，只有琐碎的或性能关键的，且非常短的方法可以内联定义。有关更多详细信息，请参见<a href="#Inline_Functions">内联函数</a>。</p>

<h2 id="Functions">函数</h2>

<a id="Function_Parameter_Ordering"></a>
<a id="Output_Parameters"></a>
<h3 id="Inputs_and_Outputs">输入和输出</h3>

<p>C++函数的输出自然是通过返回值提供的，有时也通过输出参数（或输入/输出参数）提供。</p>

<p>优先使用返回值而不是输出参数：它们提高了可读性，并且通常提供相同或更好的性能。</p>

<p>优先按值返回，或者如果不行，则按引用返回。除非它可以为空，否则避免返回原始指针。</p>

<p>参数要么是函数的输入，要么是函数的输出，或者两者兼而有之。非可选的输入参数通常应该是值或<code>const</code>引用，而非可选的输出和输入/输出参数通常应该是引用（不能为空）。通常，使用<code>std::optional</code>来表示可选的按值输入，当非可选形式使用引用时，使用<code>const</code>指针。使用非<code>const</code>指针来表示可选的输出和可选的输入/输出参数。</p>

<p>避免定义需要引用参数在调用后仍然有效的函数。在某些情况下，引用参数可以绑定到临时对象，导致生命周期错误。相反，设法消除生命周期要求（例如，通过复制参数），或者通过指针传递保留参数，并记录生命周期和非空要求。</p>

<p>在排序函数参数时，将所有仅输入参数放在任何输出参数之前。特别是，不要仅仅因为它们是新的就将新参数添加到函数的末尾；将新的仅输入参数放在输出参数之前。这不是一个硬性规定。既是输入又是输出的参数使情况变得复杂，而且，正如往常一样，与相关函数的一致性可能需要你稍微调整规则。变参函数也可能需要不寻常的参数排序。</p>

<h3 id="Write_Short_Functions">编写简短的函数</h3>

<p>优先选择小而集中的函数。</p>

<p>我们认识到长函数有时是合适的，因此没有对函数长度设定硬性限制。如果一个函数超过大约40行，请考虑是否可以在不损害程序结构的情况下将其拆分。</p>

<p>即使你的长函数现在运行得很完美，几个月后有人修改它时可能会添加新的行为。这可能会导致难以发现的错误。保持你的函数简短和简单，使其他人更容易阅读和修改你的代码。小函数也更容易测试。</p>

<p>在处理某些代码时，你可能会发现长而复杂的函数。不要害怕修改现有代码：如果处理这样的函数证明是困难的，你发现错误难以调试，或者你想在几个不同的上下文中使用它的某一部分，请考虑将函数分解成更小、更易管理的部分。
<h3 id="Function_Overloading">函数重载</h3>

<p>仅当读者在查看调用点时能够很好地理解正在发生的事情，而无需首先弄清楚调用的是哪个重载版本时，才使用重载函数（包括构造函数）。</p>

<p class="definition"></p>
<p>您可以编写一个接受 <code>const std::string&amp;</code> 的函数，并用另一个接受 <code>const char*</code> 的函数进行重载。然而，在这种情况下，请考虑使用 <code>std::string_view</code>。</p>

<pre>class MyClass {
 public:
  void Analyze(const std::string &amp;text);
  void Analyze(const char *text, size_t textlen);
};
</pre>

<p class="pros"></p>
<p>通过允许同名函数接受不同的参数，重载可以使代码更加直观。它对于模板化代码可能是必要的，并且对于访问者（Visitors）来说可能很方便。</p>
<p>基于 <code>const</code> 或引用限定符的重载可以使实用代码更加可用、更有效，或两者兼而有之。（更多信息请参见 <a href="http://abseil.io/tips/148">TotW 148</a>。）</p>

<p class="cons"></p>
<p>如果函数仅根据参数类型进行重载，读者可能需要理解 C++ 复杂的匹配规则才能明白发生了什么。此外，许多人对继承的语义感到困惑，如果派生类只覆盖了函数的某些变体。</p>

<p class="decision"></p>
<p>当变体之间没有语义差异时，您可以重载函数。这些重载可以在类型、限定符或参数数量上有所不同。然而，阅读此类调用的读者无需知道选择了重载集中的哪个成员，只需知道从该集中调用了<b>某物</b>。如果您可以用头文件中的一个注释来记录重载集中的所有条目，这是一个设计良好的重载集的好迹象。</p>

<h3 id="Default_Arguments">默认参数</h3>

<p>当默认值保证始终相同的情况下，允许在非虚函数上使用默认参数。遵循与<a href="#Function_Overloading">函数重载</a>相同的限制，如果使用默认参数获得的可读性优势不足以抵消下述缺点，则优先使用重载函数。</p>

<p class="pros"></p>
<p>通常您有一个使用默认值的函数，但偶尔您想覆盖默认值。默认参数提供了一种简单的方法来做到这一点，而无需为罕见的情况定义许多函数。与重载函数相比，默认参数具有更清晰的语法，样板代码更少，并且更清楚地区分了“必需”和“可选”参数。</p>

<p class="cons"></p>
<p>默认参数是实现重载函数语义的另一种方式，因此所有<a href="#Function_Overloading">不重载函数的理由</a>都适用。</p>

<p>虚函数调用中参数的默认值由目标对象的静态类型决定，并且没有保证给定函数的所有重写都声明相同的默认值。</p>

<p>默认参数在每次调用点重新评估，这可能会使生成的代码膨胀。读者也可能期望默认值在声明时固定，而不是在每次调用时变化。</p>

<p>在存在默认参数的情况下，函数指针会令人困惑，因为函数签名通常与调用签名不匹配。添加函数重载可以避免这些问题。</p>

<p class="decision"></p>
<p>默认参数在虚函数上被禁止，因为它们无法正常工作，并且在指定的默认值可能根据评估时间不同而不同时也是禁止的。（例如，不要编写 <code>void f(int n = counter++);</code>。）</p>

<p>在其他一些情况下，默认参数可以足够改善其函数声明的可读性，以克服上述缺点，因此它们是被允许的。当有疑问时，请使用重载。</p>
<h3 id="trailing_return">尾随返回类型语法</h3>

<p>仅在使用普通语法（前置返回类型）不切实际或可读性大大降低的情况下使用尾随返回类型。</p>

<p class="definition"></p>
<p>C++允许两种不同的函数声明形式。在较旧的形式中，返回类型出现在函数名前。例如：</p>
<pre>int foo(int x);
</pre>
<p>较新的形式在函数名前使用<code>auto</code>关键字，并在参数列表后使用尾随返回类型。例如，上述声明可以等价地写成：</p>
<pre>auto foo(int x) -&gt; int;
</pre>
<p>尾随返回类型位于函数的作用域内。对于像<code>int</code>这样的简单情况，这没有区别，但对于更复杂的情况，如在类作用域中声明的类型或基于函数参数的类型，则有影响。</p>

<p class="pros"></p>
<p>尾随返回类型是唯一明确指定<a href="#Lambda_expressions">lambda表达式</a>返回类型的方法。在某些情况下，编译器能够推断出lambda的返回类型，但在所有情况下都不是这样。即使编译器可以自动推断，有时明确指定会对读者更清晰。
</p>
<p>有时在函数的参数列表已经出现后指定返回类型会更容易和更可读。这在返回类型依赖于模板参数时尤其正确。例如：</p>
  <pre>    template &lt;typename T, typename U&gt;
    auto add(T t, U u) -&gt; decltype(t + u);
  </pre>
  与
  <pre>    template &lt;typename T, typename U&gt;
    decltype(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u);
  </pre>

<p class="cons"></p>
<p>尾随返回类型语法相对较新，并且在类似C++的语言如C和Java中没有类似的语法，因此一些读者可能觉得它不熟悉。</p>
<p>现有代码库中有大量的函数声明不会被更改为使用新语法，因此现实的选择是仅使用旧语法或使用两种语法的混合。使用单一版本对风格的一致性更好。</p>

<p class="decision"></p>
<p>在大多数情况下，继续使用旧式的函数声明，其中返回类型位于函数名前。仅在需要的情况下（如lambda）或通过将类型放在函数的参数列表之后，可以以更可读的方式编写类型时，才使用新的尾随返回类型形式。后一种情况应该是罕见的；这主要是在相当复杂的模板代码中出现的问题，而这在<a href="#Template_metaprogramming">大多数情况下是不鼓励的</a>。</p>


<h2 id="Google-Specific_Magic">Google特定的魔法</h2>

<div>
<p>我们使用各种技巧和工具来使C++代码更加健壮，并且我们使用C++的方式可能与您在其他地方看到的不同。</p>
</div>
<h3 id="Ownership_and_Smart_Pointers">所有权和智能指针</h3>

<p>对于动态分配的对象，优先选择单一、固定的所有者。优先使用智能指针来转移所有权。</p>

<p class="definition"></p>
<p>“所有权”是管理动态分配内存（和其他资源）的一种簿记技术。动态分配对象的所有者是一个对象或函数，负责确保在不再需要时删除它。所有权有时可以共享，在这种情况下，通常由最后一个所有者负责删除它。即使所有权未共享，它也可以从一段代码转移到另一段代码。</p>

<p>“智能”指针是像指针一样操作的类，例如，通过重载<code>*</code>和<code>-&gt;</code>操作符。某些智能指针类型可以用于自动化所有权簿记，以确保这些责任得到履行。
<a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">
<code>std::unique_ptr</code></a>是一种智能指针类型，表示对动态分配对象的独占所有权；当<code>std::unique_ptr</code>超出作用域时，对象会被删除。它不能被复制，但可以被<em>移动</em>以表示所有权转移。
<a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">
<code>std::shared_ptr</code></a>是一种智能指针类型，表示对动态分配对象的共享所有权。<code>std::shared_ptr</code>可以被复制；对象的所有权在所有副本之间共享，当最后一个<code>std::shared_ptr</code>被销毁时，对象会被删除。</p>

<p class="pros"></p>
<ul>
  <li>没有某种所有权逻辑，几乎不可能管理动态分配的内存。</li>

  <li>转移对象的所有权可能比复制它更便宜（如果复制它是可能的话）。</li>

  <li>转移所有权可能比“借用”指针或引用更简单，因为它减少了两个用户之间协调对象生命周期的需要。</li>

  <li>智能指针可以通过使所有权逻辑明确、自文档化和无歧义来提高可读性。</li>

  <li>智能指针可以消除手动所有权簿记，简化代码并排除一大类错误。</li>

  <li>对于<code>const</code>对象，共享所有权可以是深拷贝的一个简单且高效的替代方案。</li>
</ul>

<p class="cons"></p>
<ul>
  <li>所有权必须通过指针（无论是智能的还是普通的）来表示和转移。指针语义比值语义更复杂，尤其是在API中：你不仅要担心所有权，还要担心别名、生命周期和可变性等其他问题。</li>

  <li>值语义的性能成本往往被高估，因此所有权转移的性能优势可能无法证明可读性和复杂性成本是合理的。</li>

  <li>转移所有权的API迫使其客户端采用单一的内存管理模型。</li>

  <li>使用智能指针的代码在资源释放发生的位置上不太明确。</li>

  <li><code>std::unique_ptr</code>使用移动语义来表达所有权转移，这相对较新，可能会使一些程序员感到困惑。</li>

  <li>共享所有权可能是对仔细的所有权设计的诱人替代方案，模糊了系统的设计。</li>

  <li>共享所有权需要在运行时进行显式的簿记，这可能成本高昂。</li>

  <li>在某些情况下（例如，循环引用），具有共享所有权的对象可能永远不会被删除。</li>

  <li>智能指针并不是普通指针的完美替代品。</li>
</ul>

<p class="decision"></p>
<p>如果需要动态分配，优先保持所有权与分配它的代码在一起。如果其他代码需要访问该对象，考虑传递其副本，或传递指针或引用而不转移所有权。优先使用<code>std::unique_ptr</code>来明确所有权转移。例如：</p>

<pre>std::unique_ptr&lt;Foo&gt; FooFactory();
void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);
</pre>

<p>除非有非常充分的理由，否则不要设计你的代码使用共享所有权。一个这样的理由是避免昂贵的复制操作，但你应该仅在性能优势显著且底层对象是不可变的情况下（即，<code>std::shared_ptr&lt;const Foo&gt;</code>）才这样做。如果你确实使用共享所有权，优先使用<code>std::shared_ptr</code>。</p>

<p>永远不要使用<code>std::auto_ptr</code>。相反，使用<code>std::unique_ptr</code>。</p>

<h3 id="cpplint">cpplint</h3>

<p>使用<code>cpplint.py</code>来检测样式错误。</p>

<p><code>cpplint.py</code>是一个读取源文件并识别许多样式错误的工具。它并非完美，既有误报也有漏报，但它仍然是一个有价值的工具。</p>

<div>
<p>一些项目有关于如何从他们的项目工具中运行<code>cpplint.py</code>的说明。如果你贡献的项目没有，你可以单独下载
<a href="https://raw.githubusercontent.com/cpplint/cpplint/HEAD/cpplint.py">
<code>cpplint.py</code></a>。</p>
</div>

<h2 id="Other_C++_Features">其他C++特性</h2>
<h3 id="Rvalue_references">右值引用</h3>

<p>仅在下列特定特殊情况下使用右值引用。</p>

<p class="definition"></p>
<p> 右值引用
是一种只能绑定到临时对象的引用类型。其语法与传统引用语法相似。例如，<code>void f(std::string&amp;&amp;
s);</code> 声明了一个函数，其参数是对 <code>std::string</code> 的右值引用。</p>

<p id="Forwarding_references"> 当标记 '&amp;&amp;' 应用于函数参数中的未限定模板参数时，会应用特殊的模板参数推导规则。这种引用被称为转发引用。</p>

<p class="pros"></p>
<ul>
  <li>定义移动构造函数（接受类类型的右值引用的构造函数）使得可以移动值而不是复制它。例如，如果 <code>v1</code> 是一个 <code>std::vector&lt;std::string&gt;</code>，那么 <code>auto v2(std::move(v1))</code> 可能只会进行一些简单的指针操作，而不是复制大量数据。在许多情况下，这可以带来显著的性能提升。</li>

  <li>右值引用使得可以实现可移动但不可复制的类型，这对于没有合理复制定义但仍希望将它们作为函数参数传递、放入容器等的类型很有用。</li>

  <li><code>std::move</code> 是有效使用某些标准库类型（如 <code>std::unique_ptr</code>）的必要条件。</li>

  <li><a href="#Forwarding_references">转发引用</a> 使用右值引用标记，使得可以编写一个通用的函数包装器，该包装器将其参数转发给另一个函数，无论其参数是否为临时对象和/或 const。这被称为“完美转发”。</li>
</ul>

<p class="cons"></p>
<ul>
  <li>右值引用尚未被广泛理解。像引用折叠和转发引用的特殊推导规则这样的规则有些晦涩难懂。</li>

  <li>右值引用经常被误用。在函数调用后参数预期具有有效指定状态的签名中，或者在没有执行移动操作的情况下使用右值引用是违反直觉的。</li>
</ul>

<p class="decision"></p>
<p>除非符合以下情况，否则不要使用右值引用（或对方法应用 <code>&amp;&amp;</code> 限定符）：</p>
<ul>
  <li>您可以使用它们来定义移动构造函数和移动赋值运算符（如 <a href="#Copyable_Movable_Types">可复制和可移动类型</a> 中所述）。</li>

  <li>您可以使用它们来定义 <code>&amp;&amp;</code> 限定方法，这些方法逻辑上“消耗” <code>*this</code>，使其处于不可用或空状态。请注意，这仅适用于方法限定符（位于函数签名结束括号之后）；如果您想“消耗”普通函数参数，建议按值传递。</li>

  <li>您可以结合 <code><a href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a></code> 使用转发引用，以支持完美转发。</li>

  <li>您可以使用它们来定义一对重载函数，例如一个接受 <code>Foo&amp;&amp;</code>，另一个接受 <code>const Foo&amp;</code>。通常，首选的解决方案是按值传递，但有时一对重载函数可以带来更好的性能，例如如果函数有时不消耗输入。像往常一样：如果您为了性能而编写更复杂的代码，请确保您有证据证明它确实有帮助。</li>
</ul>

<h3 id="Friends">友元</h3>

<p>我们允许合理使用 <code>friend</code> 类和函数。</p>

<p>友元通常应在同一文件中定义，以便读者不必查看另一个文件即可找到类的私有成员的使用情况。一种常见的 <code>friend</code> 使用情况是让 <code>FooBuilder</code> 类成为 <code>Foo</code> 的友元，以便它可以正确构建 <code>Foo</code> 的内部状态，而不对外暴露此状态。在某些情况下，让单元测试类成为其测试类的友元可能是有用的。</p>

<p>友元扩展了类的封装边界，但并未打破它。在某些情况下，这比将成员设为 <code>public</code> 更好，因为您只想给另一个类访问权限。然而，大多数类应仅通过其公共成员与其他类交互。</p>
<h3 id="Exceptions">异常</h3>

<p>我们不使用C++异常。</p>

<p class="pros"></p>
<ul>
  <li>异常允许应用程序的高层决定如何处理深层嵌套函数中“不可能发生”的失败，而无需使用错误代码的模糊和容易出错的记录方式。</li>

  <div>
  <li>大多数其他现代语言使用异常。在C++中使用它们将使其与Python、Java以及其他人熟悉的C++更加一致。</li>
  </div>

  <li>一些第三方C++库使用异常，内部关闭它们会使与这些库的集成变得更加困难。</li>

  <li>异常是构造函数失败的唯一方式。我们可以通过工厂函数或<code>Init()</code>方法来模拟这一点，但这分别需要堆分配或新的“无效”状态。</li>

  <li>异常在测试框架中非常有用。</li>
</ul>

<p class="cons"></p>
<ul>
  <li>当你向现有函数添加<code>throw</code>语句时，你必须检查它的所有传递调用者。它们必须至少提供基本的异常安全保证，或者它们永远不会捕获异常，并且对程序因此终止感到满意。例如，如果<code>f()</code>调用<code>g()</code>调用<code>h()</code>，并且<code>h</code>抛出一个<code>f</code>捕获的异常，<code>g</code>必须小心，否则它可能无法正确清理。</li>

  <li>更普遍地说，异常使得通过查看代码来评估程序的控制流变得困难：函数可能在你意想不到的地方返回。这会导致维护和调试困难。你可以通过一些关于如何以及在哪里可以使用异常的规则来最小化这种成本，但这需要开发者了解和理解更多内容。</li>

  <li>异常安全性需要RAII和不同的编码实践。需要大量的支持机制来使编写正确的异常安全代码变得容易。此外，为了避免要求读者理解整个调用图，异常安全代码必须将写入持久状态的逻辑隔离到“提交”阶段。这将带来好处和成本（可能在你被迫模糊代码以隔离提交的地方）。允许使用异常将迫使我们始终支付这些成本，即使它们不值得时也是如此。</li>

  <li>启用异常会向每个生成的二进制文件添加数据，增加编译时间（可能略微增加）并可能增加地址空间压力。</li>

  <li>异常的可用性可能会鼓励开发者在不适当的时候抛出它们，或者在不安全的情况下从中恢复。例如，无效的用户输入不应该导致抛出异常。我们需要使风格指南更长以记录这些限制！</li>
</ul>

<p class="decision"></p>
<p>从表面上看，使用异常的好处超过了成本，特别是在新项目中。然而，对于现有代码，引入异常对所有依赖代码都有影响。如果异常可以传播到新项目之外，那么将新项目集成到现有的无异常代码中也会变得有问题。因为Google的大多数现有C++代码没有准备好处理异常，所以采用生成异常的新代码相对困难。</p>

<p>鉴于Google的现有代码不容忍异常，使用异常的成本比在新项目中的成本略高。转换过程将是缓慢且容易出错的。我们认为，异常的可用替代方案，如错误代码和断言，不会带来显著的负担。</p>

<p>我们建议不使用异常的建议不是基于哲学或道德理由，而是基于实际理由。因为我们希望在Google使用我们的开源项目，如果这些项目使用异常会很难做到，所以我们也需要建议在Google的开源项目中避免使用异常。如果我们必须从头开始，一切可能会有所不同。</p>

<p>此禁令也适用于与异常处理相关的功能，如<code>std::exception_ptr</code>和<code>std::nested_exception</code>。</p>

<p>对于Windows代码，此规则有一个<a href="#Windows_Code">例外</a>（无意双关）。</p>
<h3 id="noexcept"><code>noexcept</code></h3>

<p>在有用且正确的情况下指定<code>noexcept</code>。</p>

<p class="definition"></p>
<p><code>noexcept</code>说明符用于指定一个函数是否会抛出异常。如果一个异常从标记为<code>noexcept</code>的函数中逃逸，程序将通过<code>std::terminate</code>崩溃。</p>

<p><code>noexcept</code>操作符执行编译时检查，如果一个表达式被声明为不抛出任何异常，则返回true。</p>

<p class="pros"></p>
<ul>
  <li>将移动构造函数指定为<code>noexcept</code>在某些情况下可以提高性能，例如，如果T的移动构造函数是<code>noexcept</code>，则<code>std::vector&lt;T&gt;::resize()</code>会移动而不是复制对象。</li>

  <li>在启用异常的环境中，在函数上指定<code>noexcept</code>可以触发编译器优化，例如，如果编译器知道由于<code>noexcept</code>说明符不会抛出异常，它就不必生成额外的堆栈展开代码。</li>
</ul>

<p class="cons"></p>
<ul>
  <li>在遵循本指南的项目中，如果禁用了异常，确保<code>noexcept</code>说明符的正确性是困难的，甚至难以定义正确性的含义。</li>

  <li>撤销<code>noexcept</code>是困难的，甚至是不可能的，因为它消除了调用者可能依赖的保证，而这些保证很难检测到。</li>
</ul>

<p class="decision"></p>
<p>如果<code>noexcept</code>对性能有用，并且准确反映了您的函数的预期语义，即如果函数体内以某种方式抛出异常，则表示致命错误，您可以使用<code>noexcept</code>。您可以假设移动构造函数上的<code>noexcept</code>具有有意义的性能优势。如果您认为在其他函数上指定<code>noexcept</code>有显著的性能优势，请与您的项目负责人讨论。</p>

<p>如果完全禁用了异常（即，大多数Google C++环境），请优先使用无条件的<code>noexcept</code>。否则，使用带有简单条件的条件<code>noexcept</code>说明符，这些条件仅在函数可能抛出的少数情况下评估为false。测试可能包括对涉及操作是否可能抛出的类型特征检查（例如，对于移动构造对象的<code>std::is_nothrow_move_constructible</code>），或者对分配是否可能抛出的检查（例如，对于标准默认分配的<code>absl::default_allocator_is_nothrow</code>）。请注意，在许多情况下，异常的唯一可能原因是分配失败（我们认为移动构造函数不应抛出异常，除非是由于分配失败），并且在许多应用程序中，将内存耗尽视为致命错误而不是程序应尝试从中恢复的异常情况是合适的。对于其他潜在的失败，您应该优先考虑接口的简洁性，而不是支持所有可能的异常抛出场景：例如，与其编写一个复杂的<code>noexcept</code>子句，依赖于哈希函数是否可以抛出，不如简单地记录您的组件不支持抛出哈希函数，并使其无条件地<code>noexcept</code>。</p>
<h3 id="Run-Time_Type_Information__RTTI_">运行时类型信息 (RTTI)</h3>

<p>避免使用运行时类型信息 (RTTI)。</p>

<p class="definition"></p>
<p> RTTI 允许程序员在运行时查询对象的 C++ 类。这通过使用 <code>typeid</code> 或 <code>dynamic_cast</code> 来实现。</p>

<p class="pros"></p>
<p>RTTI 的标准替代方案（如下所述）需要对相关类层次结构进行修改或重新设计。有时这种修改不可行或不受欢迎，特别是在广泛使用或成熟的代码中。</p>

<p>RTTI 在某些单元测试中可能很有用。例如，它在测试工厂类时很有用，测试需要验证新创建的对象是否具有预期的动态类型。它在管理对象与其模拟对象之间的关系时也很有用。</p>

<p>RTTI 在考虑多个抽象对象时很有用。考虑</p>

<pre>bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast&lt;Derived*&gt;(other);
  if (that == nullptr)
    return false;
  ...
}
</pre>

<p class="cons"></p>
<p>在运行时查询对象的类型通常意味着设计问题。需要在运行时知道对象的类型通常表明类层次结构的设计存在缺陷。</p>

<p>不加约束地使用 RTTI 会使代码难以维护。它可能导致基于类型的决策树或 switch 语句散布在代码中，所有这些在进行进一步更改时都必须检查。</p>

<p class="decision"></p>
<p>RTTI 有合法的用途，但容易被滥用，因此在使用时必须小心。你可以在单元测试中自由使用它，但在其他代码中尽量避免使用。特别是在编写新代码时要三思。如果你发现自己需要编写根据对象的类别而不同行为的代码，请考虑以下替代方案之一来查询类型：</p>

<ul>
  <li>虚拟方法是根据特定子类类型执行不同代码路径的首选方式。这将工作放在对象本身内部。</li>

  <li>如果工作属于对象外部，而是在一些处理代码中，请考虑使用双重调度解决方案，例如访问者设计模式。这允许对象外部的设施使用内置类型系统来确定类的类型。</li>
</ul>

<p>当程序的逻辑保证基类的一个给定实例实际上是特定派生类的实例时，可以在该对象上自由使用 <code>dynamic_cast</code>。通常在这种情况下，可以使用 <code>static_cast</code> 作为替代方案。</p>

<p>基于类型的决策树强烈表明你的代码走错了方向。</p>

<pre class="badcode">if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...
</pre>

<p>这样的代码通常在类层次结构中添加新的子类时会失效。此外，当子类的属性发生变化时，很难找到并修改所有受影响的代码段。</p>

<p>不要手动实现类似 RTTI 的解决方案。反对 RTTI 的论点同样适用于像带有类型标签的类层次结构这样的解决方案。此外，解决方案掩盖了你的真实意图。</p>

<h3 id="Casting">类型转换</h3>

<p>使用 C++ 风格的类型转换，如 <code>static_cast&lt;float&gt;(double_value)</code>，或使用大括号初始化来转换算术类型，如 <code>int64_t y = int64_t{1} &lt;&lt; 42</code>。除非转换为 <code>void</code>，否则不要使用像 <code>(int)x</code> 这样的转换格式。只有当 <code>T</code> 是类类型时，你才可以使用像 <code>T(x)</code> 这样的转换格式。</p>

<p class="definition"></p>
<p> C++ 引入了与 C 不同的类型转换系统，该系统区分了类型转换操作的类型。</p>

<p class="pros"></p>
<p>C 风格转换的问题在于操作的模糊性；有时你在进行 <em>转换</em>（例如，<code>(int)3.5</code>），有时你在进行 <em>类型转换</em>（例如，<code>(int)"hello"</code>）。大括号初始化和 C++ 风格的转换通常可以帮助避免这种模糊性。此外，C++ 风格的转换在搜索时更容易被发现。</p>

<p class="cons"></p>
<p>C++ 风格的转换语法冗长且繁琐。</p>

<p class="decision"></p>
<p>一般来说，不要使用 C 风格的转换。相反，当需要显式类型转换时，使用这些 C++ 风格的转换。
</p>

<ul>
  <li>使用大括号初始化来转换算术类型（例如，<code>int64_t{x}</code>）。这是最安全的方法，因为如果转换可能导致信息丢失，代码将无法编译。语法也简洁。</li>

  <li>使用 <code>absl::implicit_cast</code> 安全地向上转换类型层次结构，例如，将 <code>Foo*</code> 转换为 <code>SuperclassOfFoo*</code> 或将 <code>Foo*</code> 转换为 <code>const Foo*</code>。C++ 通常会自动执行此操作，但在某些情况下需要显式向上转换，例如使用 <code>?:</code> 运算符时。</li>

  <li>使用 <code>static_cast</code> 作为需要进行值转换的 C 风格转换的等价物，当你需要显式地将指针从类向上转换到其超类，或者当你需要显式地将指针从超类向下转换到子类时。在最后一种情况下，你必须确保你的对象实际上是子类的实例。</li>

  <li>使用 <code>const_cast</code> 来移除 <code>const</code> 限定符（参见 <a href="#Use_of_const">const</a>）。</li>

  <li>使用 <code>reinterpret_cast</code> 来进行指针类型与整数和其他指针类型（包括 <code>void*</code>）之间的不安全转换。仅在你知道自己在做什么并且理解别名问题时使用此操作。另外，考虑解引用指针（无需转换）并使用 <code>std::bit_cast</code> 来转换生成的值。</li>

  <li>使用 <code>std::bit_cast</code> 来使用相同大小的不同类型解释值的原始位（类型转换），例如，将 <code>double</code> 的位解释为 <code>int64_t</code>。</li>
</ul>

<p>有关 <code>dynamic_cast</code> 的使用指南，请参见 <a href="#Run-Time_Type_Information__RTTI_">RTTI 部分</a>。</p>
<h3 id="Streams">流</h3>

<p>在适当的情况下使用流，并坚持使用“简单”的用法。仅为表示值的类型重载<code>&lt;&lt;</code>进行流操作，并且只写入用户可见的值，而不写入任何实现细节。</p>

<p class="definition"></p>
<p>流是C++中的标准I/O抽象，如标准头文件<code>&lt;iostream&gt;</code>所示。它们在Google代码中广泛使用，主要用于调试日志和测试诊断。</p>

<p class="pros"></p>
<p><code>&lt;&lt;</code>和<code>&gt;&gt;</code>流操作符提供了一个用于格式化I/O的API，这个API易于学习、可移植、可重用且可扩展。相比之下，<code>printf</code>甚至不支持<code>std::string</code>，更不用说用户定义的类型了，并且很难以可移植的方式使用。<code>printf</code>还要求你在众多略有不同的版本中进行选择，并导航数十个转换说明符。</p>

<p>流通过<code>std::cin</code>、<code>std::cout</code>、<code>std::cerr</code>和<code>std::clog</code>为控制台I/O提供了第一级支持。C API也能做到这一点，但由于需要手动缓冲输入而受到限制。</p>

<p class="cons"></p>
<ul>
<li>流格式可以通过改变流的状态来配置。这种改变是持久的，因此除非你每次其他代码可能触及它时都特意将其恢复到已知状态，否则你的代码行为可能会受到流的整个先前历史的影响。用户代码不仅可以修改内置状态，还可以通过注册系统添加新的状态变量和行为。</li>

<li>由于上述问题、代码和数据在流代码中的混合方式以及运算符重载的使用（可能会选择你意想不到的重载），很难精确控制流输出。</li>

<li>通过<code>&lt;&lt;</code>操作符链构建输出的做法会干扰国际化，因为它将词序固定在代码中，而流对本地化的支持是<a href="http://www.boost.org/doc/libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why">有缺陷的</a>。</li>

<li>流API微妙且复杂，因此程序员必须积累经验才能有效使用它。</li>

<li>解析<code>&lt;&lt;</code>的众多重载对编译器来说极其昂贵。在大型代码库中广泛使用时，它可能消耗多达20%的解析和语义分析时间。</li>
</ul>

<p class="decision"></p>
<p>仅在流是最佳工具时使用流。这通常是在I/O是临时性的、本地的、人类可读的，并且针对其他开发人员而不是最终用户的情况下。与你周围的代码以及整个代码库保持一致；如果有解决你问题的既定工具，请使用该工具。特别是，日志库通常是诊断输出的更好选择，而不是<code>std::cerr</code>或<code>std::clog</code>，而<code>absl/strings</code>中的库或等效库通常是<code>std::stringstream</code>的更好选择。</p>

<p>避免使用流来处理面向外部用户或处理不受信任数据的I/O。相反，找到并使用适当的模板库来处理国际化、本地化和安全加固等问题。</p>

<p>如果你确实使用流，避免使用流API的有状态部分（错误状态除外），例如<code>imbue()</code>、<code>xalloc()</code>和<code>register_callback()</code>。使用显式的格式化函数（如<code>absl::StreamFormat()</code>）而不是流操纵器或格式化标志来控制格式化细节，如数字基数、精度或填充。</p>

<p>仅当你的类型表示一个值时，才将<code>&lt;&lt;</code>重载为流操作符，并且<code>&lt;&lt;</code>写入该值的人类可读的字符串表示。避免在<code>&lt;&lt;</code>的输出中暴露实现细节；如果你需要打印对象内部用于调试，请使用命名函数（最常见的约定是名为<code>DebugString()</code>的方法）。</p>

<h3 id="Preincrement_and_Predecrement">前增量和前减量</h3>

<p>除非你需要后缀语义，否则使用增量和减量操作符的前缀形式（<code>++i</code>）。</p>

<p class="definition"></p>
<p>当一个变量被增量（<code>++i</code>或<code>i++</code>）或减量（<code>--i</code>或<code>i--</code>）且表达式值未被使用时，必须决定是使用前增量（减量）还是后增量（减量）。</p>

<p class="pros"></p>

<p>后缀增量/减量表达式评估为修改前的值。这可能导致代码更紧凑但更难阅读。前缀形式通常更易读，从不效率更低，并且可能更有效，因为它不需要复制操作前的值。</p>

<p class="cons"></p>
<p>在C语言中，形成了即使表达式值未被使用也使用后增量的传统，尤其是在<code>for</code>循环中。</p>

<p class="decision"></p>
<p>使用前增量/减量，除非代码明确需要后缀增量/减量表达式的结果。</p>
<h3 id="Use_of_const">const 的使用</h3>

<p>在 API 中，只要合理就使用 <code>const</code>。
<code>constexpr</code> 在某些情况下是更好的选择。</p>

<p class="definition"></p>
<p>声明的变量和参数可以使用关键字 <code>const</code> 前置，以表明变量不会被更改（例如，<code>const int foo</code>）。类的函数可以使用 <code>const</code> 限定符来表明该函数不会更改类成员变量的状态（例如，<code>class Foo { int Bar(char c) const; };</code>）。</p>

<p class="pros"></p>
<p>使人们更容易理解变量的使用方式。允许编译器进行更好的类型检查，并且理论上可以生成更好的代码。帮助人们确信程序的正确性，因为他们知道他们调用的函数在修改变量的方式上是有限的。帮助人们了解在多线程程序中哪些函数在没有锁的情况下是安全的。</p>

<p class="cons"></p>
<p><code>const</code> 是具有传染性的：如果将一个 <code>const</code> 变量传递给一个函数，该函数的原型中必须有 <code>const</code>（否则该变量需要使用 <code>const_cast</code>）。这在调用库函数时可能特别成问题。</p>

<p class="decision"></p>
<p>我们强烈建议在 API 中（即在函数参数、方法和非局部变量上）只要有意义和准确的地方就使用 <code>const</code>。这提供了关于操作可以修改哪些对象的一致且主要由编译器验证的文档。拥有一种一致且可靠的方法来区分读写对于编写线程安全的代码至关重要，并且在许多其他情况下也有用。特别是：</p>

<ul>
  <li>如果一个函数保证它不会修改通过引用或指针传递的参数，那么相应的函数参数应该分别是引用到常量（<code>const T&amp;</code>）或指针到常量（<code>const T*</code>）。</li>

  <li>对于按值传递的函数参数，<code>const</code> 对调用者没有影响，因此不建议在函数声明中使用。参见


  <a href="https://abseil.io/tips/109">TotW #109</a>。


  </li><li>声明方法为 <code>const</code>，除非它们改变对象的逻辑状态（或允许用户修改该状态，例如通过返回非 <code>const</code> 引用，但这种情况很少见），或者它们不能安全地并发调用。</li>
</ul>

<p>在局部变量上使用 <code>const</code> 既不鼓励也不反对。</p>

<p>一个类的所有 <code>const</code> 操作都应该可以安全地与彼此并发调用。如果这不可行，则该类必须明确标注为“线程不安全”。</p>


<h4>const 的位置</h4>

<p>有些人喜欢使用 <code>int const *foo</code> 而不是 <code>const int* foo</code>。他们认为这样更易读，因为它更一致：它保持了 <code>const</code> 总是跟随它所描述的对象的规则。然而，这种一致性论点在很少有深层嵌套指针表达式的代码库中不适用，因为大多数 <code>const</code> 表达式只有一个 <code>const</code>，并且它适用于底层值。在这种情况下，没有一致性需要维护。将 <code>const</code> 放在前面可以说更易读，因为它遵循英语中将“形容词”（<code>const</code>）放在“名词”（<code>int</code>）之前的做法。</p>

<p>尽管如此，虽然我们鼓励将 <code>const</code> 放在前面，但我们不强制要求这样做。但要与周围的代码保持一致！</p>

<h3 id="Use_of_constexpr">constexpr、constinit 和 consteval 的使用</h3>

<p>使用 <code>constexpr</code> 来定义真正的常量或确保常量初始化。
使用 <code>constinit</code> 来确保非常量变量的常量初始化。
</p>

<p class="definition"></p>
<p>一些变量可以声明为 <code>constexpr</code> 以表明它们是真正的常量，即在编译/链接时固定。一些函数和构造函数可以声明为 <code>constexpr</code>，这使它们能够用于定义 <code>constexpr</code> 变量。函数可以声明为 <code>consteval</code> 以限制它们在编译时使用。</p>

<p class="pros"></p>
<p>使用 <code>constexpr</code> 可以定义带有浮点表达式而不是仅字面值的常量；定义用户定义类型的常量；以及使用函数调用定义常量。</p>

<p class="cons"></p>
<p>过早地将某物标记为 <code>constexpr</code> 可能会在以后需要降级时造成迁移问题。当前对 <code>constexpr</code> 函数和构造函数中允许的内容的限制可能会在这些定义中引发晦涩的解决方案。</p>

<p class="decision"></p>
<p><code>constexpr</code> 定义使接口的常量部分的规范更加健壮。使用 <code>constexpr</code> 来指定真正的常量以及支持其定义的函数。可以使用 <code>consteval</code> 用于必须在运行时不被调用的代码。
避免为了使函数定义能够与 <code>constexpr</code> 一起使用而复杂化函数定义。不要使用 <code>constexpr</code> 或 <code>consteval</code> 来强制内联。</p>
<h3 id="Integer_Types">整数类型</h3>

<p>在C++内置的整数类型中，唯一使用的类型是
<code>int</code>。如果程序需要不同大小的整数类型，请使用
<code>&lt;cstdint&gt;</code>中的精确宽度整数类型，例如
<code>int16_t</code>。如果你的值可能大于或等于2^31，
请使用64位类型，如 <code>int64_t</code>。
请记住，即使你的值永远不会对 <code>int</code> 来说太大，
它也可能在中间计算中需要更大的类型。遇到疑问时，选择更大的类型。</p>

<p class="definition"></p>
<p>C++ 没有为像 <code>int</code> 这样的整数类型指定确切的大小。
在现代架构上的常见大小是 <code>short</code> 为16位，<code>int</code> 为32位，
<code>long</code> 为32或64位，<code>long long</code> 为64位，
但不同的平台会做出不同的选择，特别是对于 <code>long</code>。</p>

<p class="pros"></p>
<p>声明的一致性。</p>

<p class="cons"></p>
<p>C++ 中整数类型的大小可能因编译器和架构而异。</p>

<p class="decision"></p>

<p>
标准库头文件 <code>&lt;cstdint&gt;</code> 定义了像 <code>int16_t</code>、<code>uint32_t</code>、
<code>int64_t</code> 等类型。你应该始终优先使用这些类型，而不是 <code>short</code>、<code>unsigned
long long</code> 等类型，当你需要保证整数的大小时。建议省略这些类型的 <code>std::</code>
前缀，因为额外的5个字符不值得增加混乱。在内置整数类型中，只应使用
<code>int</code>。在适当的情况下，你可以使用标准类型别名，如
<code>size_t</code> 和 <code>ptrdiff_t</code>。</p>

<p>我们经常使用 <code>int</code>，用于我们知道不会太大的整数，例如循环计数器。
对于这些情况，请使用普通的 <code>int</code>。你应该假设 <code>int</code> 至少有32位，
但不要假设它超过32位。如果你需要64位整数类型，请使用 <code>int64_t</code> 或 <code>uint64_t</code>。

</p><p>对于我们知道可能“很大”的整数，
使用
<code>int64_t</code>。
</p>

<p>你不应该使用无符号整数类型，如
<code>uint32_t</code>，除非有有效的理由，例如表示位模式而不是数字，
或者你需要定义的模2^N溢出。特别是，不要使用无符号类型来说明一个数字永远不会为负。
相反，使用断言来实现这一点。</p>

<p>如果你的代码是一个返回大小的容器，请确保使用能够适应容器任何可能用法的类型。
遇到疑问时，使用较大的类型而不是较小的类型。</p>

<p>在转换整数类型时要小心。整数转换和提升可能会导致未定义的行为，导致安全漏洞和其他问题。</p>

<h4>关于无符号整数</h4>

<p>无符号整数适合表示位字段和模运算。由于历史原因，C++标准还使用无符号整数来表示容器的大小 - 标准委员会的许多成员认为这是个错误，但目前实际上无法修复。无符号算术不模拟简单整数的行为，而是由标准定义为模拟模运算（在溢出/下溢时环绕），这意味着编译器无法诊断出一大类错误。在其他情况下，定义的行为阻碍了优化。</p>

<p>话虽如此，混合整数类型的符号性同样会导致同样大的一类问题。我们能提供的最佳建议是：尽量使用迭代器和容器而不是指针和大小，尽量不混合符号性，尽量避免使用无符号类型（除了表示位字段或模运算外）。不要仅仅为了断言一个变量为非负数而使用无符号类型。</p>

<h3 id="Floating-Point_Types">浮点类型</h3>

<p>在C++内置的浮点类型中，唯一使用的类型是
<code>float</code> 和
<code>double</code>。你可以假设这些类型分别表示IEEE-754的binary32和binary64。</p>

<p>不要使用 <code>long double</code>，因为它会产生非可移植的结果。</p>

<a id="64-bit_Portability"></a>
<h3 id="Architecture_Portability">架构可移植性</h3>

<p>编写架构可移植的代码。不要依赖特定于单个处理器的CPU功能。</p>

<ul>
  <li>在打印值时，使用类型安全的数字格式化库，如
  <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/str_cat.h"><code>absl::StrCat</code></a>,
  <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/substitute.h"><code>absl::Substitute</code></a>,
  <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/str_format.h"><code>absl::StrFormat</code></a>,
  或 <a href="#Streams"><code>std::ostream</code></a>，而不是
  <code>printf</code> 家族的函数。</li>

  <li>在将结构化数据移入或移出你的进程时，使用序列化库（如
  <a href="https://protobuf.dev/">Protocol
  Buffers</a>）进行编码，而不是在内存中复制表示。
  </li>

  <li>如果需要将内存地址作为整数处理，请将它们存储在
  <code>uintptr_t</code> 中，而不是 <code>uint32_t</code> 或
  <code>uint64_t</code> 中。</li>

  <li>
  如有需要，使用 <a href="#Casting">大括号初始化</a> 来创建
  64位常量。例如：
<pre>int64_t my_value{0x123456789};
uint64_t my_mask{uint64_t{3} &lt;&lt; 48};
</pre>
  </li>

  <li>使用可移植的 <a href="#Floating-Point_Types">浮点类型</a>；
  避免使用 <code>long double</code>。</li>

  <li>使用可移植的 <a href="#Integer_Types">整数类型</a>；
  避免使用 <code>short</code>、<code>long</code> 和 <code>long long</code>。</li>
</ul>
<h3 id="Preprocessor_Macros">预处理器宏</h3>

<p>避免定义宏，特别是在头文件中；优先使用内联函数、枚举和<code>const</code>变量。
为宏命名时使用项目特定的前缀。不要使用宏来定义C++ API的部分。</p>

<p>宏意味着你看到的代码与编译器看到的代码不同。这可能引入意外的行为，特别是因为宏具有全局作用域。</p>

<p>宏引入的问题在它们用于定义C++ API的部分时尤为严重，对于公共API更是如此。当开发人员错误使用该接口时，编译器的每条错误消息现在都必须解释宏是如何形成该接口的。重构和分析工具在更新接口时会遇到极大的困难。因此，我们特别禁止以这种方式使用宏。例如，避免如下模式：</p>

<pre class="badcode">class WOMBAT_TYPE(Foo) {
  // ...

 public:
  EXPAND_PUBLIC_WOMBAT_API(Foo)

  EXPAND_WOMBAT_COMPARISONS(Foo, ==, &lt;)
};
</pre>

<p>幸运的是，宏在C++中并不像在C中那样必要。不要使用宏来内联性能关键代码，而是使用内联函数。不要使用宏来存储常量，而是使用<code>const</code>变量。不要使用宏来“缩写”长变量名，而是使用引用。不要使用宏来有条件地编译代码...嗯，完全不要这样做（当然，除了防止头文件重复包含的<code>#define</code>保护之外）。这会使测试变得更加困难。</p>

<p>宏可以做其他技术无法做到的事情，你确实会在代码库中看到它们，特别是在底层库中。它们的某些特殊功能（如字符串化、连接等）是语言本身无法提供的。但在使用宏之前，请仔细考虑是否有非宏的方式可以达到同样的效果。如果你需要使用宏来定义接口，请联系你的项目负责人请求豁免此规则。</p>

<p>以下使用模式将避免许多与宏相关的问题；如果你使用宏，尽可能遵循它：</p>

<ul>
  <li>不要在<code>.h</code>文件中定义宏。</li>

  <li>在使用宏之前立即<code>#define</code>它们，并在使用后立即<code>#undef</code>它们。</li>

  <li>不要在替换现有宏之前仅仅<code>#undef</code>它；相反，选择一个可能独一无二的名称。</li>

  <li>尽量避免使用扩展到不平衡的C++构造的宏，或者至少要很好地记录这种行为。</li>

  <li>尽量不使用<code>##</code>来生成函数/类/变量名称。</li>

</ul>

<p>从头文件导出宏（即在头文件中定义它们而不在头文件结束前<code>#undef</code>它们）是极力不鼓励的。如果你确实从头文件导出一个宏，它必须有一个全局唯一的名称。为了实现这一点，它必须使用由你的项目命名空间名称（但大写）组成的前缀命名。</p>

<h3 id="0_and_nullptr/NULL">0和nullptr/NULL</h3>

<p>对指针使用<code>nullptr</code>，对字符使用<code>'\0'</code>（而不是<code>0</code>字面量）。</p>

<p>对于指针（地址值），使用<code>nullptr</code>，因为这提供了类型安全性。</p>

<p>对空字符使用<code>'\0'</code>。使用正确的类型使代码更易读。</p>

<h3 id="sizeof">sizeof</h3>

<p>优先使用<code>sizeof(<var>varname</var>)</code>而不是<code>sizeof(<var>type</var>)</code>。</p>

<p>当你获取特定变量的大小时，使用<code>sizeof(<var>varname</var>)</code>。
<code>sizeof(<var>varname</var>)</code>会在有人现在或将来更改变量类型时适当更新。你可以使用<code>sizeof(<var>type</var>)</code>来处理与任何特定变量无关的代码，例如管理外部或内部数据格式的代码，其中使用适当的C++类型的变量不方便。</p>

<pre>MyStruct data;
memset(&amp;data, 0, sizeof(data));
</pre>

<pre class="badcode">memset(&amp;data, 0, sizeof(MyStruct));
</pre>

<pre>if (raw_size &lt; sizeof(int)) {
  LOG(ERROR) &lt;&lt; "压缩记录不够大，无法容纳计数：" &lt;&lt; raw_size;
  return false;
}
</pre>

<a id="auto"></a>
<h3 id="Type_deduction">类型推导（包括 auto）</h3>

<p>仅当类型推导能使不熟悉项目的人更容易理解代码，或使代码更安全时才使用它。不要仅仅为了避免编写显式类型的麻烦而使用它。</p>

<p class="definition"></p>

<p>C++ 在几种情况下允许（甚至要求）编译器推导类型，而不是在代码中显式地指定类型：</p>
<dl>
  <dt><a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">函数模板参数推导</a></dt>
  <dd>可以不带显式模板参数调用函数模板。编译器从函数参数的类型中推导出这些参数：
    <pre class="neutralcode">template &lt;typename T&gt;
void f(T t);

f(0);  // 调用 f&lt;int&gt;(0)</pre>
  </dd>
  <dt><a href="https://en.cppreference.com/w/cpp/language/auto"><code>auto</code> 变量声明</a></dt>
  <dd>变量声明可以使用 <code>auto</code> 关键字代替类型。编译器从变量的初始化器中推导出类型，遵循与使用相同初始化器的函数模板参数推导相同的规则（只要你不使用大括号而是使用圆括号）。
    <pre class="neutralcode">auto a = 42;  // a 是 int
auto&amp; b = a;  // b 是 int&amp;
auto c = b;   // c 是 int
auto d{42};   // d 是 int，不是 std::initializer_list&lt;int&gt;
</pre>
    <code>auto</code> 可以与 <code>const</code> 结合使用，并且可以作为指针或引用类型的一部分使用，并且（自 C++17 起）可以作为非类型模板参数使用。这种语法的一个罕见变体是使用 <code>decltype(auto)</code> 代替 <code>auto</code>，在这种情况下，推导出的类型是将 <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a> 应用于初始化器的结果。
  </dd>
  <dt><a href="https://en.cppreference.com/w/cpp/language/function#Return_type_deduction">函数返回类型推导</a></dt>
  <dd><code>auto</code>（和 <code>decltype(auto)</code>）也可以用于替代函数返回类型。编译器从函数体中的 <code>return</code> 语句推导出返回类型，遵循与变量声明相同的规则：
    <pre class="neutralcode">auto f() { return 0; }  // f 的返回类型是 int</pre>
    <a href="#Lambda_expressions">Lambda 表达式</a> 的返回类型也可以以相同的方式推导，但这是通过省略返回类型而不是通过显式的 <code>auto</code> 触发的。令人困惑的是，<a href="#trailing_return">尾随返回类型</a> 语法对于函数也使用 <code>auto</code> 在返回类型位置，但这不依赖于类型推导；它只是显式返回类型的另一种语法。
  </dd>
  <dt><a href="https://isocpp.org/wiki/faq/cpp14-language#generic-lambdas">通用 Lambda</a></dt>
  <dd>Lambda 表达式可以使用 <code>auto</code> 关键字代替一个或多个参数类型。这会使 Lambda 的调用运算符成为一个函数模板而不是普通函数，每个 <code>auto</code> 函数参数都有一个单独的模板参数：
    <pre class="neutralcode">// 按降序排序 `vec`
std::sort(vec.begin(), vec.end(), [](auto lhs, auto rhs) { return lhs &gt; rhs; });</pre>
  </dd>
  <dt><a href="https://isocpp.org/wiki/faq/cpp14-language#lambda-captures">Lambda 初始化捕获</a></dt>
  <dd>Lambda 捕获可以有显式的初始化器，这可以用来声明全新的变量，而不仅仅是捕获现有的变量：
    <pre class="neutralcode">[x = 42, y = "foo"] { ... }  // x 是 int，y 是 const char*</pre>
    这种语法不允许指定类型；相反，它使用 <code>auto</code> 变量的规则进行推导。
  </dd>
  <dt><a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">类模板参数推导</a></dt>
  <dd>参见 <a href="#CTAD">下文</a>。</dd>
  <dt><a href="https://en.cppreference.com/w/cpp/language/structured_binding">结构化绑定</a></dt>
  <dd>在使用 <code>auto</code> 声明元组、结构或数组时，可以为各个元素指定名称，而不是为整个对象指定名称；这些名称称为“结构化绑定”，整个声明称为“结构化绑定声明”。这种语法没有提供指定封闭对象或各个名称类型的途径：
    <pre class="neutralcode">auto [iter, success] = my_map.insert({key, value});
if (!success) {
  iter-&gt;second = value;
}</pre>
    <code>auto</code> 也可以与 <code>const</code>、<code>&amp;</code> 和 <code>&amp;&amp;</code> 结合使用，但请注意，这些限定符在技术上适用于匿名元组/结构/数组，而不是各个绑定。确定绑定类型的规则相当复杂；结果通常不会令人惊讶，除了绑定类型通常不会是引用，即使声明声明了一个引用（但它们通常会像引用一样行为）。
  </dd>
</dl>

<p>（这些总结省略了许多细节和注意事项；请参阅链接以获取更多信息。）</p>

<p class="pros"></p>

<ul>
  <li>C++ 类型名称可能很长且繁琐，尤其是当它们涉及模板或命名空间时。</li>
  <li>当 C++ 类型名称在单个声明或小代码区域内重复时，这种重复可能不会有助于可读性。</li>
  <li>有时让类型被推导出来会更安全，因为这避免了意外复制或类型转换的可能性。</li>
</ul>

<p class="cons"></p>
<p>当类型是显式的时，C++ 代码通常更清晰，尤其是当类型推导依赖于代码远处的信息时。在像这样的表达式中：</p>

<pre class="badcode">auto foo = x.add_foo();
auto i = y.Find(key);
</pre>

<p>如果 <code>y</code> 的类型不是很为人所知，或者 <code>y</code> 是在许多行之前声明的，那么结果类型可能并不明显。</p>

<p>程序员必须理解类型推导何时会或不会产生引用类型，否则他们会在不经意间得到副本。</p>
<p>如果一个推导类型被用作接口的一部分，那么程序员可能在只打算更改其值时更改了其类型，导致比预期更激进的API更改。</p>

<p class="decision"></p>

<p>基本规则是：仅在使代码更清晰或更安全时使用类型推导，不要仅仅为了避免编写显式类型的麻烦而使用它。在判断代码是否更清晰时，请记住您的读者不一定是您的团队成员，或熟悉您的项目，因此您和您的审阅者认为不必要的类型杂乱通常会为其他人提供有用的信息。例如，您可以认为<code>make_unique&lt;Foo&gt;()</code>的返回类型是显而易见的，但<code>MyWidgetFactory()</code>的返回类型可能不是这样。</p>

<p>这些原则适用于所有形式的类型推导，但细节有所不同，如下节所述。</p>

<h4>函数模板参数推导</h4>

<p>函数模板参数推导几乎总是可以接受的。类型推导是与函数模板交互的预期默认方式，因为它允许函数模板像无限集合的普通函数重载一样工作。因此，函数模板几乎总是被设计成模板参数推导清晰且安全，或者无法编译。</p>

<h4>局部变量类型推导</h4>

<p>对于局部变量，您可以使用类型推导来通过消除明显或不相关的类型信息，使代码更清晰，以便读者可以专注于代码的有意义部分：</p>
<pre class="neutralcode">std::unique_ptr&lt;WidgetWithBellsAndWhistles&gt; widget =
  std::make_unique&lt;WidgetWithBellsAndWhistles&gt;(arg1, arg2);
absl::flat_hash_map&lt;std::string,
                    std::unique_ptr&lt;WidgetWithBellsAndWhistles&gt;&gt;::const_iterator
  it = my_map_.find(key);
std::array&lt;int, 6&gt; numbers = {4, 8, 15, 16, 23, 42};</pre>

<pre class="goodcode">auto widget = std::make_unique&lt;WidgetWithBellsAndWhistles&gt;(arg1, arg2);
auto it = my_map_.find(key);
std::array numbers = {4, 8, 15, 16, 23, 42};</pre>

<p>类型有时包含有用信息和样板代码的混合，例如上例中的<code>it</code>：显然它是一个迭代器，并且在许多上下文中容器类型甚至键类型并不相关，但值的类型可能是有用的。在这种情况下，通常可以定义具有显式类型的局部变量来传达相关信息：</p>
<pre class="goodcode">if (auto it = my_map_.find(key); it != my_map_.end()) {
  WidgetWithBellsAndWhistles&amp; widget = *it-&gt;second;
  // 使用`widget`做一些事情
}</pre>
<p>如果类型是一个模板实例，并且参数是样板代码但模板本身是有信息的，您可以使用类模板参数推导来抑制样板代码。然而，实际上提供有意义益处的情况非常罕见。请注意，类模板参数推导也受<a href="#CTAD">单独的样式规则</a>约束。</p>

<p>如果有更简单的选项可用，不要使用<code>decltype(auto)</code>，因为它是一个相当晦涩的功能，因此在代码清晰度上成本较高。</p>

<h4>返回类型推导</h4>

<p>仅当函数体中只有很少的<code>return</code>语句，并且几乎没有其他代码时，才使用返回类型推导（适用于函数和lambda），因为否则读者可能无法一眼看出返回类型是什么。此外，仅当函数或lambda的作用域非常狭窄时才使用它，因为具有推导返回类型的函数不定义抽象边界：实现<em>就是</em>接口。特别是，头文件中的公共函数几乎永远不应该有推导的返回类型。</p>

<h4>参数类型推导</h4>

<p>对于lambda的<code>auto</code>参数类型应谨慎使用，因为实际类型是由调用lambda的代码决定的，而不是由lambda的定义决定的。因此，除非lambda在定义处附近被显式调用（这样读者可以轻松看到两者），或者lambda被传递给一个众所周知的接口以至于显然它最终将被调用的参数是什么（例如，上面的<code>std::sort</code>示例），否则显式类型几乎总是更清晰的。</p>

<h4>Lambda初始化捕获</h4>

<p>初始化捕获由<a href="#Lambda_expressions">更具体的样式规则</a>覆盖，该规则在很大程度上取代了类型推导的一般规则。</p>

<h4>结构化绑定</h4>

<p>与其他形式的类型推导不同，结构化绑定实际上可以通过为更大对象的元素提供有意义的名称来为读者提供额外信息。这意味着结构化绑定声明可能在<code>auto</code>不会的情况下提供比显式类型更好的可读性改进。结构化绑定在对象是pair或tuple时（如上面的<code>insert</code>示例）特别有益，因为它们一开始就没有有意义的字段名称，但请注意，除非像<code>insert</code>这样的预先存在的API迫使您这样做，否则您通常<a href="#Structs_vs._Tuples">不应该使用pair或tuple</a>。</p>

<p>如果被绑定的对象是一个结构体，有时提供更具体于您使用情况的名称可能会有所帮助，但请记住，这也可能意味着名称对您的读者来说不如字段名称那么容易识别。我们建议使用注释来指示基础字段的名称，如果它与绑定的名称不匹配，使用与函数参数注释相同的语法：</p>
<pre>auto [/*field_name1=*/bound_name1, /*field_name2=*/bound_name2] = ...</pre>
<p>与函数参数注释一样，这可以使工具检测到您是否弄错了字段的顺序。</p>
<h3 id="CTAD">类模板参数推导</h3>

<p>仅在明确支持此功能的模板上使用类模板参数推导。</p>

<p class="definition"></p>
<p><a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">类模板参数推导</a>（通常缩写为“CTAD”）发生在变量声明时使用了模板类型，且未提供模板参数列表（甚至没有空的尖括号）：</p>
  <pre class="neutralcode">std::array a = {1, 2, 3};  // `a` 是 std::array&lt;int, 3&gt;</pre>
<p>编译器使用模板的“推导指南”从初始化器中推导出参数，这些推导指南可以是显式的或隐式的。</p>

<p>显式的推导指南看起来像带有尾随返回类型的函数声明，但没有前导的 <code>auto</code>，且函数名是模板的名称。例如，上述示例依赖于 <code>std::array</code> 的以下推导指南：</p>
  <pre class="neutralcode">namespace std {
template &lt;class T, class... U&gt;
array(T, U...) -&gt; std::array&lt;T, 1 + sizeof...(U)&gt;;
}</pre>
<p>主模板中的构造函数（相对于模板特化）也会隐式定义推导指南。</p>

<p>当你声明依赖于 CTAD 的变量时，编译器使用构造函数重载解析规则选择一个推导指南，该指南的返回类型将成为变量的类型。</p>

<p class="pros"></p>
<p>CTAD 有时可以让你省略代码中的样板内容。</p>

<p class="cons"></p>
<p>从构造函数生成的隐式推导指南可能具有不理想的行为，或者完全不正确。这对于在 C++17 引入 CTAD 之前编写的构造函数尤其成问题，因为这些构造函数的作者无法预知（更不用说修复）它们的构造函数对 CTAD 造成的任何问题。此外，添加显式的推导指南来修复这些问题可能会破坏依赖于隐式推导指南的现有代码。</p>

<p>CTAD 还具有与 <code>auto</code> 相同的许多缺点，因为它们都是从初始化器中推导变量类型全部或部分的机制。CTAD 确实比 <code>auto</code> 提供了更多的信息给读者，但它也没有给读者一个明显的提示，信息已被省略。</p>

<p class="decision"></p>
<p>除非模板的维护者通过提供至少一个显式的推导指南明确支持使用 CTAD（所有 <code>std</code> 命名空间中的模板也被假定为已选择支持），否则不要在给定模板上使用 CTAD。如果可用，应使用编译器警告来强制执行此规则。</p>

<p>CTAD 的使用还必须遵循关于<a href="#Type_deduction">类型推导</a>的一般规则。</p>

<h3 id="Designated_initializers">指定初始化器</h3>

<p>仅以符合 C++20 标准的形式使用指定初始化器。</p>

<p class="definition"></p>
<p><a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization#Designated_initializers">指定初始化器</a>是一种语法，允许通过显式命名其字段来初始化聚合体（“普通旧式结构”）：</p>
  <pre class="neutralcode">  struct Point {
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
  };

  Point p = {
    .x = 1.0,
    .y = 2.0,
    // z 将为 0.0
  };</pre>
<p>显式列出的字段将按指定方式初始化，其他字段将以与传统聚合体初始化表达式（如 <code>Point{1.0, 2.0}</code>）相同的方式初始化。</p>

<p class="pros"></p>
<p>指定初始化器可以使聚合体表达式变得方便且易读，特别是对于字段顺序不如上述 <code>Point</code> 示例那样直接的结构体。</p>

<p class="cons"></p>
<p>尽管指定初始化器长期以来是 C 标准的一部分，并且作为扩展被 C++ 编译器支持，但在 C++20 之前，C++ 并不支持它们。</p>

<p>C++ 标准中的规则比 C 和编译器扩展中的规则更严格，要求指定初始化器按结构定义中字段出现的顺序出现。因此，在上述示例中，根据 C++20，初始化 <code>x</code> 然后 <code>z</code> 是合法的，但初始化 <code>y</code> 然后 <code>x</code> 则不合法。</p>

<p class="decision"></p>
<p>仅以与 C++20 标准兼容的形式使用指定初始化器：初始化器应按结构定义中相应字段出现的顺序排列。</p>
<h3 id="Lambda_expressions">Lambda 表达式</h3>

<p>在适当的地方使用 lambda 表达式。当 lambda 表达式可能逃离当前作用域时，优先使用显式捕获。</p>

<p class="definition"></p>
<p> Lambda 表达式是一种创建匿名函数对象的简洁方式。它们在传递函数作为参数时通常很有用。例如：</p>

<pre>std::sort(v.begin(), v.end(), [](int x, int y) {
  return Weight(x) &lt; Weight(y);
});
</pre>

<p> 它们还允许从封闭作用域捕获变量，可以通过名称显式捕获，也可以使用默认捕获隐式捕获。显式捕获需要列出每个变量，作为值捕获或引用捕获：</p>

<pre>int weight = 3;
int sum = 0;
// 按值捕获 `weight`，按引用捕获 `sum`。
std::for_each(v.begin(), v.end(), [weight, &amp;sum](int x) {
  sum += weight * x;
});
</pre>


<p>默认捕获会隐式捕获 lambda 体中引用的任何变量，包括如果使用了成员变量的 <code>this</code>：</p>

<pre>const std::vector&lt;int&gt; lookup_table = ...;
std::vector&lt;int&gt; indices = ...;
// 按引用捕获 `lookup_table`，按 `lookup_table` 中关联元素的值对 `indices` 进行排序。
std::sort(indices.begin(), indices.end(), [&amp;](int a, int b) {
  return lookup_table[a] &lt; lookup_table[b];
});
</pre>

<p>变量捕获也可以有显式初始化器，这可以用于按值捕获只能移动的变量，或处理普通引用或值捕获无法处理的其他情况：</p>
  <pre>std::unique_ptr&lt;Foo&gt; foo = ...;
[foo = std::move(foo)] () {
  ...
}</pre>
<p>这种捕获（通常称为“初始化捕获”或“广义 lambda 捕获”）实际上不需要从封闭作用域“捕获”任何东西，甚至不需要从封闭作用域中使用名称；这种语法是一种完全通用的定义 lambda 对象成员的方式：</p>
  <pre class="neutralcode">[foo = std::vector&lt;int&gt;({1, 2, 3})] () {
  ...
}</pre>
<p>带有初始化器的捕获的类型使用与 <code>auto</code> 相同的规则进行推断。</p>

<p class="pros"></p>
<ul>
  <li>Lambda 表达式比其他定义传递给 STL 算法的函数对象的方式要简洁得多，这可以提高可读性。</li>

  <li>适当使用默认捕获可以减少冗余，并突出显示与默认值的重要例外情况。</li>

   <li>Lambda、<code>std::function</code> 和 <code>std::bind</code> 可以结合使用，作为通用的回调机制；它们使得编写接受绑定函数作为参数的函数变得容易。</li>
</ul>

<p class="cons"></p>
<ul>
  <li>Lambda 中的变量捕获可能是悬空指针错误的来源，特别是如果 lambda 逃离当前作用域时。</li>

  <li>按值进行默认捕获可能会误导，因为它们并不能防止悬空指针错误。按值捕获指针不会进行深拷贝，因此通常与按引用捕获具有相同的生活周期问题。当按值捕获 <code>this</code> 时尤其令人困惑，因为 <code>this</code> 的使用通常是隐式的。</li>

  <li>捕获实际上声明了新的变量（无论捕获是否有初始化器），但它们看起来与 C++ 中任何其他变量声明语法都不一样。特别是，没有地方放置变量的类型，甚至没有 <code>auto</code> 占位符（尽管初始化捕获可以通过例如强制转换间接指示类型）。这可能使得它们难以被识别为声明。</li>

  <li>初始化捕获本质上依赖于 <a href="#Type_deduction">类型推断</a>，并且具有与 <code>auto</code> 相同的许多缺点，另外的问题是语法甚至没有提示读者正在进行推断。</li>

  <li>Lambda 的使用可能会失控；非常长的嵌套匿名函数可能会使代码更难理解。</li>

</ul>

<p class="decision"></p>
<ul>
<li>在适当的地方使用 lambda 表达式，并按照 <a href="#Formatting_Lambda_Expressions">下文</a> 描述的格式进行格式化。</li>
<li>如果 lambda 可能逃离当前作用域，优先使用显式捕获。例如，而不是：
<pre class="badcode">{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;] { Frobnicate(foo); })
  ...
}
// 不好！lambda 使用了对 `foo` 的引用，并且可能使用了 `this`（如果 `Frobnicate` 是成员函数），这在粗略检查时可能不明显。如果 lambda 在函数返回后被调用，那将是糟糕的，因为 `foo` 和封闭对象都可能已被销毁。
</pre>
更好的做法是：
<pre>{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;foo] { Frobnicate(foo); })
  ...
}
// 更好 - 如果 `Frobnicate` 是成员函数，编译将失败，并且更清楚 `foo` 被危险地按引用捕获。
</pre>
</li>
<li>仅当 lambda 的生命周期明显短于任何潜在捕获时，才使用按引用进行默认捕获（<code>[&amp;]</code>）。
</li>
<li>仅当作为短 lambda 的手段来绑定少数变量时，才使用按值进行默认捕获（<code>[=]</code>），其中捕获的变量集一目了然，并且不会隐式捕获 <code>this</code>。（这意味着在非静态类成员函数中出现的 lambda，如果在其主体中引用了非静态类成员，必须显式捕获 <code>this</code> 或通过 <code>[&amp;]</code> 捕获。）不建议编写长或复杂的 lambda 并使用按值进行默认捕获。
</li>
<li>仅使用捕获来实际从封闭作用域捕获变量。不要使用带有初始化器的捕获来引入新名称，或实质上改变现有名称的含义。相反，以常规方式声明一个新变量，然后捕获它，或者避免使用 lambda 简写并显式定义一个函数对象。</li>
<li>有关指定参数和返回类型的指导，请参阅 <a href="#Type_deduction">类型推断</a> 部分。</li>

</ul>
<h3 id="Template_metaprogramming">模板元编程</h3>

<p>避免复杂的模板编程。</p>

<p class="definition"></p>
<p>模板元编程指的是一系列利用C++模板实例化机制是图灵完备的这一事实的技术，这些技术可以在类型域中执行任意编译时计算。</p>

<p class="pros"></p>
<p>模板元编程允许创建类型安全且高性能的极度灵活的接口。没有它，像

<a href="https://github.com/google/googletest">GoogleTest</a>,
<code>std::tuple</code>, <code>std::function</code>, 和
Boost.Spirit这样的设施将无法实现。</p>

<p class="cons"></p>
<p>模板元编程使用的技术通常对除了语言专家之外的人来说是晦涩难懂的。使用模板的复杂方式编写的代码往往难以阅读，并且难以调试或维护。</p>

<p>模板元编程常常导致极其糟糕的编译时错误消息：即使接口简单，当用户做错事时，复杂的实现细节也会变得可见。</p>

<p>模板元编程通过使重构工具的工作变得更加困难而干扰大规模重构。首先，模板代码在多个上下文中展开，很难验证转换在所有上下文中都合理。其次，一些重构工具使用仅表示模板展开后代码结构的AST。自动回溯到需要重写的原始源代码结构可能很困难。</p>

<p class="decision"></p>
<p>模板元编程有时允许创建比没有它时更清晰、更易用的接口，但它也常常是一种过度聪明的诱惑。最好在少数低级组件中使用它，在那里额外的维护负担可以分摊到大量的使用中。</p>

<p>在使用模板元编程或其他复杂的模板技术之前要三思；考虑一下你的团队中的普通成员是否能够足够理解你的代码以便在你转到另一个项目后维护它，或者一个非C++程序员或随意浏览代码库的人是否能够理解错误消息或追踪他们想要调用的函数的流程。如果你使用递归模板实例化、类型列表、元函数或表达式模板，或者依赖SFINAE或<code>sizeof</code>技巧来检测函数重载解析，那么你很可能已经走得太远了。</p>

<p>如果你使用模板元编程，你应该期望投入相当大的努力来最小化和隔离复杂性。你应该尽可能将元编程隐藏为实现细节，以便用户面对的头文件可读，并且你应该确保棘手的代码特别有注释。你应该仔细记录代码的使用方式，并且你应该说明“生成”的代码看起来是什么样的。特别注意当用户犯错时编译器发出的错误消息。错误消息是你用户界面的一部分，你的代码应该根据需要进行调整，以便错误消息从用户的角度来看是可理解和可操作的。</p>
<h3 id="Concepts">概念和约束</h3>

<p>谨慎使用概念。
一般来说，概念和约束应该只在C++20之前会使用模板的情况下使用。
避免在头文件中引入新概念，除非这些头文件被标记为库内部使用。
不要定义编译器不强制执行的概念。
优先使用约束而不是模板元编程，并且
避免使用 <code>template&lt;<i>Concept</i> T&gt;</code> 语法；
相反，使用 <code>requires(<i>Concept&lt;T&gt;</i>)</code> 语法。</p>

<p class="definition"></p>
<p><code>concept</code> 关键字是一种新的机制，用于为模板参数定义要求（如类型特征或接口规范）。
<code>requires</code> 关键字提供了在模板上放置匿名约束并在编译时验证这些约束是否满足的机制。
概念和约束通常一起使用，但也可以独立使用。</p>

<p class="pros"></p>
<ul>
  <li>概念允许编译器在涉及模板时生成更好的错误消息，这可以减少混淆并显著改善开发体验。</li>
  <li>概念可以减少定义和使用编译时约束所需的样板代码，通常能提高生成代码的清晰度。</li>
  <li>约束提供了一些使用模板和SFINAE技术难以实现的能力。</li>
</ul>

<p class="cons"></p>
<ul>
  <li>与模板一样，概念可能会使代码变得更加复杂且难以理解。</li>
  <li>概念语法可能对读者造成困惑，因为在使用位置，概念看起来类似于类类型。</li>
  <li>特别是在API边界，概念会增加代码的耦合性、刚性和僵化性。</li>
  <li>概念和约束可能会重复函数体的逻辑，导致代码重复和维护成本增加。</li>
  <li>概念模糊了其底层契约的真实来源，因为它们是可以在一多个位置使用的独立命名实体，这些实体都独立于彼此发展。
  这可能导致声明的和暗示的要求随时间推移而分歧。</li>
  <li>概念和约束以新颖且不明显的方式影响重载解析。</li>
  <li>与SFINAE一样，约束使得大规模重构代码变得更加困难。</li>
</ul>

<p class="decision"></p>
<p>当标准库中存在等效的预定义概念时，应优先使用它们而不是类型特征。
（例如，如果在C++20之前使用了 <code>std::is_integral_v</code>，那么在C++20代码中应使用 <code>std::integral</code>。）
同样，优先使用现代约束语法
（通过 <code>requires(<i>Condition</i>)</code>）。
避免使用传统的模板元编程结构
（如 <code>std::enable_if&lt;<i>Condition</i>&gt;</code>）
以及 <code>template&lt;<i>Concept</i> T&gt;</code> 语法。</p>

<p>不要手动重新实现任何现有的概念或特征。
例如，使用
<code>requires(std::default_initializable&lt;T&gt;)</code>
而不是
<code>requires(requires { T v; })</code>
或类似的东西。

</p><p>新的 <code>concept</code> 声明应很少见，并且只能在库内部定义，这样它们不会在API边界暴露。
更一般地，不要在你不会在C++17中使用其传统模板等效物的案例中使用概念或约束。
</p>

<p>不要定义与函数体重复的概念，或施加从阅读代码体或生成的错误消息中看似微不足道或显而易见的要求。
例如，避免以下做法：
</p><pre class="badcode">template &lt;typename T&gt;     // 不好 - 冗余且收益微小
concept Addable = std::copyable&lt;T&gt; &amp;&amp; requires(T a, T b) { a + b; };
template &lt;Addable T&gt;
T Add(T x, T y, T z) { return x + y + z; }
</pre>
相反，除非你能证明概念在特定情况下（如在深层嵌套或不明显的要求的错误消息中）带来显著改进，否则应保持代码为普通模板。

<p>概念应由编译器静态验证。
不要使用主要好处来自语义（或其他未强制执行的）约束的概念。
在编译时未强制执行的要求应通过其他机制（如注释、断言或测试）来施加。</p>

<h3 id="modules">C++20模块</h3>

<p>不要使用C++20模块。</p>

<p>C++20引入了“模块”，这是一种新的语言特性，旨在作为头文件文本包含的替代方案。它引入了三个新的关键字来支持
这项功能：<code>module</code>、export、
和 <code>import</code>。

</p><p>模块是C++编写和编译方式的一大转变，我们仍在评估它们将来如何融入Google的C++生态系统。此外，它们目前在我们的构建系统、编译器和其他工具中支持得不好，需要进一步探索编写和使用它们的最佳实践。</p>

<h3 id="coroutines">协程</h3>

<p>（目前）不要使用协程。</p>

<p>不要包含 <code>&lt;coroutine&gt;</code> 头文件，
或使用 <code>co_await</code>、<code>co_yield</code>、
或 <code>co_return</code> 关键字。</p>

<p>注意：此禁令预计是暂时的，正在制定进一步的指导方针。

</p>
<h3 id="Boost">Boost</h3>

<p>仅使用Boost库集合中已批准的库。</p>

<p class="definition"></p>
<p> <a href="https://www.boost.org/">
Boost库集合</a> 是一个流行的同行评审、免费、开源的C++库集合。</p>

<p class="pros"></p>
<p>Boost代码通常质量非常高，具有广泛的可移植性，并且填补了C++标准库中的许多重要空白，例如类型特征和更好的绑定器。</p>

<p class="cons"></p>
<p>一些Boost库鼓励可能影响可读性的编码实践，例如元编程和其他高级模板技术，以及过度的“函数式”编程风格。 </p>

<p class="decision"></p>

<div>
<p>为了保持所有可能阅读和维护代码的贡献者的高可读性，我们只允许使用经过批准的Boost功能子集。目前，允许使用的库包括：</p>

<ul>
  <li>
  <a href="https://www.boost.org/libs/utility/call_traits.htm">
  调用特征</a> 来自 <code>boost/call_traits.hpp</code></li>

  <li><a href="https://www.boost.org/libs/utility/compressed_pair.htm">
  压缩对</a> 来自 <code>boost/compressed_pair.hpp</code></li>

  <li><a href="https://www.boost.org/libs/graph/">
  Boost图形库（BGL）</a> 来自 <code>boost/graph</code>，但不包括序列化（<code>adj_list_serialize.hpp</code>）以及并行/分布式算法和数据结构（<code>boost/graph/parallel/*</code> 和 <code>boost/graph/distributed/*</code>）。</li>

  <li><a href="https://www.boost.org/libs/property_map/">
  属性映射</a> 来自 <code>boost/property_map</code>，但不包括并行/分布式属性映射（<code>boost/property_map/parallel/*</code>）。</li>

  <li><a href="https://www.boost.org/libs/iterator/">
  迭代器</a> 来自 <code>boost/iterator</code></li>

  <li><a href="https://www.boost.org/libs/polygon/">
  多边形</a> 中处理Voronoi图构建且不依赖于多边形其余部分的部分：
  <code>boost/polygon/voronoi_builder.hpp</code>,
  <code>boost/polygon/voronoi_diagram.hpp</code>, 和
  <code>boost/polygon/voronoi_geometry_type.hpp</code></li>

  <li><a href="https://www.boost.org/libs/bimap/">
  双向映射</a> 来自 <code>boost/bimap</code></li>

  <li><a href="https://www.boost.org/libs/math/doc/html/dist.html">
  统计分布和函数</a> 来自
  <code>boost/math/distributions</code></li>

  <li><a href="https://www.boost.org/libs/math/doc/html/special.html">
  特殊函数</a> 来自 <code>boost/math/special_functions</code></li>

  <li><a href="https://www.boost.org/libs/math/doc/html/root_finding.html">
  根查找和最小化函数</a> 来自 <code>boost/math/tools</code></li>

  <li><a href="https://www.boost.org/libs/multi_index/">
  多索引</a> 来自 <code>boost/multi_index</code></li>

  <li><a href="https://www.boost.org/libs/heap/">
  堆</a> 来自 <code>boost/heap</code></li>

  <li><a href="https://www.boost.org/libs/container/">容器</a>中的平面容器：
  <code>boost/container/flat_map</code>, 和
  <code>boost/container/flat_set</code></li>

  <li><a href="https://www.boost.org/libs/intrusive/">侵入式</a>
  来自 <code>boost/intrusive</code>。</li>

  <li><a href="https://www.boost.org/libs/sort/">排序库</a>
  <code>boost/sort</code>。</li>

  <li><a href="https://www.boost.org/libs/preprocessor/">预处理器</a>
  来自 <code>boost/preprocessor</code>。</li>
</ul>

<p>我们正在积极考虑将其他Boost功能添加到列表中，因此此列表将来可能会扩展。</p>
</div>

<h3 id="Disallowed_Stdlib">禁止使用的标准库功能</h3>

<p>与<a href="#Boost">Boost</a>一样，一些现代C++库功能鼓励可能影响可读性的编码实践——例如通过移除可能对读者有帮助的检查冗余（如类型名称），或通过鼓励模板元编程。其他扩展重复了通过现有机制可用的功能，这可能导致混淆和转换成本。</p>

<p class="decision"></p>
<p>以下C++标准库功能不得使用：</p>

<ul>

  <li>编译时有理数
  (<code>&lt;ratio&gt;</code>)，因为担心它与更依赖模板的接口风格相关联。</li>

  <li><code>&lt;cfenv&gt;</code> 和
  <code>&lt;fenv.h&gt;</code> 头文件，因为许多编译器无法可靠地支持这些功能。</li>

  <li><code>&lt;filesystem&gt;</code> 头文件，
  因为它在测试方面的支持不足，并且存在固有的安全漏洞。</li>

</ul>

<h3 id="Nonstandard_Extensions">非标准扩展</h3>

<p>除非另有说明，否则不得使用C++的非标准扩展。</p>

<p class="definition"></p>
<p>编译器支持各种不属于标准C++的扩展。此类扩展包括GCC的 <code>__attribute__</code>、内建函数如 <code>__builtin_prefetch</code> 或SIMD、<code>#pragma</code>、内联汇编、<code>__COUNTER__</code>、<code>__PRETTY_FUNCTION__</code>、复合语句表达式（例如，<code>foo = ({ int x; Bar(&amp;x); x })</code>）、变长数组和 <code>alloca()</code>，以及"<a href="https://en.wikipedia.org/wiki/Elvis_operator">Elvis操作符</a>" <code>a?:b</code>。</p>

<p class="pros"></p>
  <ul>
    <li>非标准扩展可能提供标准C++中不存在的有用功能。</li>
    <li>对编译器的重要性能指导只能通过扩展来指定。</li>
  </ul>

<p class="cons"></p>
  <ul>
    <li>非标准扩展在所有编译器中都不起作用。使用非标准扩展会降低代码的可移植性。</li>
    <li>即使在所有目标编译器中都支持这些扩展，扩展通常没有明确的规范，并且编译器之间可能存在细微的行为差异。</li>
    <li>非标准扩展增加了读者必须了解的语言功能，以理解代码。</li>
    <li>非标准扩展需要额外的工作来跨架构移植。</li>
  </ul>

<p class="decision"></p>
<p>不要使用非标准扩展。你可以使用通过非标准扩展实现的可移植性包装器，只要这些包装器由指定的项目范围内的可移植性头文件提供即可。</p>
<h3 id="Aliases">别名</h3>

<p>公共别名是为了API用户的利益而设，应予以明确的文档说明。</p>

<p class="definition"></p>
<p>有几种方法可以创建其他实体的别名名称：</p>
<pre>using Bar = Foo;
typedef Foo Bar;  // 但在C++代码中更推荐使用`using`。
using ::other_namespace::Foo;
using enum MyEnumType;  // 为MyEnumType中的所有枚举器创建别名。
</pre>

  <p>在新代码中，<code>using</code>比<code>typedef</code>更可取，
  因为它提供了与C++其他部分更一致的语法，并且适用于模板。</p>

  <p>像其他声明一样，在头文件中声明的别名是该头文件公共API的一部分，除非它们位于函数定义中、类的私有部分中，或在明确标记为内部的命名空间中。此类区域或<code>.cc</code>文件中的别名是实现细节（因为客户端代码无法引用它们），不受此规则的限制。</p>

<p class="pros"></p>
  <ul>
    <li>别名可以通过简化长或复杂的名称来提高可读性。</li>
    <li>别名可以通过在一个地方命名在API中重复使用的类型来减少重复，这<em>可能</em>使以后更改类型变得更容易。
    </li>
  </ul>

<p class="cons"></p>
  <ul>
    <li>当放置在客户端代码可以引用的头文件中时，别名会增加该头文件API中的实体数量，增加其复杂性。</li>
    <li>客户端可能容易依赖公共别名的非预期细节，使更改变得困难。</li>
    <li>可能会诱使创建一个仅用于实现的公共别名，而不考虑其对API或可维护性的影响。</li>
    <li>别名可能造成名称冲突的风险</li>
    <li>别名可能通过给熟悉的构造一个不熟悉的名称而降低可读性</li>
    <li>类型别名可能造成不明确的API契约：
      不清楚别名是否保证与其别名的类型完全相同，
      是否具有相同的API，或者仅在指定的狭窄方式中可用</li>
  </ul>

<p class="decision"></p>
<p>不要仅仅为了在实现中节省打字而将别名放入公共API中；
  只有当你打算让你的客户端使用它时才这样做。</p>
<p>在定义公共别名时，记录新名称的意图，包括它是否保证始终与当前别名的类型相同，或者是否打算更有限的兼容性。这让用户知道他们是否可以将这些类型视为可替代的，或者是否必须遵循更具体的规则，并且可以帮助实现保留一定程度的自由来更改别名。</p>
<p>不要在公共API中放置命名空间别名。（另见<a href="#Namespaces">命名空间</a>）。
</p>

<p>例如，这些别名记录了它们在客户端代码中应如何使用的意图：</p>
<pre>namespace mynamespace {
// 用于存储字段测量值。DataPoint可能从Bar*更改为某种内部类型。
// 客户端代码应将其视为不透明的指针。
using DataPoint = ::foo::Bar*;

// 一组测量值。仅为用户方便而设的别名。
using TimeSeries = std::unordered_set&lt;DataPoint, std::hash&lt;DataPoint&gt;, DataPointComparator&gt;;
}  // namespace mynamespace
</pre>

<p>这些别名没有记录预期用途，其中一半不是为客户端使用准备的：</p>

<pre class="badcode">namespace mynamespace {
// 不好：这些都没有说明它们应如何使用。
using DataPoint = ::foo::Bar*;
using ::std::unordered_set;  // 不好：仅为本地方便
using ::std::hash;           // 不好：仅为本地方便
typedef unordered_set&lt;DataPoint, hash&lt;DataPoint&gt;, DataPointComparator&gt; TimeSeries;
}  // namespace mynamespace
</pre>

<p>然而，本地方便别名在函数定义、<code>private</code>
  类的部分、明确标记为内部的命名空间以及<code>.cc</code>文件中是可以的：</p>

<pre>// 在.cc文件中
using ::foo::Bar;
</pre>

<h3 id="Switch_Statements">Switch语句</h3>

<p>如果不是基于枚举值的条件，switch语句应始终包含一个<code>default</code>情况（在枚举值的情况下，编译器会警告未处理的值）。如果default情况永远不应执行，则将其视为错误。例如：

</p><pre>switch (var) {
  case 0: {
    ...
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    LOG(FATAL) &lt;&lt; "Switch语句中的无效值: " &lt;&lt; var;
  }
}
</pre>

<p>从一个case标签落入另一个case标签必须使用<code>[[fallthrough]];</code>属性进行注释。<code>[[fallthrough]];</code>应放置在执行点上，其中发生落入到下一个case标签的情况。一个常见的例外是连续的case标签之间没有干预代码的情况，在这种情况下不需要注释。</p>

<pre>switch (x) {
  case 41:  // 此处不需要注释。
  case 43:
    if (dont_be_picky) {
      // 使用此替代或与注释一起使用。
      [[fallthrough]];
    } else {
      CloseButNoCigar();
      break;
    }
  case 42:
    DoSomethingSpecial();
    [[fallthrough]];
  default:
    DoSomethingGeneric();
    break;
}
</pre>

<h2 id="Inclusive_Language">包容性语言</h2>

<p>在所有代码中，包括命名和注释，使用包容性语言，避免其他程序员可能认为不尊重或冒犯的术语（如“master”和“slave”，“blacklist”和“whitelist”，或“redline”），即使这些术语也有表面上中性的含义。
同样，除非你指的是特定的人（并使用他们的代词），否则使用性别中立的语言。例如，
对于未指定性别的人使用“they”/“them”/“their”（<a href="https://apastyle.apa.org/style-grammar-guidelines/grammar/singular-they">即使是单数</a>），对于软件、计算机和其他非人的事物使用“it”/“its”。</p>
<h2 id="Naming">命名</h2>

<p>最重要的连贯性规则是那些管理命名规则的。名称的风格立即告诉我们被命名实体是什么类型：类型、变量、函数、常量、宏等，而不需要我们去搜索该实体的声明。我们大脑中的模式匹配引擎在很大程度上依赖于这些命名规则。
</p>

<p>命名规则相当随意，但我们认为在这一领域的一致性比个人偏好更重要，所以无论你认为它们是否合理，规则就是规则。</p>

<h3 id="General_Naming_Rules">通用命名规则</h3>

<p>使用即使对不同团队的人也清晰易懂的名称来优化可读性。</p>

<p>使用描述对象目的或意图的名称。不要担心节省水平空间，因为让新读者立即理解你的代码远比节省空间更重要。尽量减少使用项目外的人可能不了解的缩写（特别是首字母缩写词和缩写词）。不要通过删除单词内部的字母来缩写。作为一个经验法则，如果缩写在维基百科中列出，那么它可能是可以接受的。一般来说，描述性应该与名称的可见范围成比例。例如，在一个5行的函数中，<code>n</code>可能是一个合适的名称，但在类的范围内，它可能过于模糊。</p>

<pre>class MyClass {
 public:
  int CountFooErrors(const std::vector&lt;Foo&gt;&amp; foos) {
    int n = 0;  // 在有限的范围和上下文中具有清晰的含义
    for (const auto&amp; foo : foos) {
      ...
      ++n;
    }
    return n;
  }
  void DoSomethingImportant() {
    std::string fqdn = ...;  // 众所周知的缩写，全限定域名
  }
 private:
  const int kMaxAllowedConnections = ...;  // 在上下文中具有清晰的含义
};
</pre>

<pre class="badcode">class MyClass {
 public:
  int CountFooErrors(const std::vector&lt;Foo&gt;&amp; foos) {
    int total_number_of_foo_errors = 0;  // 在有限的范围和上下文中过于冗长
    for (int foo_index = 0; foo_index &lt; foos.size(); ++foo_index) {  // 使用习惯性的 `i`
      ...
      ++total_number_of_foo_errors;
    }
    return total_number_of_foo_errors;
  }
  void DoSomethingImportant() {
    int cstmr_id = ...;  // 删除内部字母
  }
 private:
  const int kNum = ...;  // 在广泛的范围内含义不清晰
};
</pre>

<p>请注意，某些普遍已知的缩写是可以接受的，例如<code>i</code>作为迭代变量和<code>T</code>作为模板参数。</p>

<p>对于下面的命名规则的目的，一个“单词”是指你会在英语中不带内部空格写的任何东西。这包括缩写，如首字母缩写词和缩写词。对于混合大小写书写的名称（有时也称为“<a href="https://en.wikipedia.org/wiki/Camel_case">驼峰式命名法</a>”或“<a href="https://en.wiktionary.org/wiki/Pascal_case">帕斯卡命名法</a>”），其中每个单词的首字母大写，优选将缩写作为单个单词大写，例如，<code>StartRpc()</code>而不是<code>StartRPC()</code>。</p>

<p>模板参数应遵循其类别的命名风格：类型模板参数应遵循<a href="#Type_Names">类型名称</a>的规则，非类型模板参数应遵循<a href="#Variable_Names">变量名称</a>的规则。

</p><h3 id="File_Names">文件名</h3>

<p>文件名应全部小写，可以包含下划线（<code>_</code>）或连字符（<code>-</code>）。遵循你的项目使用的惯例。如果没有一致的本地模式可遵循，优选“<code>_</code>”。</p>

<p>可接受的文件名示例：</p>

<ul>
  <li><code>my_useful_class.cc</code></li>
  <li><code>my-useful-class.cc</code></li>
  <li><code>myusefulclass.cc</code></li>
  <li><code>myusefulclass_test.cc // _unittest 和 _regtest 已被废弃。</code></li>
</ul>

<p>C++文件应具有<code>.cc</code>文件扩展名，头文件应具有<code>.h</code>扩展名。依赖于在特定点被文本包含的文件应以<code>.inc</code>结尾（另见关于<a href="#Self_contained_Headers">自包含头文件</a>的部分）。</p>

<p>不要使用已存在于<code>/usr/include</code>中的文件名，例如<code>db.h</code>。</p>

<p>一般来说，使你的文件名非常具体。例如，使用<code>http_server_logs.h</code>而不是<code>logs.h</code>。一个非常常见的情况是有一对文件，例如，称为<code>foo_bar.h</code>和<code>foo_bar.cc</code>，定义了一个名为<code>FooBar</code>的类。</p>

<h3 id="Type_Names">类型名称</h3>

<p>类型名称以大写字母开头，每个新单词也以大写字母开头，不使用下划线：<code>MyExcitingClass</code>，<code>MyExcitingEnum</code>。</p>

<p>所有类型的名称——类、结构体、类型别名、枚举和类型模板参数——都遵循相同的命名约定。类型名称应以大写字母开头，每个新单词也以大写字母开头。不使用下划线。例如：</p>

<pre>// 类和结构体
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map&lt;UrlTableProperties *, std::string&gt; PropertiesMap;

// using 别名
using PropertiesMap = hash_map&lt;UrlTableProperties *, std::string&gt;;

// 枚举
enum class UrlTableError { ...
</pre>

<h3 id="Concept_Names">概念名称</h3>

概念名称遵循与<a href="#Type_Names">类型名称</a>相同的规则。
<h3 id="Variable_Names">变量命名</h3>

<p>变量名（包括函数参数）和数据成员的命名使用<code>snake_case</code>（全小写，单词之间用下划线分隔）。类的成员变量（但不包括结构体）还会在末尾加上下划线。例如：<code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>。</p>

<h4>常见变量名</h4>

<p>例如：</p>

<pre>std::string table_name;  // 正确 - 使用snake_case。
</pre>

<pre class="badcode">std::string tableName;   // 错误 - 使用混合大小写。
</pre>

<h4>类数据成员</h4>

<p>类的静态和非静态数据成员的命名与普通非成员变量相同，但会在末尾加上下划线。</p>

<pre>class TableInfo {
  ...
 private:
  std::string table_name_;  // 正确 - 末尾有下划线。
  static Pool&lt;TableInfo&gt;* pool_;  // 正确。
};
</pre>

<h4>结构体数据成员</h4>

<p>结构体的静态和非静态数据成员的命名与普通非成员变量相同。它们没有类数据成员所具有的末尾下划线。</p>

<pre>struct UrlTableProperties {
  std::string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};
</pre>

<p>有关何时使用结构体与类的讨论，请参见<a href="#Structs_vs._Classes">结构体与类</a>。</p>

<h3 id="Constant_Names">常量命名</h3>

<p>声明为<code>constexpr</code>或<code>const</code>且在程序运行期间值固定的变量，应以"k"开头，后跟混合大小写命名。极少数情况下，当无法使用大写字母进行分隔时，可以使用下划线作为分隔符。例如：</p>

<pre>const int kDaysInAWeek = 7;
const int kAndroid8_0_0 = 24;  // Android 8.0.0
</pre>

<p>所有具有静态存储期的此类变量（即静态变量和全局变量，详见<a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">存储期</a>）都应按此方式命名，包括模板中不同实例化可能具有不同值的变量。对于其他存储类的变量（例如自动变量），此约定是可选的；否则，适用通常的变量命名规则。例如：</p>

<pre>void ComputeFoo(absl::string_view suffix) {
  // 这两种方式都可以接受。
  const absl::string_view kPrefix = "prefix";
  const absl::string_view prefix = "prefix";
  ...
}
</pre>

<pre class="badcode">void ComputeFoo(absl::string_view suffix) {
  // 错误 - ComputeFoo的不同调用使kCombined具有不同的值。
  const std::string kCombined = absl::StrCat(kPrefix, suffix);
  ...
}
</pre>

<h3 id="Function_Names">函数命名</h3>

<p>普通函数使用混合大小写命名；访问器和修改器可以像变量一样命名。</p>

<p>通常，函数应以大写字母开头，每个新单词也应大写字母开头。</p>

<pre>AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</pre>

<p>（作为API的一部分暴露且意图看起来像函数的类和命名空间范围的常量也应遵循相同的命名规则，因为它们是对象而不是函数这一事实是一个不重要的实现细节。）</p>

<p>访问器和修改器（获取和设置函数）可以像变量一样命名。这些通常对应于实际的成员变量，但这不是必需的。例如，<code>int count()</code>和<code>void set_count(int count)</code>。</p>

<h3 id="Namespace_Names">命名空间命名</h3>

<p>命名空间名应全部小写，单词之间用下划线分隔。顶级命名空间名应基于项目名称。避免嵌套命名空间与知名顶级命名空间发生冲突。</p>

<p>顶级命名空间的名称通常应为包含在该命名空间中的代码所属的项目或团队的名称。该命名空间中的代码通常应位于与命名空间名称匹配的目录中（或其子目录中）。</p>

<p>请记住，<a href="#General_Naming_Rules">禁止使用缩写名称的规则</a>同样适用于命名空间，就像变量名称一样。命名空间内的代码很少需要提及命名空间名称，因此通常没有特别需要缩写的理由。</p>

<p>避免嵌套命名空间与知名顶级命名空间名称匹配。命名空间名称之间的冲突可能导致由于名称查找规则而出现意外的构建错误。特别是，不要创建任何嵌套的<code>std</code>命名空间。应优先使用独特的项目标识符（如<code>websearch::index</code>，<code>websearch::index_util</code>），而不是容易发生冲突的名称，如<code>websearch::util</code>。还应避免过深的嵌套命名空间（参见<a href="https://abseil.io/tips/130">TotW #130</a>）。</p>

<p>对于<code>internal</code>命名空间，要警惕其他代码被添加到同一个<code>internal</code>命名空间中导致冲突（团队内部的辅助函数往往相关，可能导致冲突）。在这种情况下，使用文件名来创建唯一的内部名称是有帮助的（例如<code>websearch::index::frobber_internal</code>用于<code>frobber.h</code>）。</p>

<h3 id="Enumerator_Names">枚举器命名</h3>

<p>枚举器（对于范围内和范围外的枚举）应像<a href="#Constant_Names">常量</a>一样命名，而不像<a href="#Macro_Names">宏</a>一样命名。即，使用<code>kEnumName</code>而不是<code>ENUM_NAME</code>。</p>

<pre>enum class UrlTableError {
  kOk = 0,
  kOutOfMemory,
  kMalformedInput,
};
</pre>
<pre class="badcode">enum class AlternateUrlTableError {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};
</pre>

<p>直到2009年1月，枚举值的命名风格是像<a href="#Macro_Names">宏</a>一样命名。这导致了枚举值与宏之间的名称冲突问题。因此，改为偏好常量风格命名。新代码应使用常量风格命名。</p>
<h3 id="Macro_Names">宏名称</h3>

<p>你真的打算<a href="#Preprocessor_Macros">定义一个宏</a>吗？如果要定义，它们看起来像这样：
<code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE</code>。
</p>

<p>请参阅<a href="#Preprocessor_Macros">宏的描述</a>；一般来说，不应使用宏。
但是，如果绝对需要，那么它们应该使用全大写和下划线命名，并带有项目特定的前缀。</p>

<pre>#define MYPROJECT_ROUND(x) ...
</pre>

<h3 id="Exceptions_to_Naming_Rules">命名规则的例外</h3>

<p>如果你命名的东西与现有的C或C++实体类似，那么你可以遵循现有的命名约定方案。</p>

<dl>
  <dt><code>bigopen()</code></dt>
  <dd>函数名，遵循<code>open()</code>的形式</dd>

  <dt><code>uint</code></dt>
  <dd><code>typedef</code></dd>

  <dt><code>bigpos</code></dt>
  <dd><code>struct</code>或<code>class</code>，遵循<code>pos</code>的形式</dd>

  <dt><code>sparse_hash_map</code></dt>
  <dd>类似STL的实体；遵循STL命名约定</dd>

  <dt><code>LONGLONG_MAX</code></dt>
  <dd>常量，如<code>INT_MAX</code></dd>
</dl>

<h2 id="Comments">注释</h2>

<p>注释对于保持我们的代码可读性至关重要。以下规则描述了你应该在哪里以及如何添加注释。但请记住：虽然注释非常重要，但最好的代码是自文档化的。给类型和变量赋予有意义的名称远比使用晦涩的名称然后通过注释解释要好得多。</p>

<p>在编写注释时，请为你的读者写作：下一个需要理解你的代码的贡献者。要慷慨——下一个可能是你自己！</p>

<h3 id="Comment_Style">注释风格</h3>

<p>可以使用<code>//</code>或<code>/* */</code>语法，只要你保持一致即可。</p>

<p>你可以使用<code>//</code>或<code>/* */</code>语法；然而，<code>//</code>更为常见。请保持你注释的方式和使用的风格的一致性。</p>

<h3 id="File_Comments">文件注释</h3>

<div>
<p>每个文件应以许可证模板开始。</p>
</div>

<p>如果一个源文件（如<code>.h</code>文件）声明了多个面向用户的抽象（常用函数、相关类等），请包含一个描述这些抽象集合的注释。包含足够的细节，以便未来的作者知道什么不适合放在这里。然而，关于各个抽象的详细文档应与这些抽象一起，而不是在文件级别上。</p>

<p>例如，如果你为<code>frobber.h</code>编写文件注释，你不需要在<code>frobber.cc</code>或<code>frobber_test.cc</code>中包含文件注释。另一方面，如果你在<code>registered_objects.cc</code>中编写了一组没有关联头文件的类，你必须在<code>registered_objects.cc</code>中包含文件注释。

</p><h4>法律声明和作者行</h4>

<div>
<p>每个文件都应包含许可证模板。根据项目使用的许可证（例如，Apache 2.0、BSD、LGPL、GPL）选择适当的模板。</p>
</div>

<p>如果你对带有作者行的文件进行了重大更改，请考虑删除作者行。
新文件通常不应包含版权声明或作者行。</p>

<h3 id="Class_Comments">结构体和类注释</h3>

<p>每个非显而易见的类或结构体声明都应附带一个注释，描述它的用途和使用方法。</p>

<pre>// 遍历GargantuanTable的内容。
// 示例：
//    std::unique_ptr&lt;GargantuanTableIterator&gt; iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
class GargantuanTableIterator {
  ...
};
</pre>

<h4 id="Class_Comments_Details">类注释</h4>

<p>类注释应为读者提供足够的信息，以了解如何以及何时使用该类，以及正确使用该类所需的任何额外考虑。记录类所做的同步假设（如果有）。如果类的实例可以被多个线程访问，请特别注意记录关于多线程使用的规则和不变量。</p>

<p>类注释通常是展示类简单且专注使用的小代码片段的好地方。</p>

<p>当足够分离时（例如，<code>.h</code>和<code>.cc</code>文件），描述类使用方法的注释应与其接口定义一起；关于类操作和实现的注释应伴随类方法的实现。
<h3 id="Function_Comments">函数注释</h3>

<p>声明注释描述函数的使用（当其不明显时）；函数定义处的注释描述操作。</p>

<h4>函数声明</h4>

<p>几乎每个函数声明都应有紧接其前的注释，描述函数的功能和使用方法。这些注释只有在函数简单且明显时（例如，类的明显属性的简单访问器）才可以省略。在<code>.cc</code>文件中声明的私有方法和函数也不例外。函数注释应以隐含的主语<i>此函数</i>来编写，并以动词短语开头；例如，“打开文件”，而不是“打开文件”。一般来说，这些注释不描述函数如何执行其任务。相反，这应该留给函数定义中的注释来解释。</p>

<p>在函数声明处的注释中应提及的事项类型包括：</p>

<ul>
  <li>输入和输出的内容。如果在`反引号`中提供了函数参数名称，那么代码索引工具可能能够更好地呈现文档。</li>

  <li>对于类成员函数：对象是否在方法调用期间之外记住引用或指针参数。这对于构造函数的指针/引用参数非常常见。</li>

  <li>对于每个指针参数，是否允许其为null，以及如果是null会发生什么情况。</li>

  <li>对于每个输出或输入/输出参数，该参数的状态会发生什么变化。（例如，状态是追加还是覆盖？）。</li>

  <li>如果函数的使用方式有任何性能影响。</li>
</ul>

<p>以下是一个示例：</p>

<pre>// 返回此表的迭代器，定位在词典顺序上大于或等于`start_word`的第一个条目。
// 如果没有这样的条目，则返回空指针。客户端在基础GargantuanTable被销毁后不得使用迭代器。
//
// 此方法等同于：
//    std::unique_ptr&lt;Iterator&gt; iter = table-&gt;NewIterator();
//    iter-&gt;Seek(start_word);
//    return iter;
std::unique_ptr&lt;Iterator&gt; GetIterator(absl::string_view start_word) const;
</pre>

<p>然而，不要不必要地冗长或陈述完全显而易见的事情。</p>

<p>在记录函数重写时，应关注重写本身的具体细节，而不是重复被重写函数的注释。在许多情况下，重写不需要额外的文档，因此不需要注释。</p>

<p>在注释构造函数和析构函数时，请记住，阅读您的代码的人知道构造函数和析构函数的用途，因此仅说明“销毁此对象”这样的注释没有用。记录构造函数对其参数的处理（例如，如果它们接管指针的所有权），以及析构函数进行的清理工作。如果这是微不足道的，就跳过注释。析构函数通常没有头部注释是很常见的。</p>

<h4>函数定义</h4>

<p>如果函数执行其工作的方式有任何技巧性，函数定义应有解释性注释。例如，在定义注释中，您可以描述所使用的任何编码技巧，概述您经历的步骤，或者解释为什么您选择以这种方式而不是使用可行的替代方案来实现函数。例如，您可以提到为什么它必须在函数的前半部分获取锁，而在后半部分不需要锁。</p>

<p>请注意，您不应只是重复在函数声明中给出的注释，在<code>.h</code>文件或其他地方。简要重述函数的功能是可以的，但注释的重点应放在它是如何做的上。</p>

<h3 id="Variable_Comments">变量注释</h3>

<p>一般来说，变量的实际名称应该足以清楚地说明变量的用途。在某些情况下，需要更多的注释。</p>

<h4>类数据成员</h4>

<p>每个类数据成员（也称为实例变量或成员变量）的目的必须清晰。如果有任何不明确表达的类型和名称的不变量（特殊值、成员之间的关系、生命周期要求），必须进行注释。然而，如果类型和名称足够（<code>int num_events_;</code>），则不需要注释。</p>

<p>特别是，当存在和含义不明显的哨兵值（如nullptr或-1）时，应添加注释进行描述。例如：</p>

<pre>private:
 // 用于边界检查表访问。-1表示我们还不知道表有多少条目。
 int num_total_entries_;
</pre>

<h4>全局变量</h4>

<p>所有全局变量都应有注释，描述它们是什么，用于什么，以及（如果不清楚）为什么它们需要是全局的。例如：</p>

<pre>// 在此回归测试中我们运行的测试用例总数。
const int kNumTestCases = 6;
</pre>
<h3 id="Implementation_Comments">实现注释</h3>

<p>在您的实现中，您应该在代码中棘手、不明显、有趣或重要的部分添加注释。</p>

<h4>解释性注释</h4>

<p>棘手或复杂的代码块应该在其前面添加注释。</p>

<h4 class="stylepoint_subsection" id="Function_Argument_Comments">函数参数注释</h4>

<p>当函数参数的含义不明显时，请考虑以下解决方案之一：</p>

<ul>
  <li>如果参数是一个字面常量，并且在多个函数调用中以隐式假设它们相同的形式使用，您应该使用命名常量来明确这种约束，并保证其有效性。</li>

  <li>考虑更改函数签名，将<code>bool</code>参数替换为<code>enum</code>参数。这将使参数值自描述。</li>

  <li>对于具有多个配置选项的函数，考虑定义一个单一的类或结构来保存所有选项，并传递该类的实例。这种方法有几个优点。选项在调用点通过名称引用，这能澄清其含义。它还减少了函数参数数量，使函数调用更易于阅读和编写。作为额外的好处，当您添加另一个选项时，不必更改调用点。</li>

  <li>用命名变量替换大型或复杂的嵌套表达式。</li>

  <li>作为最后的手段，使用注释在调用点澄清参数含义。</li>
</ul>

考虑以下示例：

<pre class="badcode">// 这些参数是什么？
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</pre>

<p>与之对比：</p>

<pre>ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</pre>

<h4 id="Implementation_Comment_Donts">不要这样做</h4>

<p>不要陈述显而易见的事情。特别是，除非行为对熟悉C++的读者来说不明显，否则不要逐字描述代码做了什么。相反，提供更高层次的注释，描述代码为何这样做，或者使代码自描述。</p>

比较以下内容：

<pre class="badcode">// 在向量中查找元素。  &lt;-- 不好：显而易见！
if (std::find(v.begin(), v.end(), element) != v.end()) {
  Process(element);
}
</pre>

与此对比：

<pre>// 除非“element”已被处理，否则处理它。
if (std::find(v.begin(), v.end(), element) != v.end()) {
  Process(element);
}
</pre>

<p>自描述的代码不需要注释。上面的示例中的注释将是显而易见的：</p>

<pre>if (!IsAlreadyProcessed(element)) {
  Process(element);
}
</pre>

<h3 id="Punctuation,_Spelling_and_Grammar">标点符号、拼写和语法</h3>

<p>注意标点符号、拼写和语法；阅读写得好的注释比阅读写得差的注释更容易。</p>

<p>注释应该像叙述性文本一样易读，具有适当的大写和标点符号。在许多情况下，完整的句子比句子片段更易读。较短的注释，例如代码行末尾的注释，有时可以不太正式，但您应该保持风格的一致性。</p>

<p>尽管代码审查者指出您使用逗号时应该使用分号可能会令人沮丧，但保持源代码的高度清晰和可读性非常重要。正确的标点符号、拼写和语法有助于实现这一目标。</p>

<h3 id="TODO_Comments">TODO注释</h3>

<p>使用<code>TODO</code>注释来标记临时、短期解决方案或足够好但不完美的代码。</p>

<p><code>TODO</code>应包含全大写的<code>TODO</code>字符串，后跟关于<code>TODO</code>引用的问题的最佳上下文的人员或问题的错误ID、姓名、电子邮件地址或其他标识符。</p>

<div>
<pre>// TODO: bug 12345678 - 在2047q4兼容性窗口期满后删除此代码。
// TODO: example.com/my-design-doc - 下次触及此代码时手动修复。
// TODO(bug 12345678): 在Foo服务关闭后更新此列表。
// TODO(John): 在这里使用“*”作为连接运算符。
</pre>
</div>

<p>如果您的<code>TODO</code>是“在未来某个日期做某事”的形式，请确保您包含一个非常具体的日期（“在2005年11月之前修复”）或一个非常具体的事件（“当所有客户端都能处理XML响应时删除此代码。”）。</p>

<h2 id="Formatting">格式化</h2>

<p>编码风格和格式化相当随意，但如果每个人都使用相同的风格，项目会更容易遵循。个人可能不同意格式化规则的每一个方面，有些规则可能需要一些时间来适应，但重要的是所有项目贡献者都遵循风格规则，以便他们都能轻松阅读和理解每个人的代码。</p>

<div>
<p>为了帮助您正确格式化代码，我们创建了一个<a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">emacs设置文件</a>。</p>
</div>
<h3 id="Line_Length">行长度</h3>

<p>代码中的每一行文本应最多为80个字符长。</p>

<div>
<p>我们认识到这条规则是有争议的，但现有的大量代码已经遵循了它，我们认为一致性很重要。</p>
</div>

<p class="pros"></p>
<p>支持这条规则的人认为，强迫他们调整窗口大小是不礼貌的，而且没有必要使用更长的行。有些人习惯于并排打开多个代码窗口，因此无论如何都没有空间来扩大他们的窗口。人们设置工作环境时假设了一个特定的最大窗口宽度，80列一直是传统标准。为什么要改变它呢？</p>

<p class="cons"></p>
<p>支持改变的人认为，更宽的行可以使代码更易读。80列限制是1960年代大型机的顽固回归；现代设备有宽屏，可以轻松显示更长的行。</p>

<p class="decision"></p>
<p>最大长度为80个字符。</p>

<p>如果一行满足以下条件，可以超过80个字符：</p>

<ul>
  <li>注释行，如果将其拆分会损害可读性、剪切和粘贴的便利性或自动链接功能——例如，如果一行包含一个示例命令或一个超过80个字符的字面URL。</li>

  <li>无法轻松在80列处换行的字符串字面量。这可能是因为它包含URI或其他语义关键部分，或者因为字面量包含嵌入式语言，或者多行字面量中的换行符具有重要意义，如帮助消息。在这些情况下，分割字面量会降低可读性、可搜索性、点击链接的能力等。除了测试代码外，此类字面量应出现在文件顶部的命名空间范围内。如果像Clang-Format这样的工具无法识别不可分割的内容，请在必要时<a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html#disabling-formatting-on-a-piece-of-code">禁用工具</a>。
  <br><br>
  （我们必须在这种字面量的可用性/可搜索性与它们周围代码的可读性之间取得平衡。）
  </li>

  <li>包含语句。</li>

  <li>一个<a href="#The__define_Guard">头文件保护</a></li>

  <li>一个using声明</li>
</ul>

<h3 id="Non-ASCII_Characters">非ASCII字符</h3>

<p>非ASCII字符应很少使用，且必须使用UTF-8格式。</p>

<p>您不应在源代码中硬编码面向用户的文本，即使是英文，因此使用非ASCII字符的情况应该很少。然而，在某些情况下，在代码中包含此类词语是合适的。例如，如果您的代码解析来自外国的数据文件，可能适合硬编码这些数据文件中用作分隔符的非ASCII字符串。更常见的是，单元测试代码（不需要本地化）可能包含非ASCII字符串。在这种情况下，您应该使用UTF-8，因为这是大多数能够处理ASCII以外内容的工具都能理解的编码格式。</p>

<p>十六进制编码也是可以的，并且在增强可读性的地方是鼓励的——例如，<code>"\xEF\xBB\xBF"</code>，或者更简单地，<code>"\uFEFF"</code>，是Unicode零宽度不换行空格字符，如果以直接的UTF-8形式包含在源代码中，将是不可见的。</p>

<p>尽可能避免使用<code>u8</code>前缀。从C++20开始，它的语义与C++17相比有显著不同，生成的是<code>char8_t</code>数组而不是<code>char</code>数组，并且在C++23中还会再次改变。</p>

<p>您不应使用<code>char16_t</code>和<code>char32_t</code>字符类型，因为它们用于非UTF-8文本。出于类似的原因，您也不应使用<code>wchar_t</code>（除非您正在编写与广泛使用<code>wchar_t</code>的Windows API交互的代码）。</p>

<h3 id="Spaces_vs._Tabs">空格与制表符</h3>

<p>只使用空格，每次缩进2个空格。</p>

<p>我们使用空格进行缩进。不要在代码中使用制表符。您应该设置编辑器在按下制表键时发出空格。</p>
<h3 id="Function_Declarations_and_Definitions">函数声明和定义</h3>

<p>返回类型与函数名在同一行，参数如果能在一行内显示则与函数名在同一行。无法在一行内显示的参数列表应像函数调用中的参数一样换行处理。</p>

<p>函数的格式如下：</p>

<pre>ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
</pre>

<p>如果一行内文本过多：</p>

<pre>ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}
</pre>

<p>或者如果连第一个参数都无法在一行内显示：</p>

<pre>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 个空格缩进
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 个空格缩进
  ...
}
</pre>

<p>需要注意的几点：</p>

<ul>
  <li>选择好的参数名称。</li>

  <li>只有在函数定义中未使用参数时，才可以省略参数名称。</li>

  <li>如果返回类型和函数名无法在一行内显示，应在它们之间换行。</li>

  <li>如果在函数声明或定义的返回类型后换行，不应缩进。</li>

  <li>左括号始终与函数名在同一行。</li>

  <li>函数名与左括号之间永远没有空格。</li>

  <li>括号与参数之间永远没有空格。</li>

  <li>左大括号始终在函数声明的最后一行的末尾，而不是下一行的开头。</li>

  <li>右大括号要么单独在一行，要么与左大括号在同一行。</li>

  <li>右括号与左大括号之间应有一个空格。</li>

  <li>如果可能，所有参数应对齐。</li>

  <li>默认缩进为 2 个空格。</li>

  <li>换行的参数应有 4 个空格缩进。</li>
</ul>

<p>从上下文中显然未使用的参数可以省略：</p>

<pre>class Foo {
 public:
  Foo(const Foo&amp;) = delete;
  Foo&amp; operator=(const Foo&amp;) = delete;
};
</pre>

<p>可能不明显的未使用参数应在函数定义中注释掉变量名：</p>

<pre>class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}
</pre>

<pre class="badcode">// 错误 - 如果有人以后想实现，不清楚变量的含义。
void Circle::Rotate(double) {}
</pre>

<p>属性和扩展为属性的宏应出现在函数声明或定义的最前面，在返回类型之前：</p>
<pre>  ABSL_ATTRIBUTE_NOINLINE void ExpensiveFunction();
  [[nodiscard]] bool IsOk();
</pre>

<h3 id="Formatting_Lambda_Expressions">Lambda 表达式</h3>

<p>参数和主体应像任何其他函数一样格式化，捕获列表应像其他逗号分隔的列表一样格式化。</p>

<p>对于引用捕获，不应在与符号（<code>&amp;</code>）和变量名之间留空格。</p>
<pre>int x = 0;
auto x_plus_n = [&amp;x](int n) -&gt; int { return x + n; }
</pre>
<p>短的 lambda 表达式可以作为函数参数内联编写。</p>
<pre>absl::flat_hash_set&lt;int&gt; to_remove = {7, 8, 9};
std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;to_remove](int i) {
               return to_remove.contains(i);
             }),
             digits.end());
</pre>

<h3 id="Floating_Literals">浮点字面量</h3>

<p>浮点字面量应始终有一个小数点，两边都有数字，即使它们使用指数表示法。所有浮点字面量采用这种熟悉的形式可以提高可读性，因为这有助于确保它们不会被误认为是整数字面量，并且指数表示法的 <code>E</code>/<code>e</code> 不会被误认为是十六进制数字。用整数字面量初始化浮点变量是可以的（假设变量类型可以精确表示该整数），但请注意，指数表示法的数字永远不是整数字面量。
</p>

<pre class="badcode">float f = 1.f;
long double ld = -.5L;
double d = 1248e6;
</pre>

<pre class="goodcode">float f = 1.0f;
float f2 = 1.0;  // 也可
float f3 = 1;    // 也可
long double ld = -0.5L;
double d = 1248.0e6;
</pre>
<h3 id="Function_Calls">函数调用</h3>

<p>要么将调用写在一行上，要么在括号处换行，要么将参数从新的一行开始，并缩进四个空格，然后继续保持四个空格的缩进。在没有其他考虑的情况下，使用最少的行数，包括在适当的情况下将多个参数放在同一行上。</p>

<p>函数调用的格式如下：</p>
<pre>bool result = DoSomething(argument1, argument2, argument3);
</pre>

<p>如果参数不能全部在一行上显示，它们应该分成多行，每个后续行与第一个参数对齐。不要在左括号后或右括号前添加空格：</p>
<pre>bool result = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
</pre>

<p>参数可以选择性地全部放在后续行上，并缩进四个空格：</p>
<pre>if (...) {
  ...
  ...
  if (...) {
    bool result = DoSomething(
        argument1, argument2,  // 4个空格缩进
        argument3, argument4);
    ...
  }
</pre>

<p>将多个参数放在一行上以减少调用函数所需的行数，除非存在特定的可读性问题。有些人认为严格地将每个参数放在一行上更易读，并且简化了参数的编辑。然而，我们优先考虑读者的需求而不是编辑参数的便利性，大多数可读性问题可以通过以下技术更好地解决。</p>

<p>如果将多个参数放在一行上由于某些参数的表达式复杂或令人困惑而降低了可读性，请尝试创建变量来捕获这些参数，并使用描述性名称：</p>
<pre>int my_heuristic = scores[x] * y + bases[x];
bool result = DoSomething(my_heuristic, x, y, z);
</pre>

<p>或者将令人困惑的参数单独放在一行，并添加解释性注释：</p>
<pre>bool result = DoSomething(scores[x] * y + bases[x],  // 分数启发式。
                          x, y, z);
</pre>

<p>如果仍然存在一个参数在单独一行上显著提高可读性的情况，那么就将其放在单独一行上。该决定应针对使该参数更易读的情况，而不是一般政策。</p>

<p>有时参数形成对可读性重要的结构。在这些情况下，可以根据该结构来格式化参数：</p>
<pre>// 通过3x3矩阵变换小部件。
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</pre>

<h3 id="Braced_Initializer_List_Format">大括号初始化列表格式</h3>

<p>格式化大括号初始化列表就像格式化其位置上的函数调用一样。</p>

<p>如果大括号列表跟在一个名称之后（例如，类型或变量名称），则格式化为该名称的函数调用的括号。如果没有名称，假设名称长度为零。</p>

<pre>// 单行上的大括号初始化列表示例。
return {foo, bar};
functioncall({foo, bar});
std::pair&lt;int, int&gt; p{foo, bar};

// 当需要换行时。
SomeFunction(
    {"假设在{之前有一个零长度的名称"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"假设在{之前有一个零长度的名称"},
    SomeOtherType{
        "非常长的字符串需要周围的换行。",
        some, other, values},
    SomeOtherType{"稍微短一些的字符串",
                  some, other, values}};
SomeType variable{
    "这太长了，无法在一行中显示"};
MyType m = {  // 这里，您也可以在{之前换行。
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</pre>

<a id="Conditionals"></a>
<h3 id="Formatting_Looping_Branching">循环和分支语句</h3>

<p>从高层次来看，循环或分支语句包括以下<strong>组件</strong>：
</p><ul>
  <li>一个或多个<strong>语句关键字</strong>（例如 <code>if</code>、<code>else</code>、<code>switch</code>、<code>while</code>、<code>do</code> 或 <code>for</code>）。</li>
  <li>一个<strong>条件或迭代说明符</strong>，位于括号内。</li>
  <li>一个或多个<strong>受控语句</strong>，或受控语句块。</li>
</ul>
对于这些语句：

<ul>
  <li>语句的组件之间应使用单个空格（而不是换行符）分隔。</li>
  <li>在条件或迭代说明符内，每个分号与下一个标记之间应有一个空格（或换行符），除非该标记是闭合括号或另一个分号。</li>
  <li>在条件或迭代说明符内，开口括号后和闭合括号前不要加空格。</li>
  <li>将任何受控语句放入块中（即使用花括号）。</li>
  <li>在受控块内，开口花括号后立即换行，闭合花括号前立即换行。</li>
</ul>

<pre>if (condition) {                   // 良好 - 括号内无空格，花括号前有空格。
  DoOneThing();                    // 良好 - 缩进两个空格。
  DoAnotherThing();
} else if (int a = f(); a != 3) {  // 良好 - 闭合花括号在新行，else 在同一行。
  DoAThirdThing(a);
} else {
  DoNothing();
}

// 良好 - 相同的规则适用于循环。
while (condition) {
  RepeatAThing();
}

// 良好 - 相同的规则适用于循环。
do {
  RepeatAThing();
} while (condition);

// 良好 - 相同的规则适用于循环。
for (int i = 0; i &lt; 10; ++i) {
  RepeatAThing();
}
</pre>

<pre class="badcode">if(condition) {}                   // 错误 - `if` 后缺少空格。
else if ( condition ) {}           // 错误 - 括号与条件之间有空格。
else if (condition){}              // 错误 - 花括号前缺少空格。
else if(condition){}               // 错误 - 多个空格缺失。

for (int a = f();a == 10) {}       // 错误 - 分号后缺少空格。

// 错误 - `if ... else` 语句没有处处使用花括号。
if (condition)
  foo;
else {
  bar;
}

// 错误 - `if` 语句太长，不能省略花括号。
if (condition)
  // 注释
  DoSomething();

// 错误 - `if` 语句太长，不能省略花括号。
if (condition1 &amp;&amp;
    condition2)
  DoSomething();
</pre>

<p>由于历史原因，我们允许上述规则的一个例外：如果整个语句出现在单行上（在这种情况下，闭合括号与受控语句之间有一个空格）或两行上（在这种情况下，闭合括号后换行且没有花括号），则可以省略受控语句的花括号或花括号内的换行符。</p>

<pre class="neutralcode">// 可以 - 适合一行。
if (x == kFoo) { return new Foo(); }

// 可以 - 在这种情况下，花括号是可选的。
if (x == kFoo) return new Foo();

// 可以 - 条件适合一行，主体适合另一行。
if (x == kBar)
  Bar(arg1, arg2, arg3);
</pre>

<p>此例外不适用于多关键字语句，如 <code>if ... else</code> 或 <code>do ... while</code>。</p>

<pre class="badcode">// 错误 - `if ... else` 语句缺少花括号。
if (x) DoThis();
else DoThat();

// 错误 - `do ... while` 语句缺少花括号。
do DoThis();
while (x);
</pre>

<p>仅当语句简短时才使用这种样式，并考虑到具有复杂条件或受控语句的循环和分支语句可能使用花括号更易读。有些项目要求始终使用花括号。</p>

<p><code>switch</code> 语句中的 <code>case</code> 块可以有或没有花括号，根据您的偏好。如果您确实包含了花括号，它们的放置应如以下所示。</p>

<pre>switch (var) {
  case 0: {  // 缩进两个空格
    Foo();   // 缩进四个空格
    break;
  }
  default: {
    Bar();
  }
}
</pre>

<p>空循环体应使用一对空花括号或不带花括号的 <code>continue</code>，而不是单个分号。</p>

<pre>while (condition) {}  // 良好 - `{}` 表示无逻辑。
while (condition) {
  // 注释也是可以的
}
while (condition) continue;  // 良好 - `continue` 表示无逻辑。
</pre>

<pre class="badcode">while (condition);  // 错误 - 看起来像是 `do-while` 循环的一部分。
</pre>
<h3 id="Pointer_and_Reference_Expressions">指针和引用表达式</h3>

<p>在句点或箭头周围没有空格。指针操作符后面没有空格。</p>

<p>以下是正确格式化的指针和引用表达式的示例：</p>

<pre>x = *p;
p = &amp;x;
x = r.y;
x = r-&gt;y;
</pre>

<p>请注意：</p>

<ul>
  <li>访问成员时，句点或箭头周围没有空格。</li>

   <li>指针操作符在<code>*</code>或<code>&amp;</code>之后没有空格。</li>
</ul>

<p>当引用指针或引用（变量声明或定义、参数、返回类型、模板参数等）时，可以在星号/与号前后放置空格。在尾随空格样式中，某些情况下（如模板参数等）会省略空格。</p>

<pre>// 这些是可以的，空格在前。
char *c;
const std::string &amp;str;
int *GetPointer();
std::vector&lt;char *&gt;

// 这些是可以的，空格在后（或省略）。
char* c;
const std::string&amp; str;
int* GetPointer();
std::vector&lt;char*&gt;  // 注意'*'和'&gt;'之间没有空格
</pre>

<p>您应该在一个文件内保持一致。
修改现有文件时，请使用该文件中的样式。</p>

<p>允许（尽管不常见）在同一声明中声明多个变量，但如果这些变量中有任何指针或引用修饰，则不允许这样做。这类声明容易被误读。</p>
<pre>// 如果有助于可读性，这是可以的。
int x, y;
</pre>
<pre class="badcode">int x, *y;  // 不允许 - 多重声明中没有&amp;或*
int* x, *y;  // 不允许 - 多重声明中没有&amp;或*；空格不一致
char * c;  // 错误 - *两侧都有空格
const std::string &amp; str;  // 错误 - &amp;两侧都有空格
</pre>

<h3 id="Boolean_Expressions">布尔表达式</h3>

<p>当您有一个比<a href="#Line_Length">标准行长度</a>更长的布尔表达式时，请一致地分行处理。</p>

<p>在这个例子中，逻辑与操作符总是位于行尾：</p>

<pre>if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</pre>

<p>请注意，在这个例子中，当代码换行时，两个<code>&amp;&amp;</code>逻辑与操作符都位于行尾。这在Google代码中更为常见，尽管将所有操作符换行到行首也是允许的。适当插入额外的括号可以提高可读性，但要小心不要过度使用。还要注意，您应该始终使用标点操作符，如<code>&amp;&amp;</code>和<code>~</code>，而不是单词操作符，如<code>and</code>和<code>compl</code>。</p>

<h3 id="Return_Values">返回值</h3>

<p>不需要在<code>return</code>表达式周围无谓地添加括号。</p>

<p>只有在<code>x = expr;</code>中使用括号时，才在<code>return expr;</code>中使用括号。</p>

<pre>return result;                  // 简单情况下不使用括号。
// 括号可以使复杂表达式更易读。
return (some_long_condition &amp;&amp;
        another_condition);
</pre>

<pre class="badcode">return (value);                // 您不会写 var = (value);
return(result);                // return 不是函数！
</pre>

<h3 id="Variable_and_Array_Initialization">变量和数组初始化</h3>

<p>您可以选择<code>=</code>、<code>()</code>和<code>{}</code>；以下都是正确的：</p>

<pre>int x = 3;
int x(3);
int x{3};
std::string name = "Some Name";
std::string name("Some Name");
std::string name{"Some Name"};
</pre>

<p>在具有<code>std::initializer_list</code>构造函数的类型上使用大括号初始化列表<code>{...}</code>时要小心。
非空的<i>大括号初始化列表</i>尽可能优先使用<code>std::initializer_list</code>构造函数。请注意，空大括号<code>{}</code>是特殊的，如果有可用的默认构造函数，将调用默认构造函数。要强制使用非<code>std::initializer_list</code>构造函数，请使用括号而不是大括号。</p>

<pre>std::vector&lt;int&gt; v(100, 1);  // 包含100个项的向量：全部为1。
std::vector&lt;int&gt; v{100, 1};  // 包含2个项的向量：100和1。
</pre>

<p>此外，大括号形式可以防止整数类型的缩小转换。这可以防止某些类型的编程错误。</p>

<pre>int pi(3.14);  // 可以 - pi == 3。
int pi{3.14};  // 编译错误：缩小转换。
</pre>

<h3 id="Preprocessor_Directives">预处理器指令</h3>

<p>开始预处理器指令的哈希标记应始终位于行首。</p>

<p>即使预处理器指令位于缩进代码的主体中，指令也应从行首开始。</p>

<pre>// 良好 - 指令位于行首
  if (lopsided_score) {
#if DISASTER_PENDING      // 正确 - 从行首开始
    DropEverything();
# if NOTIFY               // 可以但不是必需的 - #后有空格
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
</pre>

<pre class="badcode">// 错误 - 缩进的指令
  if (lopsided_score) {
    #if DISASTER_PENDING  // 错误！"#if"应位于行首
    DropEverything();
    #endif                // 错误！不要缩进"#endif"
    BackToNormal();
  }
</pre>
<h3 id="Class_Format">类格式</h3>

<p>按<code>public</code>、<code>protected</code>和<code>private</code>顺序排列各部分，每部分缩进一个空格。</p>

<p>类定义的基本格式（不包括注释，关于需要哪些注释，请参见<a href="#Class_Comments">类注释</a>的讨论）是：</p>

<pre>class MyClass : public OtherClass {
 public:      // 注意缩进1个空格！
  MyClass();  // 常规2个空格缩进。
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</pre>

<p>需要注意的事项：</p>

<ul>
  <li>任何基类名应与子类名在同一行，受80列限制的影响。</li>

  <li><code>public:</code>、<code>protected:</code>和<code>private:</code>关键字应缩进一个空格。</li>

  <li>除了第一次出现外，这些关键字之前应有一个空行。在小类中，此规则是可选的。</li>

  <li>这些关键字之后不要留空行。</li>

  <li><code>public</code>部分应在最前面，其次是<code>protected</code>，最后是<code>private</code>部分。</li>

  <li>有关在这些部分内声明顺序的规则，请参见<a href="#Declaration_Order">声明顺序</a>。</li>
</ul>

<h3 id="Constructor_Initializer_Lists">构造函数初始化列表</h3>

<p>构造函数初始化列表可以全部在一行上，也可以后续行缩进四个空格。</p>

<p>初始化列表的可接受格式是：</p>

<pre>// 当所有内容在一行上时：
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// 如果签名和初始化列表不在一行上，
// 必须在冒号前换行并缩进4个空格：
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// 当列表跨多行时，将每个成员放在单独一行上并对齐：
MyClass::MyClass(int var)
    : some_var_(var),             // 缩进4个空格
      some_other_var_(var + 1) {  // 对齐
  DoSomething();
}

// 与任何其他代码块一样，如果适合，关闭大括号可以与打开大括号在同一行：
MyClass::MyClass(int var)
    : some_var_(var) {}
</pre>

<h3 id="Namespace_Formatting">命名空间格式</h3>

<p>命名空间的内容不缩进。</p>

<p><a href="#Namespaces">命名空间</a>不增加额外的缩进级别。例如，使用：</p>

<pre>namespace {

void foo() {  // 正确。命名空间内没有额外缩进。
  ...
}

}  // namespace
</pre>

<p>不要在命名空间内缩进：</p>

<pre class="badcode">namespace {

  // 错误！不应该缩进。
  void foo() {
    ...
  }

}  // namespace
</pre>

<h3 id="Horizontal_Whitespace">水平空白</h3>

<p>水平空白的使用取决于位置。永远不要在行尾添加尾随空白。</p>

<h4>一般</h4>

<pre>int i = 0;  // 行尾注释前有两个空格。

void f(bool b) {  // 打开大括号前总是有一个空格。
  ...
int i = 0;  // 分号前通常没有空格。
// 大括号初始化列表内的空格是可选的。如果使用它们，
// 请在两边都使用！
int x[] = { 0 };
int x[] = {0};

// 继承和初始化列表中的冒号周围有空格。
class Foo : public Bar {
 public:
  // 对于内联函数实现，在大括号和实现本身之间放置空格。
  Foo(int b) : Bar(), baz_(b) {}  // 空大括号内没有空格。
  void Reset() { baz_ = 0; }  // 大括号与实现之间有空格。
  ...
</pre>

<p>添加尾随空白可能会给编辑同一文件的其他人带来额外的工作，因为他们在合并时会遇到问题，同样，删除现有的尾随空白也会如此。因此：不要引入尾随空白。如果你已经在更改那行，就删除它，或者在单独的清理操作中进行（最好是当没有其他人正在处理该文件时）。</p>

<h4>循环和条件语句</h4>

<pre>if (b) {          // 条件和循环中的关键字后有空格。
} else {          // else 周围有空格。
}
while (test) {}   // 括号内通常没有空格。
switch (i) {
for (int i = 0; i &lt; 5; ++i) {
// 循环和条件语句可能在括号内有空格，但这种情况很少。保持一致性。
switch ( i ) {
if ( test ) {
for ( int i = 0; i &lt; 5; ++i ) {
// for 循环在分号后总是有一个空格。分号前可能有一个空格，但这种情况很少见。
for ( ; i &lt; 5 ; ++i) {
  ...

// 基于范围的 for 循环在冒号前后总是有一个空格。
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // switch case 中的冒号前没有空格。
    ...
  case 2: break;  // 如果冒号后有代码，则使用空格。
</pre>

<h4>运算符</h4>

<pre>// 赋值运算符周围总是有空格。
x = 0;

// 其他二元运算符周围通常有空格，但可以删除因子的周围空格。括号内不应有填充。
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// 一元运算符与其参数之间没有空格。
x = -5;
++x;
if (x &amp;&amp; !y)
  ...
</pre>

<h4>模板和类型转换</h4>

<pre>// 尖括号（&lt;和&gt;）内没有空格，&lt;前没有空格，类型转换中的&gt;(之间没有空格
std::vector&lt;std::string&gt; x;
y = static_cast&lt;char*&gt;(x);

// 类型和指针之间的空格是可以的，但要保持一致。
std::vector&lt;char *&gt; x;
</pre>
<h3 id="Vertical_Whitespace">垂直空白</h3>

<p>尽量减少垂直空白的使用。</p>

<p>这更像是一个原则而不是规则：在不需要时不要使用空行。特别是，不要在函数之间放置超过一到两行的空行，避免以空行开始函数，不要以空行结束函数，并且谨慎使用空行。代码块中的空行就像散文中的段落分隔符：视觉上分隔了两个想法。</p>

<p>基本原则是：屏幕上显示的代码越多，跟踪和理解程序的控制流程就越容易。有目的地使用空白来在流程中提供分隔。</p>

<p>以下是一些关于何时可能有用空行的经验法则：</p>

<ul>
  <li>函数开头或结尾的空行对可读性没有帮助。</li>

  <li>在if-else块链中使用空行可能有助于提高可读性。</li>

  <li>在注释行之前的空行通常有助于提高可读性——新注释的引入表明了一个新想法的开始，空行使其明确该注释与后面的内容相关，而不是前面的内容。</li>

  <li>在命名空间或命名空间块声明内的空行可能通过视觉上将承重内容与（主要是非语义的）组织包装分开来提高可读性。特别是当命名空间内的第一个声明之前有一个注释时，这成为前一条规则的一个特例，帮助注释“附着”到后续的声明上。</li>
</ul>

<h2 id="Exceptions_to_the_Rules">规则的例外</h2>

<p>上述编码约定是强制性的。然而，像所有好的规则一样，这些规则有时也有例外，我们在这里讨论这些例外情况。</p>

<div>
<h3 id="Existing_Non-conformant_Code" class="no-toc">现有不符合规范的代码</h3>

<p>在处理不符合此风格指南的代码时，您可以偏离这些规则。</p>

<p>如果您发现自己正在修改按照与此指南不同的规范编写的代码，您可能需要偏离这些规则以保持与该代码中的本地约定一致。如果您对如何做到这一点有疑问，请咨询原始作者或当前负责该代码的人。请记住，<em>一致性</em>也包括本地一致性。</p>

</div>

<h3 id="Windows_Code">Windows代码</h3>

<p>Windows程序员已经开发了他们自己的编码约定，主要源自Windows头文件和其他Microsoft代码。我们希望任何人都能理解您的代码，因此我们为在任何平台上编写C++的每个人提供了一套单一的指导方针。</p>

<p>值得重申一些您可能在习惯了普遍的Windows风格后会忘记的指导方针：</p>

<ul>
  <li>不要使用匈牙利命名法（例如，将整数命名为<code>iNum</code>）。使用Google命名约定，包括源文件的<code>.cc</code>扩展名。</li>

  <li>Windows定义了许多自己的原始类型同义词，如<code>DWORD</code>、<code>HANDLE</code>等。在调用Windows API函数时使用这些类型是完全可以接受的，并且是鼓励的。即便如此，尽可能接近底层的C++类型。例如，使用<code>const TCHAR *</code>而不是<code>LPCTSTR</code>。</li>

  <li>在使用Microsoft Visual C++编译时，将编译器设置为警告级别3或更高，并将所有警告视为错误。</li>

  <li>不要使用<code>#pragma once</code>；而是使用标准的Google包含保护。包含保护中的路径应相对于您的项目树顶部。</li>

  <li>实际上，除非绝对必要，否则不要使用任何非标准扩展，如<code>#pragma</code>和<code>__declspec</code>。使用<code>__declspec(dllimport)</code>和<code>__declspec(dllexport)</code>是允许的；然而，您必须通过如<code>DLLIMPORT</code>和<code>DLLEXPORT</code>这样的宏来使用它们，以便有人可以轻松地禁用这些扩展，如果他们共享代码的话。</li>
</ul>

<p>然而，在Windows上我们偶尔需要打破的规则只有几条：</p>

<ul>
  <li>通常我们<a href="#Multiple_Inheritance">强烈不鼓励使用多重实现继承</a>；然而，在使用COM和一些ATL/WTL类时这是必需的。您可以使用多重实现继承来实现COM或ATL/WTL类和接口。</li>

  <li>虽然您不应在自己的代码中使用异常，但在ATL和一些STL中广泛使用，包括随Visual C++提供的STL。在使用ATL时，您应该定义<code>_ATL_NO_EXCEPTIONS</code>来禁用异常。您应该调查是否也可以在您的STL中禁用异常，但如果不能，可以在编译器中启用异常。（请注意，这只是为了让STL能够编译。您仍然不应自己编写异常处理代码。）</li>

  <li>处理预编译头文件的常用方法是在每个源文件顶部包含一个头文件，通常命名为<code>StdAfx.h</code>或<code>precompile.h</code>。为了使您的代码更容易与其他项目共享，避免显式包含此文件（除了在<code>precompile.cc</code>中），并使用<code>/FI</code>编译器选项自动包含该文件。</li>

  <li>资源头文件，通常命名为<code>resource.h</code>且仅包含宏，不需要遵循这些风格指南。</li>
</ul>
</div>
</body>
</html>